<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="ODP, 1.18.0.1, changes, changelog" />
    <meta name="description" content="Log of changes in the package" />
    <link rel="stylesheet" type="text/css" href="../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../css/changelog.css" />
    
    
    <title>
        ODP 1.18.0.1: changelog
    </title>
    
    </head>

<body>
<table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for ODP' href='../../../timeline/ODP/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(ODP)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Changelog for <span class='version'>1.18.0.1</span> version</h1><br/><br/>
<div class='changelog'>
<pre class='wrap'>== OpenDataPlane (1.18.0.1)
=== Summary of Changes
ODP v1.18.0.1 is a fix level for Tiger Moth Release Candidate 2 (RC 2).
It incorporates fixes and performance / serviceability enhancements but no
API changes.

==== APIs
No changes for this release.

==== Corrected Crypto Functionality
This release corrects a merge issue with crypto functionality that resulted in
incorrect crypto operation for certain cipher suites.

==== Runtime Configuration
Introduces a runtime configuration file that can be used by applications to
set selected ODP configuration parameters dynamically at runtime rather than
at `configure` time. At present this is used to configure parameters needed
by DPDK PMDs when using PktIO interfaces in the DPDK class. The intention is
to expand the use of this file over time to allow more dynamic control
of other aspect of ODP runtime configuration.

For the ODP Reference Implementation, a template configuration file is
provided in `config/odp-linux.conf`. Introduction of this support generates
an additional dependency on the `libconfig` package, which must be present to
build ODP.

==== IPsec Traffic Flow Confidentiality (TFC) Corrections
A few missing implementation features associated with TFC packet generation
have been added in this fix level. This support is now functionally complete in
the ODP Reference Implementation.

==== Debug Print Improvements
The information provided in debug builds of the Reference Implementation is
improved to print the interface name on open, start, stop, and close calls.
The driver name and number of queues are also printed to ease verification of
correct configuration.

==== Default Scheduler Performance Improvements
The performance of the default scheduler in the Reference Implementation is
significantly improved in providing scheduled access to PktIO queues. Scheduled
I/O now operates within 10% of the performance achievable using Direct I/O,
while providing incomparably better scalability in multicore environments.

==== `.so` Numbering Changes
In preparation for the Tiger Moth official release, ODP has adopted a
simplified `.so` naming scheme, which is introduced here. ODP `.so` numbers
are now tied to the ODP release number since ODP does not promise backward
compatibility across release boundaries.

== OpenDataPlane (1.18.0.0)
=== New Features
ODP v1.18.0.0 is Tiger Moth Release Candidate 2 (RC 2). It completes the new
APIs that are part of the Tiger Moth Long Term Support (LTS) release of ODP
as well as various performance refinements and bug fixes. As of RC2 the ODP
API is now frozen for the Tiger Moth development series.

==== APIs
The following new and changed APIs are included in this release:

===== Addition of Shared Memory (SHM) Initialization Parameters
The `odp_init_t` struct used as the argument to the `odp_init_global()` API
has been expanded to include a `max_memory` field that specifies the maximum
amount of shared memory (shm) that the application will use. This is to
better enable ODP implementations to optimize their use of shared memory in
support of the application. If left as (or defaulted) to 0, the implementation
may choose a default limit for the application.

===== Crypto Changes
A number of crypto refinements are included in this release:

* The single initialization vector (`iv`) in the `odp_crypto_session_param_t`
is replaced by a separate `cipher_iv` and `auth_iv` fields.

* The single initialization vector (`override_iv_ptr`) in the
`odp_crypto_op_param_t` is replaced by a separate `cipher_iv_ptr` and
`auth_iv_ptr` fields.

* The special nature of GCM and GMAC authenticated encryption modes is
clarified in that these ciphers always combine ciphering with authentication
and hence require both to be specified when used. This is simply a
documentation change as this requirement has always existed.

* Enumerations for AES_CCM (`ODP_CIPHER_ALG_AES_CCM` and
`ODP_AUTH_ALG_AES_CCM`) authenticated encryption modes are added.

* Enumeration for the AES_CMAC authenticated encryption mode
(`ODP_AUTH_ALG_AES_CMAC`) is added.

* Enumerations for the ChaCha20-Poly1305 (`ODP_CIPHER_ALG_CHACHA20_POLY1305`
and `ODP_AUTH_ALG_CHACHA20_POLY1305`) authenticated encryption modes are
added.

* Enumeration for the SHA-384 authentication algorithm
(`ODP_AUTH_ALG_SHA384_HMAC`) is added.

* Enumeration for the AES-XCBC-MAC authentication algorithm
(`ODP_AUTH_ALG_AES_XCBC_MAC`) is added.

===== Lock-free and block-free queues
The `odp_nonblocking_t` enums introduced in ODP v1.17.0.0 are now returned
as separate `odp_queue_capability()` limits for plain and scheduled queues. The
ODP reference implementations now support `ODP_NONBLOCKING_LF` queues.

===== User pointer initialized to NULL
The specification for `odp_packet_user_ptr()` is clarified that unless
overridden by `odp_packet_user_ptr_set()` the value of NULL will be returned.

===== Removal of `ODP_PKTIN_WAIT` option
The `ODP_PKTIN_WAIT` option on `odp_pktin_recv_tmo()` and
`odp_pktin_recv_mq_tmo()` is removed. Timeout options now consist of
`ODP_PKTIN_NO_WAIT` and a user-supplied timeout value. Since this timeout
value can be specified to be arbitrarily long, there is no need for an
indefinite wait capability as provision of such a capability proved
problematic for some ODP implementations.

===== Addition of packet protocol APIs
The APIs `odp_packet_l2_type()`, `odp_packet_l3_type()`, and
`odp_packet_l4_type()` are added to return the Layer 2, 3, and 4 protocols,
respectively, associated with packets that have been parsed to the
corresponding layer. If the packet was not parsed to the associated layer
these return `ODP_PROTO_Ln_TYPE_NONE`.

===== Packet addressability improvements
The documentation of `odp_packet_data()` is clarified to indicated when this
shortcut may be used safely and a new API, `odp_packet_data_seg_len()`, is
added that returns both the address of the start of packet data as well
as the number of bytes addressable from that pointer.

===== Asynchronous ordered locks
Two new APIs, `odp_schedule_order_lock_start()` and
`odp_schedule_order_lock_wait()` are added to allow for asynchronous
ordered lock acquisition in addition to the existing synchronous
`odp_schedule_order_lock()` API. In some implementations and applications,
there may be a performance advantage to indicating the intent to acquire an
ordered lock to allow the implementation to prepare for this while the
application continues parallel processing and then enter the critical section
protected by the ordered lock at a later time. In this case ordered lock
protection is not guaranteed until the `odp_schedule_order_lock_wait()` call
returns.

===== IPsec API miscellaneous changes and enhancements
IPsec support is further enhanced with the following:

* The `odp_ipsec_ipv4_param_t` and `odp_ipsec_ipv6_param_t` structures
are added to formalize the specification of IPv4 and IPv6 options in the
`odp_ipsec_tunnel_param_t` configuration.

* The `mode` field of the `odp_ipsec_out_t` is renamed to `frag_mode` for
better clarity. In addition the `flag.frag-mode` option bit in the
`odp_ipsec_out_opt_t` struct is defined to hold per-operation options for
the `odp_ipsec_out_param_t` struct.

* The `odp_ipsec_capability_t` struct returned by the `odp_ipsec_capability()`
API is expanded to include the `odp_proto_chksums_t` available on inbound
IPsec traffic. This indicates whether and how inbound packet checksums may
be validated for decrypted IPsec traffic.

===== IPsec Traffic Flow Confidentiality (TFC) support
Traffic Flow Confidentiality (TFC) allows applications to defend against
traffic analysis attacks by inserting dummy packets as well as add pad bytes
to packets traversing IPsec flows.

Dummy packets have an L3 type of `ODP_PROTO_L3_TYPE_NONE` in tunnel mode and
`ODP_PROTO_L4_TYPE_NO_NEXT` in transport mode. Padded packets have additional
data suffixed to them that extends beyond the L3 or L4 packet lengths.

For RX processing, inline dummy packets may or may not be dropped from the
inbound packet stream. For lookaside processing they are always visible. For TX
processing, the `odp_ipsec_out_opt_t` struct specifies the `tfc_pad` bit if
the packet is to be padded or the `tfc_dummy` bit if a dummy packet is to
be inserted. The dummy packet length is specified by the `tfc_pad_len` option.

=== Streamlined ABI Support
ABI support has been reorganized to make it more modular and to omit headers
and related ABI files when configure to disable this support.

=== Reference Implementation Fixes and Improvements
The ODP Reference Implementation corporates a number of improvements that
result in better code organization as well as improved processing efficiency.

==== Pktio null device support
In the LNG Reference Implemenations of ODP, the `odp_pktio_open()` API may now
specify devices of class `null` to indicate the PktIO is treated as a dummy
device. Null devices behave just like Linux `/dev/null` in that they never
receive packets and simply discard any packets sent to them.

Note that not all ODP implementations may support this device class. The
specific device classes supported by each ODP implementation may vary and are
listed in their own documentation.

==== Runtime Scheduler Selection
The ODP Reference Implementation offers both a default and a number of
alternate scheduler implementations. Previously these were selectable only at
`configure` time. They can now be dynamically selected at runtime by the use
of the `ODP_SCHEDULER` environment variable. If this environment variable is
not set, the default (basic) scheduler is used. It can be set to select
alternate schedulers:

* `ODP_SCHEDULER=basic` Explicitly selects the default scheduler
* `ODP_SCHEDULER=sp` Selects the strict priority scheduler
* `ODP_SCHEDULER=iquery` Selects the iQuery scheduler
* `ODP_SCHEDULER=scalable` Selects the scalable scheduler

==== Streamlined Queue Implementation
The ODP Reference Implementation now uses a ring model for implementing
ODP queues. This results in greatly improved efficiency for queue operations.
The default maximum queue depth used is 4096 elements, and this information is
returned via the `odp_queue_capability()` API.

==== Validation Test Simplification
The tests that are part of the validation test suite are reorganized and
simplified by having a single test file for each API rather than separate
CUnit driver files and test files.

=== Test/Example Improvements

==== Crypto Test Improvements
The `crypto` validation test suite now offers better information on which
crypto algorithms were skipped because they are not available. Testing of
full HMAC lengths is now added

==== ODP Generator Improvements
The `odp_generator` example now offers configurable RX burst size, selectable
packet handling (Direct I/O or Scheduled I/O), as well as streamlined packet
processing.

==== `l2fwd` Example Improvements
The `l2fwd` example offers improved efficiency via better cache usage.

=== Bug Fixes

==== https://bugs.linaro.org/show_bug.cgi?id=3517[Bug 3517]
timer test might fail

==== https://bugs.linaro.org/show_bug.cgi?id=3572[Bug 3572]
time_main test fails if run under heavy load

==== https://bugs.linaro.org/show_bug.cgi?id=3576[Bug 3576]
classification: CoS queues in invalid table index

==== https://bugs.linaro.org/show_bug.cgi?id=3577[Bug 3577]
classification: multiqueue CoS will always fail

==== https://bugs.linaro.org/show_bug.cgi?id=3578[Bug 3578]
classification: requested number of queues is ignored in multiqueue CoS

==== https://bugs.linaro.org/show_bug.cgi?id=3579[Bug 3579]
cls: capability to return max hash queues

==== https://bugs.linaro.org/show_bug.cgi?id=3581[Bug 3581]
classification: invalid memory access in RSS hash

==== https://bugs.linaro.org/show_bug.cgi?id=3582[Bug 3582]
classification: incorrect IPv6 RSS hash

==== https://bugs.linaro.org/show_bug.cgi?id=3594[Bug 3594]
IPsec SA may be used before fully initialized

==== https://bugs.linaro.org/show_bug.cgi?id=3595[Bug 3595]
IPsec SA lookup may leave extra SAs locked

==== https://bugs.linaro.org/show_bug.cgi?id=3597[Bug 3597]
new generator test assumes that null:0 pktio is always present

==== https://bugs.linaro.org/show_bug.cgi?id=3613[Bug 3613]
packet_main test can fail

==== https://bugs.linaro.org/show_bug.cgi?id=3618[Bug 3618]
DPDK pktio stops receiving packets if all configured RX queues are not used

==== https://bugs.linaro.org/show_bug.cgi?id=3628[Bug 3628]
Another timer_main failure

==== https://bugs.linaro.org/show_bug.cgi?id=3632[Bug 3632]
Creating a pool with total size over 4.29GB (UINT32_MAX) leads to
undefined behavior

=== Known Issues

==== https://bugs.linaro.org/show_bug.cgi?id=2988[Bug 2988]
ODP exposes symbols outside of odp*/_odp* namespace

==== https://bugs.linaro.org/show_bug.cgi?id=3611[Bug 3611]
ODP linux-generic fails on AArch64 in non-ABI-compat mode

== OpenDataPlane (1.17.0.0)
=== New Features
ODP v1.17.0.0 is Tiger Moth Release Candidate 1 (RC 1). It introduces
significant new API support as well as functional refinements that expand
ODP offload support to cover IPsec, as well as other improvements.

==== APIs
The following new and changed APIs are included in this release:

===== Event Extensions
The ODP event model has been expanded to include new types as well as event
subtypes. Subtypes are used to qualify an event by indicating that the event
carries additional metadata relating to specific usage or operations.

New event `ODP_EVENT_IPSEC_STATUS` (to be discussed
below) is added. The initial subtypes defined are: `ODP_EVENT_PACKET_BASIC`,
`ODP_EVENT_PACKET_CRYPTO`, `ODP_EVENT_PACKET_IPSEC`, and
`ODP_EVENT_NO_SUBTYPE`, which are also discussed below.

Associated with this support, new event APIs are added:

* `odp_event_subtype()` extracts the `odp_event_subtype_t` from an
`odp_event_t`.

* `odp_event_types()` returns the `odp_event_type_t` and `odp_event_subtype_t`
of an `odp_event_t` in a single call.

* `odp_event_type_multi()` scans a list of `odp_event_t` objects and returns
the number that share the same indicated `odp_event_type_t`. This allows
multiple events to be processed by groups of the same event type.

* `odp_event_filter_packet()` scans a list of `odp_event_t` objects and
partitions them into a returned array of `odp_packet_t` objects and a remaining
array of non-packet events.

* `odp_event_free_multi()` frees multiple events in a single call.

* `odp_event_free_sp()` frees multiple events originating from the same
pool in a single call. The caller must assure that the input events are from
the same pool.

===== IPsec support
ODP Tiger Moth introduces comprehensive protocol offload support for IPsec,
allowing applications to leverage the IPsec acceleration capabilities of many
SoCs. Support includes APIs for Security Association (SA) creation and
lifecycle management, as well as IPsec packet operations for inbound (RX) and
outbound (TX) processing. Packet operations are further divided into lookaside
and inline support.

====== Lookaside Support
Lookaside processing enables IPsec packets to be decrypted into plain packets
or plain packets to be encrypted into IPsec packets in a single operation under
explicit application control. This is useful for packets that need pre- or
post-processing, or to better fit with existing application design.

Two forms of lookaside processing are provided: the `odp_ipsec_in()` and
`odp_ipsec_out()` APIs provide synchronous decrypt and encrypt support,
respectively. The corresponding `odp_ipsec_in_enq()` and `odp_ipsec_out_enq()`
APIs provide these same services in asynchronous form where operations can be
launched and completed later.

====== Inline Support
In contrast to lookaside support, IPsec inline support permits applications to
fully leverage the offload capabilities found in many SoCs by allowing inbound
IPsec packets to be recognized and decrypted automatically before they are
presented to the application for processing. This is done by configuring a
Security Association (SA) and its associated PktIO to operate in inline mode.

Similarly, following output SA and PktIO configuration, the
`odp_ipsec_out_inline()` API permits a packet to be encrypted into an IPsec
packet and automatically scheduled for TX processing in a single
operation. Such "fire and forget" processing enables applications to leverage
IPsec HW support for such processing in a portable manner.

Applications using IPsec inline support need only "touch" a packet once
compared to three times when using lookaside processing, leading to greater
processing efficiency.

====== IPsec Events
New event types and subtypes are introduced to provide support for IPsec
processing. The `ODP_EVENT_PACKET` type has a new subtype:
`ODP_EVENT_PACKET_IPSEC` that provides extended metadata associated with
IPsec packets that have been processed. The new `ODP_EVENT_IPSEC_STATUS`
event, in turn, is used to report IPsec status events such as completion
notifications associated with `odp_ipsec_sa_disable()` calls.

The `odp_ipsec_result()` API is used to obtain IPsec result metadata from
a packet that has event subtype `ODP_EVENT_PACKET_IPSEC`, while the
`odp_ipsec_status()` API is used to obtain IPsec status metadata from an
`ODP_EVENT_IPSEC_STATUS` event.

===== Parser APIs
Packet parsing has been overhauled with the introduction of two new APIs:

* `odp_packet_parse()`
* `odp_packet_parse_multi()`

These use an `odp_packet_parse_param_t` struct to control the type and depth
of parsing to be performed. These routines are intended to be used to
process packets that have been decapsulated following IPsec decryption or other
tunneling or on IP fragments after they have been reassembled.

Associated with this improved parse support, the `odp_parser_layer_t` struct
is deprecated and replaced with a more general `odp_proto_layer_t` struct that
is used both in PktIO configuration as well as the new parser APIs.

===== Crypto AES-CTR and AES-GMAC Support
The ODP crypto APIs are extended to provide support for AES-CTR cipher and
AES-GMAC authentication modes, reflecting the growing availability of
accelerated support for these.

===== Crypto removal of DES-CBC
DES-CBC is no longer considered secure and support for it is removed in ODP.

===== Crypto move AAD length to sessions
The Additional Authentication Data (AAD) length is now part of the
`odp_crypto_session_t` rather than individual crypto operations. This provides
better compatibility with DPDK, which made a similar API adjustment in it's
17.08 release.

===== Crypto Packet APIs
While the `odp_crypto_operation()` API is retained for compatibility,
new packet-oriented variants are introduced that provide additional
capabilities and flexibility. These APIs are:

* `odp_crypto_op()` Performs synchronous crypto operations on one or more
input packets under the control of an associated `odp_crypto_packet_op_param_t`
struct.

* `odp_crypto_op_enq()` Performs asynchronous crypto operations on or or more
input packets under the control of an associated `odp_crypto_packet_op_param_t`
struct.

While `odp_crypto_operation()` calls result in `ODP_EVENT_CRYPTO_COMPL` events
for compatibility, the new packet-oriented APIs result in `ODP_EVENT_PACKET`
events that carry the new event subtype `ODP_EVENT_PACKET_CRYPTO`. These
packets contain additional metadata associated with the crypto operation.
New APIs added for manipulating this metadata include:

* `odp_crypto_packet_from_event()` converts an `odp_event_t` of type
`ODP_EVENT_PACKET` and subtype `ODP_EVENT_PACKET_CRYPTO` to an `odp_packet_t`.

* `odp_crypto_packet_to_event()` converts an `odp_packet_t` crypto packet
back into an `odp_event_t`.

* `odp_crypto_result()` extracts the `odp_crypto_packet_result_t` struct that
contains the crypto metadata associated with an `odp_packet_t` of event
subtype `ODP_EVENT_PACKET_CRYPTO`. This struct provides a summary bit that
says whether the operation completed successfully as well as
`odp_crypto_op_status_t` fields for the `cipher_status` and `auth_status` if a
problem was detected.

===== Classification Random Early Detection (RED) Support
Random Early Detection (RED) provides a means for input HW to ensure that
traffic is treated fairly under conditions of temporary resource overload due
to excessive inbound traffic. ODP RED support provides the ability to measure
and respond to resource pressure on either pools or queues, and only provides
flexibility in how such conditions are to be processed. They can result in
input packet drops or backpressure being indicated by transmitting pause
frames, depending on the underlying platform capabilities.

The `odp_cls_capability_t` struct returned by the `odp_cls_capability()` API
has been expanded to cover this support.

===== Time difference in nanoseconds
The new `odp_time_diff_ns()` API permits the delta between two `odp_time_t`
values to be computed in a single call.

===== PktIO API Changes
====== PktIO Maximum Frame Lengths
The `odp_pktio_mtu()` API is deprecated and replaced by two new APIs:
`odp_pktin_maxlen()` and `odp_pktout_maxlen()`. These return the maximum
sized packets that are supported for RX and TX processing,
respectively, on a given `odp_pktio_t`.

====== PktIO settable MAC address
The `odp_pktio_mac_addr_set()` API is added to allow setting of the MAC
address associated with an `odp_pktio_t`. The `odp_pktio_set_op_t` field of
the `odp_pktio_capability_t` returned by the `odp_pktio_capability()` API now
includes the `mac_addr`` field to indicate that this `odp_ptkio_t` supports
setting its MAC address.

====== Multiple loop devices
The reserved device name `loop` is now extended to `loopX` where X == integer
(_e.g.,_ `loop1`, `loop2`, etc.). For compatibility, `loop` is a synonym for
`loop0`.

===== Pool API Changes
====== Pool extent info
The `odp_pool_info()` API is extended to return the `min_data_addr` and
`max_data_addr` fields. These provide information about the minimum and maximum
application-visible addresses that may be seen in objects allocated from a
particular `odp_pool_t`. Some applications use this information to enable them
to store buffer addresses in compressed format. For example, if the
"span" of valid addresses is less than 4GB this allows a 64-bit buffer address
to be stored as a 32-bit offset.

Since this is purely informational, ODP implementations are under no constraint
as to what addresses may be returned for these fields. 0 and `UNINTPTR_MAX`
may be used if there are no limits on pool extents.

====== Pool subparameter support
The `odp_pool_param_t` structure has been expanded to provide more flexibility
to support platforms that are able to offer multiple segment sizes within a
single pool. This can lead to greater storage efficiency. These are called
subparameters and implementations supporting up to 7 of these are accommodated
with these extensions.

The `odp_pool_capability_t` structure is expanded to return the number of
subparameters supported by this implementation. The application, in turn,
specifies its expected packet size and number distribution in the
`odp_pool_pkt_subparam_t` structure that is part of the `odp_pool_param_t`
used to define the characteristics of `ODP_POOL_PACKET` pools.

This is fully compatible with previous packet pool support since ODP
implementations are under no obligation to support pool subparameters and
these, when present, are advisory in nature. They simply serve to allow the
application to better communicate its expected packet distribution within a
pool so that the ODP implementation may better optimize storage use in the
pool.

===== Checksum support
Checksum processing support has been formalized with the addition of APIs for
determining packet checksum status, controlling packet checksum processing,
retrieving partially computed checksums on packets, and computing checksum
partial sums for memory areas.

====== Checksum status
The APIs `odp_packet_l3_chksum_status()` and `odp_packet_l4_status()` are
added to allow the results of packet input checksum processing to be
queried. These APIs return an `odp_packet_chksum_status_t` enum that indicates
whether checksum validation processing was performed and if so whether the
layer 3 or 4 checksum was found to be valid. This is applicable to both
normal packet input as well as those processed via IPsec.

====== Checksum insertion
PktIOs output checksum processing is configured as part of the
`odp_pktout_config_opt_t` struct used as input to `odp_pktio_config()` API.
These control whether L3 and/or L4 checksums are to be inserted by default
as part of packet TX processing.

Individual packets may override these defaults via the new
`odp_packet_l3_chksum_insert()` and `odp_packet_l4_chksum_insert()` APIs. These
take precedence over the PktIO default, allowing checksums to be inserted
when the PktIO default is to not insert checksums or to suppress checksum
insertion if when the PktIO default is to insert checksums.

====== One's comp
...</pre></div>

</body>
</html>
