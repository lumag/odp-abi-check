<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="ODP, header, diff" />
    <meta name="description" content="Diff for header files between 1.16.0.0 and 1.17.0.0 versions of ODP" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css" />
    
    
    <title>
        ODP: headers diff between 1.16.0.0 and 1.17.0.0 versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for ODP' href='../../../../timeline/ODP/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(ODP)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>1.16.0.0</span> vs <span class='version'>1.17.0.0</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;event_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;event_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 41</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 41</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef ODP_HANDLE_T(odp_event_t);</td><td> </td><td class="right">typedef ODP_HANDLE_T(odp_event_t);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_EVENT_INVALID _odp_cast_scalar(odp_event_t, NULL)</td><td> </td><td class="right">#define ODP_EVENT_INVALID _odp_cast_scalar(odp_event_t, NULL)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef enum odp_event_type_t {</td><td> </td><td class="right">typedef enum odp_event_type_t {</td></tr>
      <tr><td class="left">       ODP_EVENT_BUFFER       = 1,</td><td> </td><td class="right">       ODP_EVENT_BUFFER       = 1,</td></tr>
      <tr><td class="left">       ODP_EVENT_PACKET       = 2,</td><td> </td><td class="right">       ODP_EVENT_PACKET       = 2,</td></tr>
      <tr><td class="left">       ODP_EVENT_TIMEOUT      = 3,</td><td> </td><td class="right">       ODP_EVENT_TIMEOUT      = 3,</td></tr>
      <tr><td class="left">       ODP_EVENT_CRYPTO_COMPL = 4,</td><td> </td><td class="right">       ODP_EVENT_CRYPTO_COMPL = 4,</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_IPSEC_STATUS = 5</span></td></tr>
      <tr><td class="left">} odp_event_type_t;</td><td> </td><td class="right">} odp_event_type_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum odp_event_subtype_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_NO_SUBTYPE   = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_PACKET_BASIC = 1,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_PACKET_CRYPTO = 2,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_PACKET_IPSEC = 3</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_event_subtype_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>8 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_inlines.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_inlines.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 18</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 18</em></th></tr>
      <tr><td class="left"> * @file</td><td> </td><td class="right"> * @file</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet inline functions</td><td> </td><td class="right"> * Packet inline functions</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef _ODP_PLAT_PACKET_INLINES_H_</td><td> </td><td class="right">#ifndef _ODP_PLAT_PACKET_INLINES_H_</td></tr>
      <tr><td class="left">#define _ODP_PLAT_PACKET_INLINES_H_</td><td> </td><td class="right">#define _ODP_PLAT_PACKET_INLINES_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/plat/packet_types.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/plat/packet_types.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/pool.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/pool.h&gt;</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">#include <span class="delete">&lt;odp/api/packet_io.h&gt;</span></td><td> </td><td class="rblock">#include <span class="insert">&lt;odp/api/time.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/plat/packet_io_types.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/plat/buffer_types.h&gt;</span></td></tr>
      <tr><td class="left">#include &lt;odp/api/hints.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/hints.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt_ptr @param offset @param seg_len</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *  @param seg_idx @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void *_odp_packet_map(void *pkt_ptr, uint32_t offset, uint32_t *seg_len,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                     int *seg_idx);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** @internal Inline function offsets */</td><td> </td><td class="right">/** @internal Inline function offsets */</td></tr>
      <tr><td class="left">extern const _odp_packet_inline_offset_t _odp_packet_inline;</td><td> </td><td class="right">extern const _odp_packet_inline_offset_t _odp_packet_inline;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Pool inline function offsets */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">extern const _odp_pool_inline_offset_t _odp_pool_inline;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#if ODP_ABI_COMPAT == 1</td><td> </td><td class="right">#if ODP_ABI_COMPAT == 1</td></tr>
      <tr><td class="left">/** @internal Inline function @param seg @return */</td><td> </td><td class="right">/** @internal Inline function @param seg @return */</td></tr>
      <tr><td class="left">static inline uint32_t _odp_packet_seg_to_ndx(odp_packet_seg_t seg)</td><td> </td><td class="right">static inline uint32_t _odp_packet_seg_to_ndx(odp_packet_seg_t seg)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_typeval(seg);</td><td> </td><td class="right">       return _odp_typeval(seg);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param ndx @return */</td><td> </td><td class="right">/** @internal Inline function @param ndx @return */</td></tr>
      <tr><td class="left">static inline odp_packet_seg_t _odp_packet_seg_from_ndx(uint32_t ndx)</td><td> </td><td class="right">static inline odp_packet_seg_t _odp_packet_seg_from_ndx(uint32_t ndx)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 71</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 81</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline uint32_t _odp_packet_tailroom(odp_packet_t pkt)</td><td> </td><td class="right">static inline uint32_t _odp_packet_tailroom(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_pkt_get(pkt, uint16_t, tailroom);</td><td> </td><td class="right">       return _odp_pkt_get(pkt, uint16_t, tailroom);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline odp_pool_t _odp_packet_pool(odp_packet_t pkt)</td><td> </td><td class="right">static inline odp_pool_t _odp_packet_pool(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">       <span class="delete">return</span> _odp_pkt_get(pkt, <span class="delete">odp_pool_t,</span> pool);</td><td> </td><td class="rblock">       <span class="insert">void *pool =</span> _odp_pkt_get(pkt, <span class="insert">void *,</span> pool);</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">return _odp_pool_get(pool, odp_pool_t, pool_hdl);</span></td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline odp_pktio_t _odp_packet_input(odp_packet_t pkt)</td><td> </td><td class="right">static inline odp_pktio_t _odp_packet_input(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_pkt_get(pkt, odp_pktio_t, input);</td><td> </td><td class="right">       return _odp_pkt_get(pkt, odp_pktio_t, input);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline int _odp_packet_num_segs(odp_packet_t pkt)</td><td> </td><td class="right">static inline int _odp_packet_num_segs(odp_packet_t pkt)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 101</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 113</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline void *_odp_packet_user_area(odp_packet_t pkt)</td><td> </td><td class="right">static inline void *_odp_packet_user_area(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_pkt_get(pkt, void *, user_area);</td><td> </td><td class="right">       return _odp_pkt_get(pkt, void *, user_area);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline uint32_t _odp_packet_user_area_size(odp_packet_t pkt)</td><td> </td><td class="right">static inline uint32_t _odp_packet_user_area_size(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">       <span class="delete">return</span> _odp_pkt_get(pkt, uint32_t, <span class="delete">user_area_size);</span></td><td> </td><td class="rblock">       <span class="insert">void *pool =</span> _odp_pkt_get(pkt, <span class="insert">void *, pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_pool_get(pool,</span> uint32_t, <span class="insert">uarea_size);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline uint32_t _odp_packet_l2_offset(odp_packet_t pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_pkt_get(pkt, uint16_t, l2_offset);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline uint32_t _odp_packet_l3_offset(odp_packet_t pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_pkt_get(pkt, uint16_t, l3_offset);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline uint32_t _odp_packet_l4_offset(odp_packet_t pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_pkt_get(pkt, uint16_t, l4_offset);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt @param len @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline void *_odp_packet_l2_ptr(odp_packet_t pkt, uint32_t *len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t offset  = _odp_packet_l2_offset(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t seg_len = _odp_packet_seg_len(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t *data    = (uint8_t *)_odp_packet_data(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (odp_unlikely(offset &gt;= seg_len)) {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               void *pkt_hdr = (void *)pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return _odp_packet_map(pkt_hdr, offset, len, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *len = seg_len - offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return data + offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt @param len @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline void *_odp_packet_l3_ptr(odp_packet_t pkt, uint32_t *len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t offset  = _odp_packet_l3_offset(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t seg_len = _odp_packet_seg_len(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t *data    = (uint8_t *)_odp_packet_data(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (odp_unlikely(offset &gt;= seg_len)) {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               void *pkt_hdr = (void *)pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return _odp_packet_map(pkt_hdr, offset, len, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *len = seg_len - offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return data + offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Inline function @param pkt @param len @return */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline void *_odp_packet_l4_ptr(odp_packet_t pkt, uint32_t *len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t offset  = _odp_packet_l4_offset(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t seg_len = _odp_packet_seg_len(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t *data    = (uint8_t *)_odp_packet_data(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (odp_unlikely(offset &gt;= seg_len)) {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               void *pkt_hdr = (void *)pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return _odp_packet_map(pkt_hdr, offset, len, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       }</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               *len = seg_len - offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return data + offset;</span></td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline uint32_t _odp_packet_flow_hash(odp_packet_t pkt)</td><td> </td><td class="right">static inline uint32_t _odp_packet_flow_hash(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_pkt_get(pkt, uint32_t, flow_hash);</td><td> </td><td class="right">       return _odp_pkt_get(pkt, uint32_t, flow_hash);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Inline function @param pkt @return */</td><td> </td><td class="right">/** @internal Inline function @param pkt @return */</td></tr>
      <tr><td class="left">static inline odp_time_t _odp_packet_ts(odp_packet_t pkt)</td><td> </td><td class="right">static inline odp_time_t _odp_packet_ts(odp_packet_t pkt)</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 5 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>3 lines changed or deleted</i></th><th><i> </i></th><th><i>92 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_inlines_api.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_inlines_api.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 71</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 71</em></th></tr>
      <tr><td class="left">_ODP_INLINE void *odp_packet_user_area(odp_packet_t pkt)</td><td> </td><td class="right">_ODP_INLINE void *odp_packet_user_area(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_packet_user_area(pkt);</td><td> </td><td class="right">       return _odp_packet_user_area(pkt);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">_ODP_INLINE uint32_t odp_packet_user_area_size(odp_packet_t pkt)</td><td> </td><td class="right">_ODP_INLINE uint32_t odp_packet_user_area_size(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_packet_user_area_size(pkt);</td><td> </td><td class="right">       return _odp_packet_user_area_size(pkt);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_ODP_INLINE uint32_t odp_packet_l2_offset(odp_packet_t pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_packet_l2_offset(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_ODP_INLINE uint32_t odp_packet_l3_offset(odp_packet_t pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_packet_l3_offset(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_ODP_INLINE uint32_t odp_packet_l4_offset(odp_packet_t pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_packet_l4_offset(pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_ODP_INLINE void *odp_packet_l2_ptr(odp_packet_t pkt, uint32_t *len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_packet_l2_ptr(pkt, len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_ODP_INLINE void *odp_packet_l3_ptr(odp_packet_t pkt, uint32_t *len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_packet_l3_ptr(pkt, len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">_ODP_INLINE void *odp_packet_l4_ptr(odp_packet_t pkt, uint32_t *len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return _odp_packet_l4_ptr(pkt, len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">_ODP_INLINE uint32_t odp_packet_flow_hash(odp_packet_t pkt)</td><td> </td><td class="right">_ODP_INLINE uint32_t odp_packet_flow_hash(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_packet_flow_hash(pkt);</td><td> </td><td class="right">       return _odp_packet_flow_hash(pkt);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">_ODP_INLINE odp_time_t odp_packet_ts(odp_packet_t pkt)</td><td> </td><td class="right">_ODP_INLINE odp_time_t odp_packet_ts(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_packet_ts(pkt);</td><td> </td><td class="right">       return _odp_packet_ts(pkt);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>30 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 96</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 96</em></th></tr>
      <tr><td class="left">       uint16_t pool;</td><td> </td><td class="right">       uint16_t pool;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t input;</td><td> </td><td class="right">       uint16_t input;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t segcount;</td><td> </td><td class="right">       uint16_t segcount;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t user_ptr;</td><td> </td><td class="right">       uint16_t user_ptr;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t user_area;</td><td> </td><td class="right">       uint16_t user_area;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">       uint16_t <span class="delete">user_area_size;</span></td><td> </td><td class="rblock">       uint16_t <span class="insert">l2_offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** @internal field offset */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint16_t l3_offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** @internal field offset */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint16_t l4_offset;</span></td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t flow_hash;</td><td> </td><td class="right">       uint16_t flow_hash;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t timestamp;</td><td> </td><td class="right">       uint16_t timestamp;</td></tr>
      <tr><td class="left">       /** @internal field offset */</td><td> </td><td class="right">       /** @internal field offset */</td></tr>
      <tr><td class="left">       uint16_t input_flags;</td><td> </td><td class="right">       uint16_t input_flags;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} _odp_packet_inline_offset_t;</td><td> </td><td class="right">} _odp_packet_inline_offset_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Packet input &amp; protocol flags */</td><td> </td><td class="right">/** @internal Packet input &amp; protocol flags */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 152</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 156</em></th></tr>
      <tr><td class="left">               uint64_t ipsec_esp:1; /**&lt; IPSec encapsulating security</td><td> </td><td class="right">               uint64_t ipsec_esp:1; /**&lt; IPSec encapsulating security</td></tr>
      <tr><td class="left">                                          payload */</td><td> </td><td class="right">                                          payload */</td></tr>
      <tr><td class="left">               uint64_t udp:1;       /**&lt; UDP */</td><td> </td><td class="right">               uint64_t udp:1;       /**&lt; UDP */</td></tr>
      <tr><td class="left">               uint64_t tcp:1;       /**&lt; TCP */</td><td> </td><td class="right">               uint64_t tcp:1;       /**&lt; TCP */</td></tr>
      <tr><td class="left">               uint64_t tcpopt:1;    /**&lt; TCP options present */</td><td> </td><td class="right">               uint64_t tcpopt:1;    /**&lt; TCP options present */</td></tr>
      <tr><td class="left">               uint64_t sctp:1;      /**&lt; SCTP */</td><td> </td><td class="right">               uint64_t sctp:1;      /**&lt; SCTP */</td></tr>
      <tr><td class="left">               uint64_t icmp:1;      /**&lt; ICMP */</td><td> </td><td class="right">               uint64_t icmp:1;      /**&lt; ICMP */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               uint64_t color:2;     /**&lt; Packet color for traffic mgmt */</td><td> </td><td class="right">               uint64_t color:2;     /**&lt; Packet color for traffic mgmt */</td></tr>
      <tr><td class="left">               uint64_t nodrop:1;    /**&lt; Drop eligibility status */</td><td> </td><td class="right">               uint64_t nodrop:1;    /**&lt; Drop eligibility status */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">uint64_t l3_chksum_done:1; /**&lt; L3 checksum validation done </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t l4_chksum_done:1; /**&lt; L4 checksum validation done </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t ipsec_udp:1; /**&lt; UDP-encapsulated IPsec packet */</span></td></tr>
      <tr><td class="left">       };</td><td> </td><td class="right">       };</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} _odp_packet_input_flags_t;</td><td> </td><td class="right">} _odp_packet_input_flags_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>11 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;pool_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;pool_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 51</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 51</em></th></tr>
      <tr><td class="left">       ODP_POOL_PACKET  = ODP_EVENT_PACKET,</td><td> </td><td class="right">       ODP_POOL_PACKET  = ODP_EVENT_PACKET,</td></tr>
      <tr><td class="left">       ODP_POOL_TIMEOUT = ODP_EVENT_TIMEOUT,</td><td> </td><td class="right">       ODP_POOL_TIMEOUT = ODP_EVENT_TIMEOUT,</td></tr>
      <tr><td class="left">} odp_pool_type_t;</td><td> </td><td class="right">} odp_pool_type_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Pool field accessor */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define _odp_pool_get(pool, cast, field) \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       (*(cast *)(uintptr_t)((uint8_t *)pool + _odp_pool_inline.field))</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Pool header field offsets for inline functions */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct _odp_pool_inline_offset_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** @internal field offset */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint16_t pool_hdl;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** @internal field offset */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint16_t uarea_size;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} _odp_pool_inline_offset_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>13 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;schedule_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;schedule_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 20</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 20</em></th></tr>
      <tr><td class="left"> * ODP schedule</td><td> </td><td class="right"> * ODP schedule</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_SCHEDULE_TYPES_H_</td><td> </td><td class="right">#ifndef ODP_SCHEDULE_TYPES_H_</td></tr>
      <tr><td class="left">#define ODP_SCHEDULE_TYPES_H_</td><td> </td><td class="right">#define ODP_SCHEDULE_TYPES_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/std_types.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** @addtogroup odp_scheduler</td><td> </td><td class="right">/** @addtogroup odp_scheduler</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_WAIT     UINT64_MAX</td><td> </td><td class="right">#define ODP_SCHED_WAIT     UINT64_MAX</td></tr>
      <tr><td class="left">#define ODP_SCHED_NO_WAIT  0</td><td> </td><td class="right">#define ODP_SCHED_NO_WAIT  0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef int odp_schedule_prio_t;</td><td> </td><td class="right">typedef int odp_schedule_prio_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_PRIO_HIGHEST  0</td><td> </td><td class="right">#define ODP_SCHED_PRIO_HIGHEST  0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 46</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 48</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef int odp_schedule_sync_t;</td><td> </td><td class="right">typedef int odp_schedule_sync_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_SYNC_PARALLEL 0</td><td> </td><td class="right">#define ODP_SCHED_SYNC_PARALLEL 0</td></tr>
      <tr><td class="left">#define ODP_SCHED_SYNC_ATOMIC   1</td><td> </td><td class="right">#define ODP_SCHED_SYNC_ATOMIC   1</td></tr>
      <tr><td class="left">#define ODP_SCHED_SYNC_ORDERED  2</td><td> </td><td class="right">#define ODP_SCHED_SYNC_ORDERED  2</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef int odp_schedule_group_t;</td><td> </td><td class="right">typedef int odp_schedule_group_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* These must be kept in sync with thread_globals_t in odp_thread.c */</td><td> </td><td class="right">/* These must be kept in sync with thread_globals_t in odp_thread.c */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">#define ODP_SCHED_GROUP_INVALID <span class="delete">-1</span></td><td> </td><td class="rblock">#define ODP_SCHED_GROUP_INVALID <span class="insert">((odp_schedule_group_t)-1)</span></td></tr>
      <tr><td class="left">#define ODP_SCHED_GROUP_ALL     0</td><td> </td><td class="right">#define ODP_SCHED_GROUP_ALL     0</td></tr>
      <tr><td class="left">#define ODP_SCHED_GROUP_WORKER  1</td><td> </td><td class="right">#define ODP_SCHED_GROUP_WORKER  1</td></tr>
      <tr><td class="left">#define ODP_SCHED_GROUP_CONTROL 2</td><td> </td><td class="right">#define ODP_SCHED_GROUP_CONTROL 2</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_GROUP_NAME_LEN 32</td><td> </td><td class="right">#define ODP_SCHED_GROUP_NAME_LEN 32</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>3 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;strong_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;strong_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 19</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 19</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ODP Strong Types. Common macros for implementing strong typing</td><td> </td><td class="right"> * ODP Strong Types. Common macros for implementing strong typing</td></tr>
      <tr><td class="left"> * for ODP abstract data types</td><td> </td><td class="right"> * for ODP abstract data types</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef STRONG_TYPES_H_</td><td> </td><td class="right">#ifndef STRONG_TYPES_H_</td></tr>
      <tr><td class="left">#define STRONG_TYPES_H_</td><td> </td><td class="right">#define STRONG_TYPES_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Use strong typing for ODP types */</td><td> </td><td class="right">/** Use strong typing for ODP types */</td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">#define <span class="delete">ODP_HANDLE_T(type)</span> struct _##type { uint8_t unused_dummy_var; } <span class="delete">*ty</span></td><td> </td><td class="rblock"><span class="insert">/* Allow type to be expanded before concatenation with underscore */</span></td></tr>
      <tr><td class="lblock"><span class="delete">pe</span></td><td> </td><td class="rblock">#define <span class="insert">_ODP_HANDLE_T(type)</span> struct _##type { uint8_t unused_dummy_var; } <span class="insert">*t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ype</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_HANDLE_T(type) _ODP_HANDLE_T(type)</span></td></tr>
      <tr><td class="left">#else</td><td> </td><td class="right">#else</td></tr>
      <tr><td class="left">#define odp_handle_t struct { uint8_t unused_dummy_var; } *</td><td> </td><td class="right">#define odp_handle_t struct { uint8_t unused_dummy_var; } *</td></tr>
      <tr><td class="left">/** C/C++ helper macro for strong typing */</td><td> </td><td class="right">/** C/C++ helper macro for strong typing */</td></tr>
      <tr><td class="left">#define ODP_HANDLE_T(type) odp_handle_t type</td><td> </td><td class="right">#define ODP_HANDLE_T(type) odp_handle_t type</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Internal macro to get value of an ODP handle */</td><td> </td><td class="right">/** Internal macro to get value of an ODP handle */</td></tr>
      <tr><td class="left">#define _odp_typeval(handle) ((uint32_t)(uintptr_t)(handle))</td><td> </td><td class="right">#define _odp_typeval(handle) ((uint32_t)(uintptr_t)(handle))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Internal macro to get printable value of an ODP handle */</td><td> </td><td class="right">/** Internal macro to get printable value of an ODP handle */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>4 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;classification.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;classification.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_CLASSIFY_H_</td><td> </td><td class="right">#ifndef ODP_API_CLASSIFY_H_</td></tr>
      <tr><td class="left">#define ODP_API_CLASSIFY_H_</td><td> </td><td class="right">#define ODP_API_CLASSIFY_H_</td></tr>
      <tr><td class="left">#include &lt;odp/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/packet_io.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/support.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/threshold.h&gt;</span></td></tr>
      <tr><td class="left">/** @defgroup odp_classification ODP CLASSIFICATION</td><td> </td><td class="right">/** @defgroup odp_classification ODP CLASSIFICATION</td></tr>
      <tr><td class="left"> *  Classification operations.</td><td> </td><td class="right"> *  Classification operations.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_cos_t</td><td> </td><td class="right"> * @typedef odp_cos_t</td></tr>
      <tr><td class="left"> * ODP Class of service handle</td><td> </td><td class="right"> * ODP Class of service handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 108</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 111</em></th></tr>
      <tr><td class="left">                * frame. The match is defined by the offset, the</td><td> </td><td class="right">                * frame. The match is defined by the offset, the</td></tr>
      <tr><td class="left">                * expected value, and its size.</td><td> </td><td class="right">                * expected value, and its size.</td></tr>
      <tr><td class="left">                */</td><td> </td><td class="right">                */</td></tr>
      <tr><td class="left">               uint64_t        custom_frame:1;</td><td> </td><td class="right">               uint64_t        custom_frame:1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       } bit;</td><td> </td><td class="right">       } bit;</td></tr>
      <tr><td class="left">       /** All bits of the bit field structure */</td><td> </td><td class="right">       /** All bits of the bit field structure */</td></tr>
      <tr><td class="left">       uint64_t all_bits;</td><td> </td><td class="right">       uint64_t all_bits;</td></tr>
      <tr><td class="left">} odp_cls_pmr_terms_t;</td><td> </td><td class="right">} odp_cls_pmr_terms_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Random Early Detection (RED)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Random Early Detection is enabled to initiate a drop probability for the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * incoming packet when the packets in the queue/pool cross the specified</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * threshold values. RED is enabled when 'red_enable' boolean is true and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the resource usage is equal to or greater than the minimum threshold val</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Resource usage could be defined either as the percentage of pool being f</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ull</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * or the number of packets/bytes occupied in the queue depening on the pla</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tform</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * capabilities.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When RED is enabled for a particular flow then further incoming packets </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * assigned a drop probability based on the size of the pool/queue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Drop probability is configured as follows</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * * Drop probability is 100%, when resource usage &gt;= threshold.max</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * * Drop probability is 0%, when resource usage &lt;= threshold.min</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * * Drop probability is between 0...100 % when resource usage is between</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     threshold.min and threshold.max</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * RED is logically configured in the CoS and could be implemented in eithe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * pool or queue linked to the CoS depending on platform capabilities.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Application should make sure not to link multiple CoS with different RED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * BP configuration to the same queue or pool.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_red_param_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** A boolean to enable RED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * When true, RED is enabled and configured with RED parameters.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Otherwise, RED parameters are ignored. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t enable;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Threshold parameters for RED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * RED is enabled when the resource usage is equal to or greater tha</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * the minimum threshold value and is disabled otherwise</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_threshold_t threshold;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_red_param_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Back pressure (BP)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When back pressure is enabled for a particular flow, the HW can send</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * back pressure information to the remote peer indicating a network conges</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tion.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_bp_param_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** A boolean to enable Back pressure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * When true, back pressure is enabled and configured with the BP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * parameters. Otherwise BP parameters are ignored.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t enable;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Threshold value for back pressure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * BP is enabled when the resource usage is equal to or greater than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * max backpressure threshold. Min threshold parameters are ignored </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * BP configuration.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * @see odp_red_param_t for 'resource usage' documentation.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_threshold_t threshold;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_bp_param_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Classification capabilities</td><td> </td><td class="right"> * Classification capabilities</td></tr>
      <tr><td class="left"> * This capability structure defines system level classification capability</td><td> </td><td class="right"> * This capability structure defines system level classification capability</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_cls_capability_t {</td><td> </td><td class="right">typedef struct odp_cls_capability_t {</td></tr>
      <tr><td class="left">       /** PMR terms supported by the classifier</td><td> </td><td class="right">       /** PMR terms supported by the classifier</td></tr>
      <tr><td class="left">        * A bit mask of one bit for each of odp_pmr_term_t</td><td> </td><td class="right">        * A bit mask of one bit for each of odp_pmr_term_t</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       odp_cls_pmr_terms_t supported_terms;</td><td> </td><td class="right">       odp_cls_pmr_terms_t supported_terms;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Maximum number of PMR terms */</td><td> </td><td class="right">       /** Maximum number of PMR terms */</td></tr>
      <tr><td class="left">       unsigned max_pmr_terms;</td><td> </td><td class="right">       unsigned max_pmr_terms;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Number of PMR terms available for use now */</td><td> </td><td class="right">       /** Number of PMR terms available for use now */</td></tr>
      <tr><td class="left">       unsigned available_pmr_terms;</td><td> </td><td class="right">       unsigned available_pmr_terms;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Maximum number of CoS supported */</td><td> </td><td class="right">       /** Maximum number of CoS supported */</td></tr>
      <tr><td class="left">       unsigned max_cos;</td><td> </td><td class="right">       unsigned max_cos;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Maximun number of queue supported per CoS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * if the value is 1, then hashing is not supported*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_hash_queues;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Protocol header combination supported for Hashing */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_pktin_hash_proto_t hash_protocols;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** A Boolean to denote support of PMR range */</td><td> </td><td class="right">       /** A Boolean to denote support of PMR range */</td></tr>
      <tr><td class="left">       odp_bool_t pmr_range_supported;</td><td> </td><td class="right">       odp_bool_t pmr_range_supported;</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Support for Random Early Detection */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_support_t random_early_detection;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Supported threshold type for RED */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_threshold_types_t threshold_red;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Support for Back Pressure to the remote peer */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_support_t back_pressure;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Supported threshold type for BP */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_threshold_types_t threshold_bp;</span></td></tr>
      <tr><td class="left">} odp_cls_capability_t;</td><td> </td><td class="right">} odp_cls_capability_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * class of service packet drop policies</td><td> </td><td class="right"> * class of service packet drop policies</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum {</td><td> </td><td class="right">typedef enum {</td></tr>
      <tr><td class="left">       ODP_COS_DROP_POOL,    /**&lt; Follow buffer pool drop policy */</td><td> </td><td class="right">       ODP_COS_DROP_POOL,    /**&lt; Follow buffer pool drop policy */</td></tr>
      <tr><td class="left">       ODP_COS_DROP_NEVER,    /**&lt; Never drop, ignoring buffer pool policy 
*/</td><td> </td><td class="right">       ODP_COS_DROP_NEVER,    /**&lt; Never drop, ignoring buffer pool policy 
*/</td></tr>
      <tr><td class="left">} odp_cls_drop_t;</td><td> </td><td class="right">} odp_cls_drop_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 165</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 242</em></th></tr>
      <tr><td class="left">       ODP_COS_FHDR_IPSEC_SPI, /**&lt; IPsec session identifier */</td><td> </td><td class="right">       ODP_COS_FHDR_IPSEC_SPI, /**&lt; IPsec session identifier */</td></tr>
      <tr><td class="left">       ODP_COS_FHDR_LD_VNI,    /**&lt; NVGRE/VXLAN network identifier */</td><td> </td><td class="right">       ODP_COS_FHDR_LD_VNI,    /**&lt; NVGRE/VXLAN network identifier */</td></tr>
      <tr><td class="left">       ODP_COS_FHDR_USER       /**&lt; Application-specific header field(s) */</td><td> </td><td class="right">       ODP_COS_FHDR_USER       /**&lt; Application-specific header field(s) */</td></tr>
      <tr><td class="left">} odp_cos_hdr_flow_fields_t;</td><td> </td><td class="right">} odp_cos_hdr_flow_fields_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Class of service parameters</td><td> </td><td class="right"> * Class of service parameters</td></tr>
      <tr><td class="left"> * Used to communicate class of service creation options</td><td> </td><td class="right"> * Used to communicate class of service creation options</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_cls_cos_param {</td><td> </td><td class="right">typedef struct odp_cls_cos_param {</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">       odp_queue_t queue;      <span class="delete">/**&lt;</span> Queue associated with CoS */</td><td> </td><td class="rblock">       <span class="insert">/** Number of queues to be linked to this CoS.</span></td></tr>
      <tr><td class="lblock">       odp_pool_t pool;        <span class="delete">/**&lt; Pool</span> associated with CoS */</td><td> </td><td class="rblock"><span class="insert">        * If the number is greater than 1 then hashing is enabled.</span></td></tr>
      <tr><td class="lblock">       odp_cls_drop_t drop_policy;     <span class="delete">/**&lt; Drop policy associated with CoS</span></td><td> </td><td class="rblock"><span class="insert">        * If number is equal to 1 then hashing is disabled.</span></td></tr>
      <tr><td class="lblock"> */</td><td> </td><td class="rblock"><span class="insert">        * When hashing is enabled the queues are created by the implementat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * and application need not configure any queue to the class of serv</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ice.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * When hashing is disabled application has to configure the queue t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * the class of service.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Depening on the implementation this number might be rounded-off t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * nearest supported value (e.g power of 2)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t num_queue;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Variant mapping for queue hash configurataion */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       union {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Mapping used when num_queue = 1, hashing is disabled in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * this case and application has to configure this queue and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * packets are delivered to this queue */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               odp_queue_t queue;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** Mapping used when num_queue &gt; 1, hashing is enabled in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * this case and queues are created by the implementation */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /**</span> Queue <span class="insert">parameters */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       odp_queue_param_t queue_param;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /** Protocol header fields which are included in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                        * packet input hash calculation */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       odp_pktin_hash_proto_t hash_proto;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               };</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       };</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Pool</span> associated with CoS */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       odp_pool_t pool;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Drop policy</span> associated with CoS */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       odp_cls_drop_t drop_policy;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Random Early Detection configuration */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_red_param_t red;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Back Pressure configuration</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">odp_bp_param_t bp;</span></td></tr>
      <tr><td class="left">} odp_cls_cos_param_t;</td><td> </td><td class="right">} odp_cls_cos_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize class of service parameters</td><td> </td><td class="right"> * Initialize class of service parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Initialize an odp_cls_cos_param_t to its default value for all fields</td><td> </td><td class="right"> * Initialize an odp_cls_cos_param_t to its default value for all fields</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * @param param   Address of the odp_cls_cos_param_t to be initialized</td><td> </td><td class="rblock"> * @param param   <span class="insert">     </span>Address of the odp_cls_cos_param_t to be initialized</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_cls_cos_param_init(odp_cls_cos_param_t *param);</td><td> </td><td class="right">void odp_cls_cos_param_init(odp_cls_cos_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Query classification capabilities</td><td> </td><td class="right"> * Query classification capabilities</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Outputs classification capabilities on success.</td><td> </td><td class="right"> * Outputs classification capabilities on success.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"> * @param[out] capability  <span class="delete">    Pointer to classification capability structu
</span>re.</td><td> </td><td class="rblock"> * @param[out] capability  <span class="insert">Pointer to classification capability structu</span>re.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * @retval     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cls_capability(odp_cls_capability_t *capability);</td><td> </td><td class="right">int odp_cls_capability(odp_cls_capability_t *capability);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a class-of-service</td><td> </td><td class="right"> * Create a class-of-service</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The use of class-of-service name is optional. Unique names are not requi
red.</td><td> </td><td class="right"> * The use of class-of-service name is optional. Unique names are not requi
red.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"> * @param       name    Name of the class-of-service or NULL. Maximum <span class="delete">strin</span></td><td> </td><td class="rblock"> * @param name         Name of the class-of-service or NULL. Maximum <span class="insert">string</span></td></tr>
      <tr><td class="lblock"><span class="delete">g</span></td><td> </td><td class="rblock"> *                     length is ODP_COS_NAME_LEN.</td></tr>
      <tr><td class="lblock"> *                      length is ODP_COS_NAME_LEN.</td><td> </td><td class="rblock"> * @param param        Class-of-service parameters</td></tr>
      <tr><td class="lblock"> * @param       param   Class-of-service parameters</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"> * @retval              Class-of-service handle</td><td> </td><td class="rblock"> * @retval Class-of-service handle</td></tr>
      <tr><td class="lblock"> * @retval              ODP_COS_INVALID on failure.</td><td> </td><td class="rblock"> * @retval ODP_COS_INVALID on failure.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note ODP_QUEUE_INVALID and ODP_POOL_INVALID are valid values for queue</td><td> </td><td class="right"> * @note ODP_QUEUE_INVALID and ODP_POOL_INVALID are valid values for queue</td></tr>
      <tr><td class="left"> * and pool associated with a class of service and when any one of these va
lues</td><td> </td><td class="right"> * and pool associated with a class of service and when any one of these va
lues</td></tr>
      <tr><td class="left"> * are configured as INVALID then the packets assigned to the CoS gets drop
ped.</td><td> </td><td class="right"> * are configured as INVALID then the packets assigned to the CoS gets drop
ped.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_cos_t odp_cls_cos_create(const char *name, odp_cls_cos_param_t *param);</td><td> </td><td class="right">odp_cos_t odp_cls_cos_create(const char *name, odp_cls_cos_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Queue hash result</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the queue within a CoS in which a particular packet will be enqu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">eued</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * based on the packet parameters and hash protocol field configured with t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * class of service.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param cos          class of service</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param packet       Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval Returns the queue handle on which this packet will be enqueued.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval ODP_QUEUE_INVALID for error case</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @note The packet has to be updated with valid header pointers L2, L3 and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> L4.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_queue_t odp_cls_hash_result(odp_cos_t cos, odp_packet_t packet);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Discard a class-of-service along with all its associated resources</td><td> </td><td class="right"> * Discard a class-of-service along with all its associated resources</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]  cos_id</span>  class-of-service instance.</td><td> </td><td class="rblock"> * @param<span class="insert"> cos_id     </span>  class-of-service instance.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"> * @retval             0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval             &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cos_destroy(odp_cos_t cos_id);</td><td> </td><td class="right">int odp_cos_destroy(odp_cos_t cos_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Assign a queue for a class-of-service</td><td> </td><td class="right"> * Assign a queue for a class-of-service</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  cos_id          class-of-service instance.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> cos_id       class-of-service instance.</td></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"> * <span class="insert">@param</span> queue_id     Identifier of a queue where all packets of this <span class="insert">spec</span></td></tr>
      <tr><td class="lblock"> <span class="delete">* @param[in]</span>  queue_id        Identifier of a queue where all packets</td><td> </td><td class="rblock"><span class="insert">ific</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             of this <span class="delete">specific</span> class of service</td><td> </td><td class="rblock"><span class="insert"> *</span>                     class of service will be enqueued.</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             will be enqueued.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cos_queue_set(odp_cos_t cos_id, odp_queue_t queue_id);</td><td> </td><td class="right">int odp_cos_queue_set(odp_cos_t cos_id, odp_queue_t queue_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">* Get the queue associated with the specific class-of-service</td><td> </td><td class="right">* Get the queue associated with the specific class-of-service</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock">* <span class="delete">@param[in]</span>   cos_id                  class-of-service instance.</td><td> </td><td class="rblock">* <span class="insert">@param</span> cos_id        class-of-service instance.</td></tr>
      <tr><td class="lblock"><span class="delete">*</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">* @retval      queue_handle            Queue handle associated with the</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">*                                      given class-of-service</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock">* @retval      ODP_QUEUE_INVALID       on failure</td><td> </td><td class="rblock">* @retval <span class="insert">Queue handle associated with the given class-of-service</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">* @retval</span> ODP_QUEUE_INVALID on failure</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">odp_queue_t odp_cos_queue(odp_cos_t cos_id);</td><td> </td><td class="right">odp_queue_t odp_cos_queue(odp_cos_t cos_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Get the number of queues linked with the specific class-of-service</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param cos_id       class-of-service instance.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of queues linked with the class-of-service.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint32_t odp_cls_cos_num_queue(odp_cos_t cos_id);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Get the list of queue associated with the specific class-of-service</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      cos_id  class-of-service instance.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] queue   Array of queue handles associated with</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     the class-of-service.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num     Maximum number of queue handles to output.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of queues linked with CoS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval on 0 failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint32_t odp_cls_cos_queues(odp_cos_t cos_id, odp_queue_t queue[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           uint32_t num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Assign packet drop policy for specific class-of-service</td><td> </td><td class="right"> * Assign packet drop policy for specific class-of-service</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  cos_id          class-of-service instance.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> cos_id       class-of-service instance.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  drop_policy     Desired packet drop policy for this class.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> drop_policy  Desired packet drop policy for this class.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Optional.</td><td> </td><td class="right"> * @note Optional.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cos_drop_set(odp_cos_t cos_id, odp_cls_drop_t drop_policy);</td><td> </td><td class="right">int odp_cos_drop_set(odp_cos_t cos_id, odp_cls_drop_t drop_policy);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">* Get the drop policy configured for a specific class-of-service instance.</td><td> </td><td class="right">* Get the drop policy configured for a specific class-of-service instance.</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock">* @param<span class="delete">[in]   cos_id  </span>        class-of-service instance.</td><td> </td><td class="rblock">* @param<span class="insert"> cos_id</span>        class-of-service instance.</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock">* @retval                      Drop policy configured with the given</td><td> </td><td class="rblock">* @retval Drop policy configured with the given class-of-service</td></tr>
      <tr><td class="lblock"><span class="delete">*</span>                              class-of-service</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">odp_cls_drop_t odp_cos_drop(odp_cos_t cos_id);</td><td> </td><td class="right">odp_cls_drop_t odp_cos_drop(odp_cos_t cos_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Request to override per-port class of service</td><td> </td><td class="right"> * Request to override per-port class of service</td></tr>
      <tr><td class="left"> * based on Layer-2 priority field if present.</td><td> </td><td class="right"> * based on Layer-2 priority field if present.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  pktio_in        Ingress port identifier.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio_in     Ingress port identifier.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  num_qos         Number of QoS levels, typically 8.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> num_qos      Number of QoS levels, typically 8.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  qos_table       Values of the Layer-2 QoS header field.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> qos_table    Values of the Layer-2 QoS header field.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  cos_table       Class-of-service assigned to each of the</td><td> </td><td class="rblock"> * <span class="insert">@param</span> cos_table    Class-of-service assigned to each of the allowed</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             allowed Layer-2 QOS levels.</td><td> </td><td class="rblock"> <span class="insert">*</span>                     Layer-2 QOS levels.</td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cos_with_l2_priority(odp_pktio_t pktio_in,</td><td> </td><td class="right">int odp_cos_with_l2_priority(odp_pktio_t pktio_in,</td></tr>
      <tr><td class="left">                            uint8_t num_qos,</td><td> </td><td class="right">                            uint8_t num_qos,</td></tr>
      <tr><td class="left">                            uint8_t qos_table[],</td><td> </td><td class="right">                            uint8_t qos_table[],</td></tr>
      <tr><td class="left">                            odp_cos_t cos_table[]);</td><td> </td><td class="right">                            odp_cos_t cos_table[]);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Request to override per-port class of service</td><td> </td><td class="right"> * Request to override per-port class of service</td></tr>
      <tr><td class="left"> * based on Layer-3 priority field if present.</td><td> </td><td class="right"> * based on Layer-3 priority field if present.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  pktio_in        Ingress port identifier.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio_in       Ingress port identifier.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  num_qos         Number of allowed Layer-3 QoS levels.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> num_qos        Number of allowed Layer-3 QoS levels.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  qos_table       Values of the Layer-3 QoS header field.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> qos_table      Values of the Layer-3 QoS header field.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  cos_table       Class-of-service assigned to each of the</td><td> </td><td class="rblock"> * <span class="insert">@param</span> cos_table      Class-of-service assigned to each of the allowed</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             allowed Layer-3 QOS levels.</td><td> </td><td class="rblock"> <span class="insert">*</span>                       Layer-3 QOS levels.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  l3_preference   when true, Layer-3 QoS overrides</td><td> </td><td class="rblock"> * <span class="insert">@param</span> l3_preference         when true, Layer-3 QoS overrides L2 QoS <span class="insert">whe</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             L2 QoS <span class="delete">when</span> present.</td><td> </td><td class="rblock"><span class="insert">n</span> present.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Optional.</td><td> </td><td class="right"> * @note Optional.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cos_with_l3_qos(odp_pktio_t pktio_in,</td><td> </td><td class="right">int odp_cos_with_l3_qos(odp_pktio_t pktio_in,</td></tr>
      <tr><td class="left">                       uint32_t num_qos,</td><td> </td><td class="right">                       uint32_t num_qos,</td></tr>
      <tr><td class="left">                       uint8_t qos_table[],</td><td> </td><td class="right">                       uint8_t qos_table[],</td></tr>
      <tr><td class="left">                       odp_cos_t cos_table[],</td><td> </td><td class="right">                       odp_cos_t cos_table[],</td></tr>
      <tr><td class="left">                       odp_bool_t l3_preference);</td><td> </td><td class="right">                       odp_bool_t l3_preference);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 399</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 548</em></th></tr>
      <tr><td class="left">       uint32_t        offset;  /**&lt; User-defined offset in packet</td><td> </td><td class="right">       uint32_t        offset;  /**&lt; User-defined offset in packet</td></tr>
      <tr><td class="left">                                Used if term == ODP_PMR_CUSTOM_FRAME only,</td><td> </td><td class="right">                                Used if term == ODP_PMR_CUSTOM_FRAME only,</td></tr>
      <tr><td class="left">                                ignored otherwise */</td><td> </td><td class="right">                                ignored otherwise */</td></tr>
      <tr><td class="left">} odp_pmr_param_t;</td><td> </td><td class="right">} odp_pmr_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize packet matching rule parameters</td><td> </td><td class="right"> * Initialize packet matching rule parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Initialize an odp_pmr_param_t to its default values for all fields</td><td> </td><td class="right"> * Initialize an odp_pmr_param_t to its default values for all fields</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock"> * @param param Address of the odp_pmr_param_t to be initialized</td><td> </td><td class="rblock"> * @param param <span class="insert">       </span>Address of the odp_pmr_param_t to be initialized</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_cls_pmr_param_init(odp_pmr_param_t *param);</td><td> </td><td class="right">void odp_cls_pmr_param_init(odp_pmr_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a packet match rule between source and destination class of servi
ce.</td><td> </td><td class="right"> * Create a packet match rule between source and destination class of servi
ce.</td></tr>
      <tr><td class="left"> * This packet matching rule is applied on all packets arriving at the sour
ce</td><td> </td><td class="right"> * This packet matching rule is applied on all packets arriving at the sour
ce</td></tr>
      <tr><td class="left"> * class of service and packets satisfying this PMR are sent to the destina
tion</td><td> </td><td class="right"> * class of service and packets satisfying this PMR are sent to the destina
tion</td></tr>
      <tr><td class="left"> * class of service.</td><td> </td><td class="right"> * class of service.</td></tr>
      <tr><td class="left"> * A composite PMR rule is created when the number of terms in the match ru
le</td><td> </td><td class="right"> * A composite PMR rule is created when the number of terms in the match ru
le</td></tr>
      <tr><td class="left"> * is more than one. The composite rule is considered as matching only if</td><td> </td><td class="right"> * is more than one. The composite rule is considered as matching only if</td></tr>
      <tr><td class="left"> * the packet satisfies all the terms in Packet Match Rule.</td><td> </td><td class="right"> * the packet satisfies all the terms in Packet Match Rule.</td></tr>
      <tr><td class="left"> * The underlying platform may not support all or any specific combination</td><td> </td><td class="right"> * The underlying platform may not support all or any specific combination</td></tr>
      <tr><td class="left"> * of value match rules, and the application should take care</td><td> </td><td class="right"> * of value match rules, and the application should take care</td></tr>
      <tr><td class="left"> * of inspecting the return value when installing such rules, and perform</td><td> </td><td class="right"> * of inspecting the return value when installing such rules, and perform</td></tr>
      <tr><td class="left"> * appropriate fallback action.</td><td> </td><td class="right"> * appropriate fallback action.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  terms           Array of odp_pmr_param_t entries, one entry </td><td> </td><td class="rblock"> * <span class="insert">@param</span> terms        Array of odp_pmr_param_t entries, one entry per term</td></tr>
      <tr><td class="lblock">per</td><td> </td><td class="rblock"> <span class="insert">*</span>                     desired.</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             term desired.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> num_terms    Number of terms in the match rule.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  num_terms       Number of terms in the match rule.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> src_cos      source CoS handle</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  src_cos         source CoS handle</td><td> </td><td class="rblock"> * <span class="insert">@param</span> dst_cos      destination CoS handle</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  dst_cos         destination CoS handle</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lblock"> * @return                     Handle to the Packet Match Rule.</td><td> </td><td class="rblock"> * @return Handle to the Packet Match Rule.</td></tr>
      <tr><td class="lblock"> * @retval                     ODP_PMR_INVAL on failure</td><td> </td><td class="rblock"> * @retval ODP_PMR_INVAL on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pmr_t odp_cls_pmr_create(const odp_pmr_param_t *terms, int num_terms,</td><td> </td><td class="right">odp_pmr_t odp_cls_pmr_create(const odp_pmr_param_t *terms, int num_terms,</td></tr>
      <tr><td class="left">                            odp_cos_t src_cos, odp_cos_t dst_cos);</td><td> </td><td class="right">                            odp_cos_t src_cos, odp_cos_t dst_cos);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Function to destroy a packet match rule</td><td> </td><td class="right"> * Function to destroy a packet match rule</td></tr>
      <tr><td class="left"> * Destroying a PMR removes the link between the source and destination</td><td> </td><td class="right"> * Destroying a PMR removes the link between the source and destination</td></tr>
      <tr><td class="left"> * class of service and this PMR will no longer be applied for packets arri
ving</td><td> </td><td class="right"> * class of service and this PMR will no longer be applied for packets arri
ving</td></tr>
      <tr><td class="left"> * at the source class of service. All the resource associated with the PMR</td><td> </td><td class="right"> * at the source class of service. All the resource associated with the PMR</td></tr>
      <tr><td class="left"> * be release but the class of service will remain intact.</td><td> </td><td class="right"> * be release but the class of service will remain intact.</td></tr>
      <tr><td class="left"> * Depending on the implementation details, destroying a composite rule</td><td> </td><td class="right"> * Depending on the implementation details, destroying a composite rule</td></tr>
      <tr><td class="left"> * may not guarantee the availability of hardware resources to create the</td><td> </td><td class="right"> * may not guarantee the availability of hardware resources to create the</td></tr>
      <tr><td class="left"> * same or essentially similar rule.</td><td> </td><td class="right"> * same or essentially similar rule.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]  pmr_id</span>  Identifier of the PMR to be destroyed</td><td> </td><td class="rblock"> * @param<span class="insert"> pmr_id     </span>  Identifier of the PMR to be destroyed</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lblock"> * @retval             0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval             &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cls_pmr_destroy(odp_pmr_t pmr_id);</td><td> </td><td class="right">int odp_cls_pmr_destroy(odp_pmr_t pmr_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">* Assigns a packet pool for a specific class of service.</td><td> </td><td class="right">* Assigns a packet pool for a specific class of service.</td></tr>
      <tr><td class="left">* All the packets belonging to the given class of service will</td><td> </td><td class="right">* All the packets belonging to the given class of service will</td></tr>
      <tr><td class="left">* be allocated from the assigned packet pool.</td><td> </td><td class="right">* be allocated from the assigned packet pool.</td></tr>
      <tr><td class="left">* The packet pool associated with class of service will supersede the</td><td> </td><td class="right">* The packet pool associated with class of service will supersede the</td></tr>
      <tr><td class="left">* packet pool associated with the pktio interface.</td><td> </td><td class="right">* packet pool associated with the pktio interface.</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lblock">* @param       cos_id  class of service handle</td><td> </td><td class="rblock">* @param cos_id        class of service handle</td></tr>
      <tr><td class="lblock">* @param       pool_id packet pool handle</td><td> </td><td class="rblock">* @param pool_id       packet pool handle</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lblock">* @retval      0 on success</td><td> </td><td class="rblock">* @retval  0 on success</td></tr>
      <tr><td class="lblock">* @retval      &lt;0 on failure</td><td> </td><td class="rblock">* @retval &lt;0 on failure</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">int odp_cls_cos_pool_set(odp_cos_t cos_id, odp_pool_t pool_id);</td><td> </td><td class="right">int odp_cls_cos_pool_set(odp_cos_t cos_id, odp_pool_t pool_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">* Get the pool associated with the given class of service</td><td> </td><td class="right">* Get the pool associated with the given class of service</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lblock">* @param <span class="delete">      cos_id</span>  class of service handle</td><td> </td><td class="rblock">* @param <span class="insert">cos_id      </span>  class of service handle</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lblock">* @retval      pool handle of the associated pool</td><td> </td><td class="rblock">* @retval pool handle of the associated pool</td></tr>
      <tr><td class="lblock">* @retval      ODP_POOL_INVALID if no associated pool found or</td><td> </td><td class="rblock">* @retval ODP_POOL_INVALID if no associated pool found or in case of an <span class="insert">err</span></td></tr>
      <tr><td class="lblock"><span class="delete">*</span>              in case of an <span class="delete">error</span></td><td> </td><td class="rblock"><span class="insert">or</span></td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">odp_pool_t odp_cls_cos_pool(odp_cos_t cos_id);</td><td> </td><td class="right">odp_pool_t odp_cls_cos_pool(odp_cos_t cos_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get printable value for an odp_cos_t</td><td> </td><td class="right"> * Get printable value for an odp_cos_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lblock"> * @param hdl  odp_cos_t handle to be printed</td><td> </td><td class="rblock"> * @param hdl          odp_cos_t handle to be printed</td></tr>
      <tr><td class="lblock"> * @return     uint64_t value that can be used to print/display this</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>             handle</td><td> </td><td class="rblock"> <span class="insert">*</span> @return uint64_t value that can be used to print/display this handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note This routine is intended to be used for diagnostic purposes</td><td> </td><td class="right"> * @note This routine is intended to be used for diagnostic purposes</td></tr>
      <tr><td class="left"> * to enable applications to generate a printable value that represents</td><td> </td><td class="right"> * to enable applications to generate a printable value that represents</td></tr>
      <tr><td class="left"> * an odp_cos_t handle.</td><td> </td><td class="right"> * an odp_cos_t handle.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint64_t odp_cos_to_u64(odp_cos_t hdl);</td><td> </td><td class="right">uint64_t odp_cos_to_u64(odp_cos_t hdl);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get printable value for an odp_pmr_t</td><td> </td><td class="right"> * Get printable value for an odp_pmr_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lblock"> * @param hdl  odp_pmr_t handle to be printed</td><td> </td><td class="rblock"> * @param hdl          odp_pmr_t handle to be printed</td></tr>
      <tr><td class="lblock"> * @return     uint64_t value that can be used to print/display this</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>             handle</td><td> </td><td class="rblock"> <span class="insert">*</span> @return uint64_t value that can be used to print/display this handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note This routine is intended to be used for diagnostic purposes</td><td> </td><td class="right"> * @note This routine is intended to be used for diagnostic purposes</td></tr>
      <tr><td class="left"> * to enable applications to generate a printable value that represents</td><td> </td><td class="right"> * to enable applications to generate a printable value that represents</td></tr>
      <tr><td class="left"> * an odp_pmr_t handle.</td><td> </td><td class="right"> * an odp_pmr_t handle.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint64_t odp_pmr_to_u64(odp_pmr_t hdl);</td><td> </td><td class="right">uint64_t odp_pmr_to_u64(odp_pmr_t hdl);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 36 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>78 lines changed or deleted</i></th><th><i> </i></th><th><i>243 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;crypto.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;crypto.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 18</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 18</em></th></tr>
      <tr><td class="left"> * @file</td><td> </td><td class="right"> * @file</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ODP crypto</td><td> </td><td class="right"> * ODP crypto</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_CRYPTO_H_</td><td> </td><td class="right">#ifndef ODP_API_CRYPTO_H_</td></tr>
      <tr><td class="left">#define ODP_API_CRYPTO_H_</td><td> </td><td class="right">#define ODP_API_CRYPTO_H_</td></tr>
      <tr><td class="left">#include &lt;odp/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/deprecated.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/deprecated.h&gt;</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/support.h&gt;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/packet.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/packet.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @defgroup odp_crypto ODP CRYPTO</td><td> </td><td class="right">/** @defgroup odp_crypto ODP CRYPTO</td></tr>
      <tr><td class="left"> *  Macros, enums, types and operations to utilise crypto.</td><td> </td><td class="right"> *  Macros, enums, types and operations to utilise crypto.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 81</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 82</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** DES */</td><td> </td><td class="right">       /** DES */</td></tr>
      <tr><td class="left">       ODP_CIPHER_ALG_DES,</td><td> </td><td class="right">       ODP_CIPHER_ALG_DES,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Triple DES with cipher block chaining */</td><td> </td><td class="right">       /** Triple DES with cipher block chaining */</td></tr>
      <tr><td class="left">       ODP_CIPHER_ALG_3DES_CBC,</td><td> </td><td class="right">       ODP_CIPHER_ALG_3DES_CBC,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** AES with cipher block chaining */</td><td> </td><td class="right">       /** AES with cipher block chaining */</td></tr>
      <tr><td class="left">       ODP_CIPHER_ALG_AES_CBC,</td><td> </td><td class="right">       ODP_CIPHER_ALG_AES_CBC,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** AES with counter mode */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_CIPHER_ALG_AES_CTR,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** AES in Galois/Counter Mode</td><td> </td><td class="right">       /** AES in Galois/Counter Mode</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  @note Must be paired with cipher ODP_AUTH_ALG_AES_GCM</td><td> </td><td class="right">        *  @note Must be paired with cipher ODP_AUTH_ALG_AES_GCM</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       ODP_CIPHER_ALG_AES_GCM,</td><td> </td><td class="right">       ODP_CIPHER_ALG_AES_GCM,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** @deprecated  Use ODP_CIPHER_ALG_AES_CBC instead */</td><td> </td><td class="right">       /** @deprecated  Use ODP_CIPHER_ALG_AES_CBC instead */</td></tr>
      <tr><td class="left">       ODP_DEPRECATE(ODP_CIPHER_ALG_AES128_CBC),</td><td> </td><td class="right">       ODP_DEPRECATE(ODP_CIPHER_ALG_AES128_CBC),</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** @deprecated  Use ODP_CIPHER_ALG_AES_GCM instead */</td><td> </td><td class="right">       /** @deprecated  Use ODP_CIPHER_ALG_AES_GCM instead */</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">       ODP_DEPRECATE(ODP_CIPHER_ALG_AES128_GCM)</td><td> </td><td class="rblock">       ODP_DEPRECATE(ODP_CIPHER_ALG_AES128_GCM)<span class="insert">,</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_cipher_alg_t;</td><td> </td><td class="right">} odp_cipher_alg_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Crypto API authentication algorithm</td><td> </td><td class="right"> * Crypto API authentication algorithm</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum {</td><td> </td><td class="right">typedef enum {</td></tr>
      <tr><td class="left">        /** No authentication algorithm specified */</td><td> </td><td class="right">        /** No authentication algorithm specified */</td></tr>
      <tr><td class="left">       ODP_AUTH_ALG_NULL,</td><td> </td><td class="right">       ODP_AUTH_ALG_NULL,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 132</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 136</em></th></tr>
      <tr><td class="left">        *  SHA-512 algorithm in HMAC mode</td><td> </td><td class="right">        *  SHA-512 algorithm in HMAC mode</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       ODP_AUTH_ALG_SHA512_HMAC,</td><td> </td><td class="right">       ODP_AUTH_ALG_SHA512_HMAC,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** AES in Galois/Counter Mode</td><td> </td><td class="right">       /** AES in Galois/Counter Mode</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  @note Must be paired with cipher ODP_CIPHER_ALG_AES_GCM</td><td> </td><td class="right">        *  @note Must be paired with cipher ODP_CIPHER_ALG_AES_GCM</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       ODP_AUTH_ALG_AES_GCM,</td><td> </td><td class="right">       ODP_AUTH_ALG_AES_GCM,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** AES in Galois/Counter MAC Mode</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * NIST and RFC specifications of GCM/GMAC refer to all data to be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * authenticated as AAD. In constrast to that, ODP API specifies the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * bulk of authenticated data to be located in packet payload for al</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * authentication algorithms, including GMAC. Thus for GMAC applicat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * should also pass all data to be authenticated as packet data. AAD</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * not used for GMAC. GMAC IV should be passed via session IV or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * per-packet IV override.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * @note Must be paired with cipher ODP_CIPHER_ALG_NULL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_AUTH_ALG_AES_GMAC,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** @deprecated  Use ODP_AUTH_ALG_MD5_HMAC instead */</td><td> </td><td class="right">       /** @deprecated  Use ODP_AUTH_ALG_MD5_HMAC instead */</td></tr>
      <tr><td class="left">       ODP_DEPRECATE(ODP_AUTH_ALG_MD5_96),</td><td> </td><td class="right">       ODP_DEPRECATE(ODP_AUTH_ALG_MD5_96),</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** @deprecated  Use ODP_AUTH_ALG_SHA256_HMAC instead */</td><td> </td><td class="right">       /** @deprecated  Use ODP_AUTH_ALG_SHA256_HMAC instead */</td></tr>
      <tr><td class="left">       ODP_DEPRECATE(ODP_AUTH_ALG_SHA256_128),</td><td> </td><td class="right">       ODP_DEPRECATE(ODP_AUTH_ALG_SHA256_128),</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** @deprecated  Use ODP_AUTH_ALG_AES_GCM instead */</td><td> </td><td class="right">       /** @deprecated  Use ODP_AUTH_ALG_AES_GCM instead */</td></tr>
      <tr><td class="left">       ODP_DEPRECATE(ODP_AUTH_ALG_AES128_GCM)</td><td> </td><td class="right">       ODP_DEPRECATE(ODP_AUTH_ALG_AES128_GCM)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_auth_alg_t;</td><td> </td><td class="right">} odp_auth_alg_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 161</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 179</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** ODP_CIPHER_ALG_DES */</td><td> </td><td class="right">               /** ODP_CIPHER_ALG_DES */</td></tr>
      <tr><td class="left">               uint32_t des         : 1;</td><td> </td><td class="right">               uint32_t des         : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** ODP_CIPHER_ALG_3DES_CBC */</td><td> </td><td class="right">               /** ODP_CIPHER_ALG_3DES_CBC */</td></tr>
      <tr><td class="left">               uint32_t trides_cbc  : 1;</td><td> </td><td class="right">               uint32_t trides_cbc  : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** ODP_CIPHER_ALG_AES_CBC */</td><td> </td><td class="right">               /** ODP_CIPHER_ALG_AES_CBC */</td></tr>
      <tr><td class="left">               uint32_t aes_cbc     : 1;</td><td> </td><td class="right">               uint32_t aes_cbc     : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** ODP_CIPHER_ALG_AES_CTR */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t aes_ctr     : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">               /** ODP_CIPHER_ALG_AES_GCM */</td><td> </td><td class="right">               /** ODP_CIPHER_ALG_AES_GCM */</td></tr>
      <tr><td class="left">               uint32_t aes_gcm     : 1;</td><td> </td><td class="right">               uint32_t aes_gcm     : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** @deprecated  Use aes_cbc instead */</td><td> </td><td class="right">               /** @deprecated  Use aes_cbc instead */</td></tr>
      <tr><td class="left">               uint32_t ODP_DEPRECATE(aes128_cbc) : 1;</td><td> </td><td class="right">               uint32_t ODP_DEPRECATE(aes128_cbc) : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** @deprecated  Use aes_gcm instead */</td><td> </td><td class="right">               /** @deprecated  Use aes_gcm instead */</td></tr>
      <tr><td class="left">               uint32_t ODP_DEPRECATE(aes128_gcm) : 1;</td><td> </td><td class="right">               uint32_t ODP_DEPRECATE(aes128_gcm) : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       } bit;</td><td> </td><td class="right">       } bit;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 203</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 224</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** ODP_AUTH_ALG_SHA256_HMAC */</td><td> </td><td class="right">               /** ODP_AUTH_ALG_SHA256_HMAC */</td></tr>
      <tr><td class="left">               uint32_t sha256_hmac : 1;</td><td> </td><td class="right">               uint32_t sha256_hmac : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** ODP_AUTH_ALG_SHA512_HMAC */</td><td> </td><td class="right">               /** ODP_AUTH_ALG_SHA512_HMAC */</td></tr>
      <tr><td class="left">               uint32_t sha512_hmac : 1;</td><td> </td><td class="right">               uint32_t sha512_hmac : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** ODP_AUTH_ALG_AES_GCM */</td><td> </td><td class="right">               /** ODP_AUTH_ALG_AES_GCM */</td></tr>
      <tr><td class="left">               uint32_t aes_gcm     : 1;</td><td> </td><td class="right">               uint32_t aes_gcm     : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** ODP_AUTH_ALG_AES_GMAC*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t aes_gmac    : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">               /** @deprecated  Use md5_hmac instead */</td><td> </td><td class="right">               /** @deprecated  Use md5_hmac instead */</td></tr>
      <tr><td class="left">               uint32_t ODP_DEPRECATE(md5_96)     : 1;</td><td> </td><td class="right">               uint32_t ODP_DEPRECATE(md5_96)     : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** @deprecated  Use sha256_hmac instead */</td><td> </td><td class="right">               /** @deprecated  Use sha256_hmac instead */</td></tr>
      <tr><td class="left">               uint32_t ODP_DEPRECATE(sha256_128) : 1;</td><td> </td><td class="right">               uint32_t ODP_DEPRECATE(sha256_128) : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** @deprecated  Use aes_gcm instead */</td><td> </td><td class="right">               /** @deprecated  Use aes_gcm instead */</td></tr>
      <tr><td class="left">               uint32_t ODP_DEPRECATE(aes128_gcm) : 1;</td><td> </td><td class="right">               uint32_t ODP_DEPRECATE(aes128_gcm) : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       } bit;</td><td> </td><td class="right">       } bit;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l6" /><small>skipping to change at</small><em> line 272</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 296</em></th></tr>
      <tr><td class="left">        *  and is relative to the operation (encode vs decode). When encodi
ng,</td><td> </td><td class="right">        *  and is relative to the operation (encode vs decode). When encodi
ng,</td></tr>
      <tr><td class="left">        *  TRUE indicates the authentication operation should be performed</td><td> </td><td class="right">        *  TRUE indicates the authentication operation should be performed</td></tr>
      <tr><td class="left">        *  after the cipher operation else before. When decoding, TRUE</td><td> </td><td class="right">        *  after the cipher operation else before. When decoding, TRUE</td></tr>
      <tr><td class="left">        *  indicates the reverse order of operation.</td><td> </td><td class="right">        *  indicates the reverse order of operation.</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  true:  Authenticate cipher text</td><td> </td><td class="right">        *  true:  Authenticate cipher text</td></tr>
      <tr><td class="left">        *  false: Authenticate plain text</td><td> </td><td class="right">        *  false: Authenticate plain text</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       odp_bool_t auth_cipher_text;</td><td> </td><td class="right">       odp_bool_t auth_cipher_text;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock">       /** Preferred sync vs. async */</td><td> </td><td class="rblock">       /** Preferred sync vs. async <span class="insert">for odp_crypto_operation() </span>*/</td></tr>
      <tr><td class="left">       odp_crypto_op_mode_t pref_mode;</td><td> </td><td class="right">       odp_crypto_op_mode_t pref_mode;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Operation mode when using packet interface: sync or async */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_op_mode_t op_mode;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** Cipher algorithm</td><td> </td><td class="right">       /** Cipher algorithm</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  Use odp_crypto_capability() for supported algorithms.</td><td> </td><td class="right">        *  Use odp_crypto_capability() for supported algorithms.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       odp_cipher_alg_t cipher_alg;</td><td> </td><td class="right">       odp_cipher_alg_t cipher_alg;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Cipher key</td><td> </td><td class="right">       /** Cipher key</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        * Use odp_crypto_cipher_capa() for supported key and IV lengths.</td><td> </td><td class="right">        * Use odp_crypto_cipher_capa() for supported key and IV lengths.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l7" /><small>skipping to change at</small><em> line 308</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 335</em></th></tr>
      <tr><td class="left">        *  Use odp_crypto_auth_capability() for supported key lengths.</td><td> </td><td class="right">        *  Use odp_crypto_auth_capability() for supported key lengths.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       odp_crypto_key_t auth_key;</td><td> </td><td class="right">       odp_crypto_key_t auth_key;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Authentication digest length in bytes</td><td> </td><td class="right">       /** Authentication digest length in bytes</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  Use odp_crypto_auth_capability() for supported digest lengths.</td><td> </td><td class="right">        *  Use odp_crypto_auth_capability() for supported digest lengths.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       uint32_t auth_digest_len;</td><td> </td><td class="right">       uint32_t auth_digest_len;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Additional Authenticated Data (AAD) length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  AAD length is constant for all operations (packets) of the sessi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">on.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Set to zero when AAD is not used. Use odp_crypto_auth_capability</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  for supported AAD lengths. The default value is zero.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t auth_aad_len;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** Async mode completion event queue</td><td> </td><td class="right">       /** Async mode completion event queue</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock">        *  <span class="delete">When odp_crypto_operation() is asynchronous, the</span> completion <span class="delete">queu</span></td><td> </td><td class="rblock">        *  <span class="insert">The</span> completion <span class="insert">queue</span> is used to return <span class="insert">completions from</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span> is</td><td> </td><td class="rblock"><span class="insert">        *  odp_crypto_operation() or odp_crypto_op_enq() results</span> to the</td></tr>
      <tr><td class="lblock">        <span class="delete">*</span>  used to return <span class="delete">the completion status of the operation</span> to the</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">        *  application.</td><td> </td><td class="right">        *  application.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       odp_queue_t compl_queue;</td><td> </td><td class="right">       odp_queue_t compl_queue;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Output pool</td><td> </td><td class="right">       /** Output pool</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  When the output packet is not specified during the call to</td><td> </td><td class="right">        *  When the output packet is not specified during the call to</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">        *  <span class="delete">odp_crypto_operation()</span>, the output packet will be allocated</td><td> </td><td class="rblock">        *  <span class="insert">crypto operation</span>, the output packet will be allocated</td></tr>
      <tr><td class="left">        *  from this pool.</td><td> </td><td class="right">        *  from this pool.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       odp_pool_t output_pool;</td><td> </td><td class="right">       odp_pool_t output_pool;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_crypto_session_param_t;</td><td> </td><td class="right">} odp_crypto_session_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @deprecated  Use odp_crypto_session_param_t instead */</td><td> </td><td class="right">/** @deprecated  Use odp_crypto_session_param_t instead */</td></tr>
      <tr><td class="left">typedef odp_crypto_session_param_t ODP_DEPRECATE(odp_crypto_session_params_
t);</td><td> </td><td class="right">typedef odp_crypto_session_param_t ODP_DEPRECATE(odp_crypto_session_params_
t);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l8" /><small>skipping to change at</small><em> line 374</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 409</em></th></tr>
      <tr><td class="left">       /** Offset from start of packet for hash result</td><td> </td><td class="right">       /** Offset from start of packet for hash result</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        *  Specifies the offset where the hash result is to be stored. In c
ase</td><td> </td><td class="right">        *  Specifies the offset where the hash result is to be stored. In c
ase</td></tr>
      <tr><td class="left">        *  of decode sessions, input hash values will be read from this off
set,</td><td> </td><td class="right">        *  of decode sessions, input hash values will be read from this off
set,</td></tr>
      <tr><td class="left">        *  and overwritten with hash results. If this offset lies within</td><td> </td><td class="right">        *  and overwritten with hash results. If this offset lies within</td></tr>
      <tr><td class="left">        *  specified 'auth_range', implementation will mute this field befo
re</td><td> </td><td class="right">        *  specified 'auth_range', implementation will mute this field befo
re</td></tr>
      <tr><td class="left">        *  calculating the hash result.</td><td> </td><td class="right">        *  calculating the hash result.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       uint32_t hash_result_offset;</td><td> </td><td class="right">       uint32_t hash_result_offset;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">Additional Authenticated Data (AAD) */</span></td><td> </td><td class="rblock">       /** Pointer to <span class="insert">AAD.</span> AAD length <span class="insert">is defined by 'auth_aad_len'</span></td></tr>
      <tr><td class="lblock"><span class="delete">       struct {</span></td><td> </td><td class="rblock">        *  <span class="insert">session parameter.</span></td></tr>
      <tr><td class="lblock"><span class="delete">               /**</span> Pointer to <span class="delete">ADD */</span></td><td> </td><td class="rblock">        */</td></tr>
      <tr><td class="lblock"><span class="delete">               uint8_t *ptr;</span></td><td> </td><td class="rblock">       <span class="insert">uint8_t *aad_ptr;</span></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               /**</span> AAD length <span class="delete">in bytes. Use odp_crypto_auth_capability() fo</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">r</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                *  <span class="delete">supported AAD lengths.</span> */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">               <span class="delete">uint32_t length;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       } aad;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Data range to apply cipher */</td><td> </td><td class="right">       /** Data range to apply cipher */</td></tr>
      <tr><td class="left">       odp_packet_data_range_t cipher_range;</td><td> </td><td class="right">       odp_packet_data_range_t cipher_range;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Data range to authenticate */</td><td> </td><td class="right">       /** Data range to authenticate */</td></tr>
      <tr><td class="left">       odp_packet_data_range_t auth_range;</td><td> </td><td class="right">       odp_packet_data_range_t auth_range;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_crypto_op_param_t;</td><td> </td><td class="right">} odp_crypto_op_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @deprecated  Use odp_crypto_op_param_t instead */</td><td> </td><td class="right">/** @deprecated  Use odp_crypto_op_param_t instead */</td></tr>
      <tr><td class="left">typedef odp_crypto_op_param_t ODP_DEPRECATE(odp_crypto_op_params_t);</td><td> </td><td class="right">typedef odp_crypto_op_param_t ODP_DEPRECATE(odp_crypto_op_params_t);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Crypto packet API per packet operation parameters</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_crypto_packet_op_param_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Session handle from creation */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_session_t session;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Override session IV pointer */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t *override_iv_ptr;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Offset from start of packet for hash result</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Specifies the offset where the hash result is to be stored. In c</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ase</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  of decode sessions, input hash values will be read from this off</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">set,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  and overwritten with hash results. If this offset lies within</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  specified 'auth_range', implementation will mute this field befo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">re</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  calculating the hash result.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t hash_result_offset;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Pointer to AAD. AAD length is defined by 'auth_aad_len'</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  session parameter.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t *aad_ptr;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Data range to apply cipher */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_packet_data_range_t cipher_range;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Data range to authenticate */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_packet_data_range_t auth_range;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_crypto_packet_op_param_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Crypto API session creation return code</td><td> </td><td class="right"> * Crypto API session creation return code</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum {</td><td> </td><td class="right">typedef enum {</td></tr>
      <tr><td class="left">       /** Session created */</td><td> </td><td class="right">       /** Session created */</td></tr>
      <tr><td class="left">       ODP_CRYPTO_SES_CREATE_ERR_NONE,</td><td> </td><td class="right">       ODP_CRYPTO_SES_CREATE_ERR_NONE,</td></tr>
      <tr><td class="left">       /** Creation failed, no resources */</td><td> </td><td class="right">       /** Creation failed, no resources */</td></tr>
      <tr><td class="left">       ODP_CRYPTO_SES_CREATE_ERR_ENOMEM,</td><td> </td><td class="right">       ODP_CRYPTO_SES_CREATE_ERR_ENOMEM,</td></tr>
      <tr><td class="left">       /** Creation failed, bad cipher params */</td><td> </td><td class="right">       /** Creation failed, bad cipher params */</td></tr>
      <tr><td class="left">       ODP_CRYPTO_SES_CREATE_ERR_INV_CIPHER,</td><td> </td><td class="right">       ODP_CRYPTO_SES_CREATE_ERR_INV_CIPHER,</td></tr>
      <tr><td class="left">       /** Creation failed, bad auth params */</td><td> </td><td class="right">       /** Creation failed, bad auth params */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l9" /><small>skipping to change at</small><em> line 440</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 503</em></th></tr>
      <tr><td class="left">       ODP_CRYPTO_HW_ERR_NONE,</td><td> </td><td class="right">       ODP_CRYPTO_HW_ERR_NONE,</td></tr>
      <tr><td class="left">       /** Error detected during DMA of data */</td><td> </td><td class="right">       /** Error detected during DMA of data */</td></tr>
      <tr><td class="left">       ODP_CRYPTO_HW_ERR_DMA,</td><td> </td><td class="right">       ODP_CRYPTO_HW_ERR_DMA,</td></tr>
      <tr><td class="left">       /** Operation failed due to pool depletion */</td><td> </td><td class="right">       /** Operation failed due to pool depletion */</td></tr>
      <tr><td class="left">       ODP_CRYPTO_HW_ERR_BP_DEPLETED,</td><td> </td><td class="right">       ODP_CRYPTO_HW_ERR_BP_DEPLETED,</td></tr>
      <tr><td class="left">} odp_crypto_hw_err_t;</td><td> </td><td class="right">} odp_crypto_hw_err_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Cryto API per packet operation completion status</td><td> </td><td class="right"> * Cryto API per packet operation completion status</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock">typedef struct odp_crypto_<span class="delete">compl</span>_status {</td><td> </td><td class="rblock">typedef struct odp_crypto_<span class="insert">op</span>_status {</td></tr>
      <tr><td class="left">       /** Algorithm specific return code */</td><td> </td><td class="right">       /** Algorithm specific return code */</td></tr>
      <tr><td class="left">       odp_crypto_alg_err_t alg_err;</td><td> </td><td class="right">       odp_crypto_alg_err_t alg_err;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Hardware specific return code */</td><td> </td><td class="right">       /** Hardware specific return code */</td></tr>
      <tr><td class="left">       odp_crypto_hw_err_t  hw_err;</td><td> </td><td class="right">       odp_crypto_hw_err_t  hw_err;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock">} <span class="delete">odp_crypto_compl_status_t;</span></td><td> </td><td class="rblock">} <span class="insert">odp_crypto_op_status_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @deprecated  Use ODP_DEPRECATE(odp_crypto_op_status_t) instead */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef odp_crypto_op_status_t ODP_DEPRECATE(odp_crypto_compl_status_t);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Crypto API operation result</td><td> </td><td class="right"> * Crypto API operation result</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_crypto_op_result {</td><td> </td><td class="right">typedef struct odp_crypto_op_result {</td></tr>
      <tr><td class="left">       /** Request completed successfully */</td><td> </td><td class="right">       /** Request completed successfully */</td></tr>
      <tr><td class="left">       odp_bool_t  ok;</td><td> </td><td class="right">       odp_bool_t  ok;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** User context from request */</td><td> </td><td class="right">       /** User context from request */</td></tr>
      <tr><td class="left">       void *ctx;</td><td> </td><td class="right">       void *ctx;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Output packet */</td><td> </td><td class="right">       /** Output packet */</td></tr>
      <tr><td class="left">       odp_packet_t pkt;</td><td> </td><td class="right">       odp_packet_t pkt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Cipher status */</td><td> </td><td class="right">       /** Cipher status */</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock">       odp_crypto_<span class="delete">compl</span>_status_t cipher_status;</td><td> </td><td class="rblock">       odp_crypto_<span class="insert">op</span>_status_t cipher_status;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Authentication status */</td><td> </td><td class="right">       /** Authentication status */</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock">       odp_crypto_<span class="delete">compl</span>_status_t auth_status;</td><td> </td><td class="rblock">       odp_crypto_<span class="insert">op</span>_status_t auth_status;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_crypto_op_result_t;</td><td> </td><td class="right">} odp_crypto_op_result_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Crypto packet API operation result</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_crypto_packet_result_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Request completed successfully */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t  ok;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Cipher status */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_op_status_t cipher_status;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Authentication status */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_op_status_t auth_status;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_crypto_packet_result_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Crypto capabilities</td><td> </td><td class="right"> * Crypto capabilities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_crypto_capability_t {</td><td> </td><td class="right">typedef struct odp_crypto_capability_t {</td></tr>
      <tr><td class="left">       /** Maximum number of crypto sessions */</td><td> </td><td class="right">       /** Maximum number of crypto sessions */</td></tr>
      <tr><td class="left">       uint32_t max_sessions;</td><td> </td><td class="right">       uint32_t max_sessions;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Supported packet operation in SYNC mode */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_support_t sync_mode;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Supported packet operation in ASYNC mode */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_support_t async_mode;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** Supported cipher algorithms */</td><td> </td><td class="right">       /** Supported cipher algorithms */</td></tr>
      <tr><td class="left">       odp_crypto_cipher_algos_t ciphers;</td><td> </td><td class="right">       odp_crypto_cipher_algos_t ciphers;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Cipher algorithms implemented with HW offload */</td><td> </td><td class="right">       /** Cipher algorithms implemented with HW offload */</td></tr>
      <tr><td class="left">       odp_crypto_cipher_algos_t hw_ciphers;</td><td> </td><td class="right">       odp_crypto_cipher_algos_t hw_ciphers;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Supported authentication algorithms */</td><td> </td><td class="right">       /** Supported authentication algorithms */</td></tr>
      <tr><td class="left">       odp_crypto_auth_algos_t   auths;</td><td> </td><td class="right">       odp_crypto_auth_algos_t   auths;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Authentication algorithms implemented with HW offload */</td><td> </td><td class="right">       /** Authentication algorithms implemented with HW offload */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l10" /><small>skipping to change at</small><em> line 584</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 671</em></th></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_crypto_auth_capability(odp_auth_alg_t auth,</td><td> </td><td class="right">int odp_crypto_auth_capability(odp_auth_alg_t auth,</td></tr>
      <tr><td class="left">                              odp_crypto_auth_capability_t capa[], int num)
;</td><td> </td><td class="right">                              odp_crypto_auth_capability_t capa[], int num)
;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Crypto session creation</td><td> </td><td class="right"> * Crypto session creation</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Create a crypto session according to the session parameters. Use</td><td> </td><td class="right"> * Create a crypto session according to the session parameters. Use</td></tr>
      <tr><td class="left"> * odp_crypto_session_param_init() to initialize parameters into their</td><td> </td><td class="right"> * odp_crypto_session_param_init() to initialize parameters into their</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * default values.</td><td> </td><td class="rblock"> * default values. <span class="insert">If call ends up with an error no new session will be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * created.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock"> * @param param             Session parameters</td><td> </td><td class="rblock"> * @param      param        Session parameters</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param</span> session           Created session else ODP_CRYPTO_SESSION_INVALID</td><td> </td><td class="rblock"> * <span class="insert">@param[out]</span> session      Created session else ODP_CRYPTO_SESSION_INVALID</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param</span> status            Failure code if unsuccessful</td><td> </td><td class="rblock"> * <span class="insert">@param[out]</span> status       Failure code if unsuccessful</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_crypto_session_create(odp_crypto_session_param_t *param,</td><td> </td><td class="right">int odp_crypto_session_create(odp_crypto_session_param_t *param,</td></tr>
      <tr><td class="left">                             odp_crypto_session_t *session,</td><td> </td><td class="right">                             odp_crypto_session_t *session,</td></tr>
      <tr><td class="left">                             odp_crypto_ses_create_err_t *status);</td><td> </td><td class="right">                             odp_crypto_ses_create_err_t *status);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Crypto session destroy</td><td> </td><td class="right"> * Crypto session destroy</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l11" /><small>skipping to change at</small><em> line 704</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 792</em></th></tr>
      <tr><td class="left"> * Initialize crypto session parameters</td><td> </td><td class="right"> * Initialize crypto session parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Initialize an odp_crypto_session_param_t to its default values for</td><td> </td><td class="right"> * Initialize an odp_crypto_session_param_t to its default values for</td></tr>
      <tr><td class="left"> * all fields.</td><td> </td><td class="right"> * all fields.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param param   Pointer to odp_crypto_session_param_t to be initialized</td><td> </td><td class="right"> * @param param   Pointer to odp_crypto_session_param_t to be initialized</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_crypto_session_param_init(odp_crypto_session_param_t *param);</td><td> </td><td class="right">void odp_crypto_session_param_init(odp_crypto_session_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Return crypto processed packet that is associated with event</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Get packet handle to an crypto processed packet event. Event subtype mus</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_EVENT_PACKET_CRYPTO. Crypto operation results can be examined with</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_crypto_result().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note: any invalid parameters will cause undefined behavior and may cause</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the application to abort or crash.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param ev       Event handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_t odp_crypto_packet_from_event(odp_event_t ev);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Convert crypto packet handle to event</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The packet handle must be an output of an crypto operation.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt      Packet handle from crypto operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Event handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_event_t odp_crypto_packet_to_event(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Get crypto operation results from an crypto processed packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Successful crypto operations of all types (SYNC and ASYNC) produce packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * which contain crypto result metadata. This function copies the operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * results from an crypto processed packet. Event subtype of this kind of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet is ODP_EVENT_PACKET_CRYPTO. Results are undefined if a non-crypto</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * processed packet is passed as input.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param         packet  An crypto processed packet (ODP_EVENT_PACKET_CRYP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">TO)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out]    result  Pointer to operation result for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval  0     On success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0     On failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_crypto_result(odp_crypto_packet_result_t *result,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                     odp_packet_t packet);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Crypto packet operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Performs the SYNC cryptographic operations specified during session crea</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * on the packets. Caller should initialize pkt_out either with desired out</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">put</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet handles or with ODP_PACKET_INVALID to make ODP allocate new packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * from provided pool. All arrays should be of num_pkt size.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param         pkt_in   Packets to be processed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in,out] pkt_out  Packet handle array specifyint resulting packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param         param    Operation parameters array</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param         num_pkt  Number of packets to be processed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of input packets consumed (0 ... num_pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_crypto_op(const odp_packet_t pkt_in[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                 odp_packet_t pkt_out[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                 const odp_crypto_packet_op_param_t param[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                 int num_pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Crypto packet operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Performs the ASYNC cryptographic operations specified during session cre</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * on the packets. Caller should initialize pkt_out either with desired out</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">put</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet handles or with ODP_PACKET_INVALID to make ODP allocate new packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * from provided pool. All arrays should be of num_pkt size. Resulting pack</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * are returned through events.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt_in   Packets to be processed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt_out  Packet handle array specifying resulting packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param param    Operation parameters array</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param num_pkt  Number of packets to be processed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of input packets consumed (0 ... num_pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_crypto_op_enq(const odp_packet_t pkt_in[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                     const odp_packet_t pkt_out[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                     const odp_crypto_packet_op_param_t param[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                     int num_pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_end.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 22 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>24 lines changed or deleted</i></th><th><i> </i></th><th><i>216 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;event.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;event.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_EVENT_H_</td><td> </td><td class="right">#ifndef ODP_API_EVENT_H_</td></tr>
      <tr><td class="left">#define ODP_API_EVENT_H_</td><td> </td><td class="right">#define ODP_API_EVENT_H_</td></tr>
      <tr><td class="left">#include &lt;odp/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/packet.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** @defgroup odp_event ODP EVENT</td><td> </td><td class="right">/** @defgroup odp_event ODP EVENT</td></tr>
      <tr><td class="left"> *  Operations on an event.</td><td> </td><td class="right"> *  Operations on an event.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_event_t</td><td> </td><td class="right"> * @typedef odp_event_t</td></tr>
      <tr><td class="left"> * ODP event</td><td> </td><td class="right"> * ODP event</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_EVENT_INVALID</td><td> </td><td class="right"> * @def ODP_EVENT_INVALID</td></tr>
      <tr><td class="left"> * Invalid event</td><td> </td><td class="right"> * Invalid event</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_event_type_t</td><td> </td><td class="right"> * @typedef odp_event_type_t</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">ODP</span> event types:</td><td> </td><td class="rblock"> * <span class="insert">Event type</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">ODP_EVENT_BUFFER, ODP_EVENT_PACKET, ODP_EVENT_TIMEOUT,</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"> * ODP_EVENT_CRYPTO_COMPL</td><td> </td><td class="rblock"><span class="insert"> * Event type specifies purpose and general format of an event. It can be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * checked with odp_event_type() or odp_event_types(). Each event type has</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * functions (e.g. odp_buffer_from_event()) to convert between the generic </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">event</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle (odp_event_t) and the type specific handle (e.g. odp_buffer_t).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Results are undefined, if conversion function of a wrong event type is u</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Application cannot change event type by chaining conversion functions.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * List of</span> event types:</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">- ODP_EVENT_BUFFER</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *     <span class="insert">- Buffer event (odp_buffer_t) for simple data storage and message pa</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ssing</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_PACKET</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - Packet event (odp_packet_t) containing packet data and plenty of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *       packet processing related metadata</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_TIMEOUT</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - Timeout event (odp_timeout_t) from a timer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * -</span> ODP_EVENT_CRYPTO_COMPL</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*     - Crypto completion event (odp_crypto_compl_t)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_IPSEC_STATUS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - IPSEC status update event (odp_ipsec_status_t)</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Get event type</span></td><td> </td><td class="rblock"> * <span class="insert">@typedef odp_event_subtype_t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Event subtype</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * @param event    Event handle</td><td> </td><td class="rblock"> * <span class="insert">Event subtype expands event type specification by providing more detaile</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * purpose and format of an event. It can be checked with odp_event_subtype</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">() or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_event_types(). Each event subtype may define specific functions</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (e.g. odp_ipsec_packet_from_event()) to convert between the generic even</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle (odp_event_t) and event type specific handle (e.g. odp_packet_t).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> When</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * subtype is known, these subtype specific functions should be preferred o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ver</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the event type general function (e.g. odp_packet_from_event()). Results </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * undefined, if conversion function of a wrong event subtype is used.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Application cannot change event subtype by chaining conversion functions</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *  List of event subtypes:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_PACKET_BASIC</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - Packet event (odp_packet_t) with basic packet metadata</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_PACKET_CRYPTO</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - Packet event (odp_packet_t) generated as a result of a Crypto</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *       operation. It contains crypto specific metadata in addition to the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *       basic packet metadata.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_PACKET_IPSEC</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - Packet event (odp_packet_t) generated as a result of an IPsec</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *       operation. It contains IPSEC specific metadata in addition to the </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">basic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *       packet metadata.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * - ODP_EVENT_NO_SUBTYPE</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     - An event type does not have any subtypes defined</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Event type of an event</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Event type specifies purpose and general format of an event.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @param      event    Event handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Event type</td><td> </td><td class="right"> * @return Event type</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_event_type_t odp_event_type(odp_event_t event);</td><td> </td><td class="right">odp_event_type_t odp_event_type(odp_event_t event);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Event subtype of an event</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Event subtype expands event type specification by providing more detaile</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * purpose and format of an event.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      event    Event handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Event subtype</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_event_subtype_t odp_event_subtype(odp_event_t event);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Event type and subtype of an event</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns event type and outputs event subtype.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      event    Event handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] subtype  Pointer to event subtype for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Event type</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_event_type_t odp_event_types(odp_event_t event,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                odp_event_subtype_t *subtype);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Event type of multiple events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the number of first events in the array which have the same even</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * type. Outputs the event type of those events.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      event    Array of event handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num      Number of events (&gt; 0)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] type     Event type pointer for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of first events (1 ... num) with the same event type</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *         (includes event[0])</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_event_type_multi(const odp_event_t event[], int num,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                        odp_event_type_t *type);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Filter and convert packet events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Checks event type of all input events, converts all packet events and ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet handles. Returns the number packet handles outputted. Outputs the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * remaining, non-packet event handles to 'remain' array. Handles are outpu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tted</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to both arrays in the same order those are stored in 'event' array. Both</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * output arrays must fit 'num' elements.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      event    Array of event handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] packet   Packet handle array for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] remain   Event handle array for output of remaining, non-pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ket</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num      Number of events (&gt; 0)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of packets outputted (0 ... num)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_event_filter_packet(const odp_event_t event[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           odp_packet_t packet[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           odp_event_t remain[], int num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Get printable value for an odp_event_t</td><td> </td><td class="right"> * Get printable value for an odp_event_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param hdl  odp_event_t handle to be printed</td><td> </td><td class="right"> * @param hdl  odp_event_t handle to be printed</td></tr>
      <tr><td class="left"> * @return     uint64_t value that can be used to print/display this</td><td> </td><td class="right"> * @return     uint64_t value that can be used to print/display this</td></tr>
      <tr><td class="left"> *             handle</td><td> </td><td class="right"> *             handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note This routine is intended to be used for diagnostic purposes</td><td> </td><td class="right"> * @note This routine is intended to be used for diagnostic purposes</td></tr>
      <tr><td class="left"> * to enable applications to generate a printable value that represents</td><td> </td><td class="right"> * to enable applications to generate a printable value that represents</td></tr>
      <tr><td class="left"> * an odp_event_t handle.</td><td> </td><td class="right"> * an odp_event_t handle.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 77</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 190</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Frees the event based on its type. Results are undefined if event</td><td> </td><td class="right"> * Frees the event based on its type. Results are undefined if event</td></tr>
      <tr><td class="left"> * type is unknown.</td><td> </td><td class="right"> * type is unknown.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param event    Event handle</td><td> </td><td class="right"> * @param event    Event handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_event_free(odp_event_t event);</td><td> </td><td class="right">void odp_event_free(odp_event_t event);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Free multiple events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Otherwise like odp_event_free(), but frees multiple events to their</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * originating pools.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param event    Array of event handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param num      Number of events to free</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_event_free_multi(const odp_event_t event[], int num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Free multiple events to the same pool</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Otherwise like odp_event_free_multi(), but all events must be from the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * same originating pool.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param event    Array of event handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param num      Number of events to free</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_event_free_sp(const odp_event_t event[], int num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_end.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 6 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>5 lines changed or deleted</i></th><th><i> </i></th><th><i>156 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;packet.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 74</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 74</em></th></tr>
      <tr><td class="left">  * @def ODP_PACKET_YELLOW</td><td> </td><td class="right">  * @def ODP_PACKET_YELLOW</td></tr>
      <tr><td class="left">  * Packet is yellow</td><td> </td><td class="right">  * Packet is yellow</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"> /**</td><td> </td><td class="right"> /**</td></tr>
      <tr><td class="left">  * @def ODP_PACKET_RED</td><td> </td><td class="right">  * @def ODP_PACKET_RED</td></tr>
      <tr><td class="left">  * Packet is red</td><td> </td><td class="right">  * Packet is red</td></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Protocol</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum odp_proto_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** No protocol defined */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_NONE = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Ethernet (including VLAN) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_ETH,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** IP version 4 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_IPV4,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** IP version 6 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_IPV6</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_proto_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Protocol layer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum odp_proto_layer_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** No layers */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_LAYER_NONE = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Layer L2 protocols (Ethernet, VLAN, etc) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_LAYER_L2,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Layer L3 protocols (IPv4, IPv6, ICMP, IPSEC, etc) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_LAYER_L3,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Layer L4 protocols (UDP, TCP, SCTP) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_LAYER_L4,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All layers */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PROTO_LAYER_ALL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_proto_layer_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Packet API data range specifier</td><td> </td><td class="right"> * Packet API data range specifier</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_packet_data_range {</td><td> </td><td class="right">typedef struct odp_packet_data_range {</td></tr>
      <tr><td class="left">       /** Offset from beginning of packet */</td><td> </td><td class="right">       /** Offset from beginning of packet */</td></tr>
      <tr><td class="left">       uint32_t offset;</td><td> </td><td class="right">       uint32_t offset;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Length of data to operate on */</td><td> </td><td class="right">       /** Length of data to operate on */</td></tr>
      <tr><td class="left">       uint32_t length;</td><td> </td><td class="right">       uint32_t length;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_packet_data_range_t;</td><td> </td><td class="right">} odp_packet_data_range_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Checksum check status in packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum odp_packet_chksum_status_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Checksum was not checked. Checksum check was not attempted or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * the attempt failed. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PACKET_CHKSUM_UNKNOWN = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Checksum was checked and it was not correct */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PACKET_CHKSUM_BAD,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Checksum was checked and it was correct */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_PACKET_CHKSUM_OK</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_packet_chksum_status_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Alloc and free</td><td> </td><td class="right"> * Alloc and free</td></tr>
      <tr><td class="left"> * ********************************************************</td><td> </td><td class="right"> * ********************************************************</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Allocate a packet from a packet pool</td><td> </td><td class="right"> * Allocate a packet from a packet pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 152</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 207</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Otherwise like odp_packet_free(), but frees multiple packets</td><td> </td><td class="right"> * Otherwise like odp_packet_free(), but frees multiple packets</td></tr>
      <tr><td class="left"> * to their originating pools.</td><td> </td><td class="right"> * to their originating pools.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt           Array of packet handles</td><td> </td><td class="right"> * @param pkt           Array of packet handles</td></tr>
      <tr><td class="left"> * @param num           Number of packet handles to free</td><td> </td><td class="right"> * @param num           Number of packet handles to free</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_packet_free_multi(const odp_packet_t pkt[], int num);</td><td> </td><td class="right">void odp_packet_free_multi(const odp_packet_t pkt[], int num);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Free multiple packets to the same pool</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Otherwise like odp_packet_free_multi(), but all packets must be from the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * same originating pool.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt           Array of packet handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param num           Number of packets to free</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_free_sp(const odp_packet_t pkt[], int num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Reset packet</td><td> </td><td class="right"> * Reset packet</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Resets all packet metadata to their default values. Packet length is use
d</td><td> </td><td class="right"> * Resets all packet metadata to their default values. Packet length is use
d</td></tr>
      <tr><td class="left"> * to initialize pointers and lengths. It must be less than the total buffe
r</td><td> </td><td class="right"> * to initialize pointers and lengths. It must be less than the total buffe
r</td></tr>
      <tr><td class="left"> * length of the packet minus the default headroom length. Packet is not</td><td> </td><td class="right"> * length of the packet minus the default headroom length. Packet is not</td></tr>
      <tr><td class="left"> * modified on failure.</td><td> </td><td class="right"> * modified on failure.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt           Packet handle</td><td> </td><td class="right"> * @param pkt           Packet handle</td></tr>
      <tr><td class="left"> * @param len           Packet data length</td><td> </td><td class="right"> * @param len           Packet data length</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 183</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 249</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param ev   Event handle</td><td> </td><td class="right"> * @param ev   Event handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Packet handle</td><td> </td><td class="right"> * @return Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_event_type()</td><td> </td><td class="right"> * @see odp_event_type()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_packet_t odp_packet_from_event(odp_event_t ev);</td><td> </td><td class="right">odp_packet_t odp_packet_from_event(odp_event_t ev);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Convert multiple packet events to packet handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * All events must be of type ODP_EVENT_PACKET.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] pkt  Packet handle array for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      ev   Array of event handles to convert</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num  Number of packets and events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_from_event_multi(odp_packet_t pkt[], const odp_event_t ev[]</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                int num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Convert packet handle to event</td><td> </td><td class="right"> * Convert packet handle to event</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Event handle</td><td> </td><td class="right"> * @return Event handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_event_t odp_packet_to_event(odp_packet_t pkt);</td><td> </td><td class="right">odp_event_t odp_packet_to_event(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Convert multiple packet handles to events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pkt  Array of packet handles to convert</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] ev   Event handle array for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num  Number of packets and events</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_to_event_multi(const odp_packet_t pkt[], odp_event_t ev[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                              int num);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Pointers and lengths</td><td> </td><td class="right"> * Pointers and lengths</td></tr>
      <tr><td class="left"> * ********************************************************</td><td> </td><td class="right"> * ********************************************************</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet head address</td><td> </td><td class="right"> * Packet head address</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 1126</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 1214</em></th></tr>
      <tr><td class="left">                        uint32_t src_offset, uint32_t len);</td><td> </td><td class="right">                        uint32_t src_offset, uint32_t len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Meta-data</td><td> </td><td class="right"> * Meta-data</td></tr>
      <tr><td class="left"> * ********************************************************</td><td> </td><td class="right"> * ********************************************************</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Flags to control packet data checksum checking</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef union odp_proto_chksums_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Individual checksum bits. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** IPv4 header checksum */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t ipv4   : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** UDP checksum */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t udp    : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** TCP checksum */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t tcp    : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** SCTP checksum */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t sctp   : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } chksum;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All checksum bits. This can be used to set/clear all flags. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t all_chksum;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_proto_chksums_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet parse parameters</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_packet_parse_param_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Protocol header at parse starting point. Valid values for this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  field are: ODP_PROTO_ETH, ODP_PROTO_IPV4, ODP_PROTO_IPV6. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_proto_t proto;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Continue parsing until this layer. Must be the same or higher</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  layer than the layer of 'proto'. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_proto_layer_t last_layer;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Flags to control payload data checksums checks up to the selecte</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  parse layer. Checksum checking status can be queried for each pa</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cket</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  with odp_packet_l3_chksum_status() and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  odp_packet_l4_chksum_status().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_proto_chksums_t chksums;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_packet_parse_param_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Parse packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Parse protocol headers in packet data and update layer/protocol specific</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * metadata (e.g. offsets, errors, protocols, checksum statuses, etc). Pars</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ing</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * starts at 'offset', which is the first header byte of protocol 'param.pr</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">oto'.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Parameter 'param.last_layer' defines the last layer application requests</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to check. Use ODP_PROTO_LAYER_ALL for all layers. A successful operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * sets (or resets) packet metadata for all layers from the layer of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * 'param.proto' to the application defined last layer. In addition, offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (and pointer) to the next layer is set. Other layer/protocol specific</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * metadata have undefined values. When operation fails, all layer/protocol</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * specific metadata have undefined values.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt     Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset  Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param param   Parse parameters. Proto and last_layer fields must be set</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                Clear all check bits that are not used.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_parse(odp_packet_t pkt, uint32_t offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                    const odp_packet_parse_param_t *param);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Parse multiple packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Otherwise like odp_packet_parse(), but parses multiple packets. Packets </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">may</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * have unique offsets, but must start with the same protocol. The same</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * parse parameters are applied to all packets.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt     Packet handle array</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset  Byte offsets into the packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param num     Number of packets and offsets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param param   Parse parameters. Proto and last_layer fields must be set</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                Clear all check bits that are not used.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of packets parsed successfully (0 ... num)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_parse_multi(const odp_packet_t pkt[], const uint32_t offset[</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          int num, const odp_packet_parse_param_t *param);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Packet pool</td><td> </td><td class="right"> * Packet pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Returns handle to the packet pool where the packet was allocated from.</td><td> </td><td class="right"> * Returns handle to the packet pool where the packet was allocated from.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt   Packet handle</td><td> </td><td class="right"> * @param pkt   Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Packet pool handle</td><td> </td><td class="right"> * @return Packet pool handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pool_t odp_packet_pool(odp_packet_t pkt);</td><td> </td><td class="right">odp_pool_t odp_packet_pool(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 1213</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 1391</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return  User area size in bytes</td><td> </td><td class="right"> * @return  User area size in bytes</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint32_t odp_packet_user_area_size(odp_packet_t pkt);</td><td> </td><td class="right">uint32_t odp_packet_user_area_size(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Layer 2 start pointer</td><td> </td><td class="right"> * Layer 2 start pointer</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"> * Returns pointer to the start of <span class="delete">the</span> layer <span class="delete">2 header.</span> Optionally, outputs</td><td> </td><td class="rblock"> * Returns pointer to the start of layer <span class="insert">2.</span> Optionally, outputs number of <span class="insert">d</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> number of <span class="delete">data</span> bytes in the segment following the pointer.</td><td> </td><td class="rblock"><span class="insert">ata</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> bytes in the segment following the pointer. <span class="insert">The pointer value is generat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * from the current layer 2 offset.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pkt      Packet handle</td><td> </td><td class="right"> * @param      pkt      Packet handle</td></tr>
      <tr><td class="left"> * @param[out] len      Number of data bytes remaining in the segment (outp
ut).</td><td> </td><td class="right"> * @param[out] len      Number of data bytes remaining in the segment (outp
ut).</td></tr>
      <tr><td class="left"> *                      Ignored when NULL.</td><td> </td><td class="right"> *                      Ignored when NULL.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * @return  Layer 2 start pointer</td><td> </td><td class="rblock"> * @return Layer 2 start pointer</td></tr>
      <tr><td class="lblock"> * @retval  NULL <span class="delete">packet does</span> not <span class="delete">contain a valid L2 header</span></td><td> </td><td class="rblock"> * @retval NULL  <span class="insert">Layer 2 offset has</span> not <span class="insert">been set</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_l2_offset(), odp_packet_l2_offset_set(), odp_packet_has_
l2()</td><td> </td><td class="right"> * @see odp_packet_l2_offset(), odp_packet_l2_offset_set(), odp_packet_has_
l2()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_packet_l2_ptr(odp_packet_t pkt, uint32_t *len);</td><td> </td><td class="right">void *odp_packet_l2_ptr(odp_packet_t pkt, uint32_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Layer 2 start offset</td><td> </td><td class="right"> * Layer 2 start offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"> * Returns offset to the start of <span class="delete">the</span> layer <span class="delete">2 header.</span> The offset is <span class="delete">calcula</span></td><td> </td><td class="rblock"> * Returns offset to the start of layer <span class="insert">2.</span> The offset is <span class="insert">calculated</span> from <span class="insert">th</span></td></tr>
      <tr><td class="lblock"><span class="delete">ted</span></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> from <span class="delete">the</span> current odp_packet_data() position in bytes.</td><td> </td><td class="rblock"><span class="insert"> *</span> current odp_packet_data() position in bytes. <span class="insert">Packet parsing sets the off</span></td></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"><span class="insert">set</span></td></tr>
      <tr><td class="lblock"> <span class="delete">* User is responsible</span> to <span class="delete">update the offset when modifying</span> the <span class="delete">packet data</span></td><td> </td><td class="rblock"> * <span class="insert">according</span> to <span class="insert">parse configuration and layers recognized in</span> the <span class="insert">packet. Da</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">pointer position.</span></td><td> </td><td class="rblock"><span class="insert">ta</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">start position updating functions (e.g. odp_packet_push_head()) do not m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odify</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the offset, but user sets a new value when needed.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"> * @return  Layer 2 start offset</td><td> </td><td class="rblock"> * @return Layer 2 start offset</td></tr>
      <tr><td class="lblock"> * @retval ODP_PACKET_OFFSET_INVALID <span class="delete">packet does</span> not <span class="delete">contain a valid L2 hea</span></td><td> </td><td class="rblock"> * @retval ODP_PACKET_OFFSET_INVALID  <span class="insert">Layer 2 offset has</span> not <span class="insert">been set</span></td></tr>
      <tr><td class="lblock"><span class="delete">der</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_l2_offset_set(), odp_packet_has_l2()</td><td> </td><td class="right"> * @see odp_packet_l2_offset_set(), odp_packet_has_l2()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint32_t odp_packet_l2_offset(odp_packet_t pkt);</td><td> </td><td class="right">uint32_t odp_packet_l2_offset(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set layer 2 start offset</td><td> </td><td class="right"> * Set layer 2 start offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock"> * Set offset to the start of <span class="delete">the</span> layer <span class="delete">2 header.</span> The offset is calculated </td><td> </td><td class="rblock"> * Set offset to the start of layer <span class="insert">2.</span> The offset is calculated from the <span class="insert">cu</span></td></tr>
      <tr><td class="lblock">from</td><td> </td><td class="rblock"><span class="insert">rrent</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> the <span class="delete">current</span> odp_packet_data() position in bytes. Offset must not exceed</td><td> </td><td class="rblock"><span class="insert"> *</span> odp_packet_data() position in bytes. Offset must not exceed packet data</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> packet data length. <span class="delete">Packet</span> is not modified on an error.</td><td> </td><td class="rblock"> <span class="insert">*</span> length. <span class="insert">Offset</span> is not modified on an error.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt     Packet handle</td><td> </td><td class="right"> * @param pkt     Packet handle</td></tr>
      <tr><td class="left"> * @param offset  Layer 2 start offset (0 ... odp_packet_len()-1)</td><td> </td><td class="right"> * @param offset  Layer 2 start offset (0 ... odp_packet_len()-1)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_l2_offset_set(odp_packet_t pkt, uint32_t offset);</td><td> </td><td class="right">int odp_packet_l2_offset_set(odp_packet_t pkt, uint32_t offset);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Layer 3 start pointer</td><td> </td><td class="right"> * Layer 3 start pointer</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock"> * Returns pointer to the start of <span class="delete">the</span> layer <span class="delete">3 header.</span> Optionally, outputs</td><td> </td><td class="rblock"> * Returns pointer to the start of layer <span class="insert">3.</span> Optionally, outputs number of <span class="insert">d</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> number of <span class="delete">data</span> bytes in the segment following the pointer.</td><td> </td><td class="rblock"><span class="insert">ata</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> bytes in the segment following the pointer. <span class="insert">The pointer value is generat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * from the current layer 3 offset.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pkt      Packet handle</td><td> </td><td class="right"> * @param      pkt      Packet handle</td></tr>
      <tr><td class="left"> * @param[out] len      Number of data bytes remaining in the segment (outp
ut).</td><td> </td><td class="right"> * @param[out] len      Number of data bytes remaining in the segment (outp
ut).</td></tr>
      <tr><td class="left"> *                      Ignored when NULL.</td><td> </td><td class="right"> *                      Ignored when NULL.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"> * @return  Layer 3 start pointer</td><td> </td><td class="rblock"> * @return Layer 3 start pointer</td></tr>
      <tr><td class="lblock"> * @retval NULL <span class="delete">packet does</span> not <span class="delete">contain a valid L3 header</span></td><td> </td><td class="rblock"> * @retval NULL  <span class="insert">Layer 3 offset has</span> not <span class="insert">been set</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_l3_offset(), odp_packet_l3_offset_set(), odp_packet_has_
l3()</td><td> </td><td class="right"> * @see odp_packet_l3_offset(), odp_packet_l3_offset_set(), odp_packet_has_
l3()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_packet_l3_ptr(odp_packet_t pkt, uint32_t *len);</td><td> </td><td class="right">void *odp_packet_l3_ptr(odp_packet_t pkt, uint32_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Layer 3 start offset</td><td> </td><td class="right"> * Layer 3 start offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock"> * Returns offset to the start of <span class="delete">the</span> layer <span class="delete">3 header.</span> The offset is <span class="delete">calcula</span></td><td> </td><td class="rblock"> * Returns offset to the start of layer <span class="insert">3.</span> The offset is <span class="insert">calculated</span> from <span class="insert">th</span></td></tr>
      <tr><td class="lblock"><span class="delete">ted</span></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> from <span class="delete">the</span> current odp_packet_data() position in bytes.</td><td> </td><td class="rblock"><span class="insert"> *</span> current odp_packet_data() position in bytes. <span class="insert">Packet parsing sets the off</span></td></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"><span class="insert">set</span></td></tr>
      <tr><td class="lblock"> <span class="delete">* User is responsible</span> to <span class="delete">update the offset when modifying</span> the <span class="delete">packet data</span></td><td> </td><td class="rblock"> * <span class="insert">according</span> to <span class="insert">parse configuration and layers recognized in</span> the <span class="insert">packet. Da</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">pointer position.</span></td><td> </td><td class="rblock"><span class="insert">ta</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">start position updating functions (e.g. odp_packet_push_head()) do not m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odify</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the offset, but user sets a new value when needed.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"> * @return  Layer 3 start <span class="delete">offset, or ODP_PACKET_OFFSET_INVALID when packet </span></td><td> </td><td class="rblock"> * @return Layer 3 start <span class="insert">offset</span></td></tr>
      <tr><td class="lblock"><span class="delete">does</span></td><td> </td><td class="rblock"> * <span class="insert">@retval ODP_PACKET_OFFSET_INVALID  Layer 3 offset has</span> not <span class="insert">been set</span></td></tr>
      <tr><td class="lblock"> *          not <span class="delete">contain a valid L3 header.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_l3_offset_set(), odp_packet_has_l3()</td><td> </td><td class="right"> * @see odp_packet_l3_offset_set(), odp_packet_has_l3()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint32_t odp_packet_l3_offset(odp_packet_t pkt);</td><td> </td><td class="right">uint32_t odp_packet_l3_offset(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set layer 3 start offset</td><td> </td><td class="right"> * Set layer 3 start offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"> * Set offset to the start of <span class="delete">the</span> layer <span class="delete">3 header.</span> The offset is calculated </td><td> </td><td class="rblock"> * Set offset to the start of layer <span class="insert">3.</span> The offset is calculated from the <span class="insert">cu</span></td></tr>
      <tr><td class="lblock">from</td><td> </td><td class="rblock"><span class="insert">rrent</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> the <span class="delete">current</span> odp_packet_data() position in bytes. Offset must not exceed</td><td> </td><td class="rblock"><span class="insert"> *</span> odp_packet_data() position in bytes. Offset must not exceed packet data</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> packet data length. <span class="delete">Packet</span> is not modified on an error.</td><td> </td><td class="rblock"> <span class="insert">*</span> length. <span class="insert">Offset</span> is not modified on an error.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt     Packet handle</td><td> </td><td class="right"> * @param pkt     Packet handle</td></tr>
      <tr><td class="left"> * @param offset  Layer 3 start offset (0 ... odp_packet_len()-1)</td><td> </td><td class="right"> * @param offset  Layer 3 start offset (0 ... odp_packet_len()-1)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_l3_offset_set(odp_packet_t pkt, uint32_t offset);</td><td> </td><td class="right">int odp_packet_l3_offset_set(odp_packet_t pkt, uint32_t offset);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Layer 4 start pointer</td><td> </td><td class="right"> * Layer 4 start pointer</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock"> * Returns pointer to the start of <span class="delete">the</span> layer <span class="delete">4 header.</span> Optionally, outputs</td><td> </td><td class="rblock"> * Returns pointer to the start of layer <span class="insert">4.</span> Optionally, outputs number of <span class="insert">d</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> number of <span class="delete">data</span> bytes in the segment following the pointer.</td><td> </td><td class="rblock"><span class="insert">ata</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> bytes in the segment following the pointer. <span class="insert">The pointer value is generat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * from the current layer 4 offset.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pkt      Packet handle</td><td> </td><td class="right"> * @param      pkt      Packet handle</td></tr>
      <tr><td class="left"> * @param[out] len      Number of data bytes remaining in the segment (outp
ut).</td><td> </td><td class="right"> * @param[out] len      Number of data bytes remaining in the segment (outp
ut).</td></tr>
      <tr><td class="left"> *                      Ignored when NULL.</td><td> </td><td class="right"> *                      Ignored when NULL.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"> * @return  Layer 4 start pointer</td><td> </td><td class="rblock"> * @return Layer 4 start pointer</td></tr>
      <tr><td class="lblock"> * @retval NULL <span class="delete">packet does</span> not <span class="delete">contain a valid L4 header</span></td><td> </td><td class="rblock"> * @retval NULL  <span class="insert">Layer 4 offset has</span> not <span class="insert">been set</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_l4_offset(), odp_packet_l4_offset_set(), odp_packet_has_
l4()</td><td> </td><td class="right"> * @see odp_packet_l4_offset(), odp_packet_l4_offset_set(), odp_packet_has_
l4()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_packet_l4_ptr(odp_packet_t pkt, uint32_t *len);</td><td> </td><td class="right">void *odp_packet_l4_ptr(odp_packet_t pkt, uint32_t *len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Layer 4 start offset</td><td> </td><td class="right"> * Layer 4 start offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"> * Returns offset to the start of <span class="delete">the</span> layer <span class="delete">4 header.</span> The offset is <span class="delete">calcula</span></td><td> </td><td class="rblock"> * Returns offset to the start of layer <span class="insert">4.</span> The offset is <span class="insert">calculated</span> from <span class="insert">th</span></td></tr>
      <tr><td class="lblock"><span class="delete">ted</span></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> from <span class="delete">the</span> current odp_packet_data() position in bytes.</td><td> </td><td class="rblock"><span class="insert"> *</span> current odp_packet_data() position in bytes. <span class="insert">Packet parsing sets the off</span></td></tr>
      <tr><td class="lblock"> *</td><td> </td><td class="rblock"><span class="insert">set</span></td></tr>
      <tr><td class="lblock"> <span class="delete">* User is responsible</span> to <span class="delete">update the offset when modifying</span> the <span class="delete">packet data</span></td><td> </td><td class="rblock"> * <span class="insert">according</span> to <span class="insert">parse configuration and layers recognized in</span> the <span class="insert">packet. Da</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">pointer position.</span></td><td> </td><td class="rblock"><span class="insert">ta</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">start position updating functions (e.g. odp_packet_push_head()) do not m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odify</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the offset, but user sets a new value when needed.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * @return  Layer 4 start offset</td><td> </td><td class="rblock"> * @return Layer 4 start offset</td></tr>
      <tr><td class="lblock"> * @retval ODP_PACKET_OFFSET_INVALID <span class="delete">packet does</span> not <span class="delete">contain a valid L4 hea</span></td><td> </td><td class="rblock"> * @retval ODP_PACKET_OFFSET_INVALID  <span class="insert">Layer 4 offset has</span> not <span class="insert">been set</span></td></tr>
      <tr><td class="lblock"><span class="delete">der</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_l4_offset_set(), odp_packet_has_l4()</td><td> </td><td class="right"> * @see odp_packet_l4_offset_set(), odp_packet_has_l4()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint32_t odp_packet_l4_offset(odp_packet_t pkt);</td><td> </td><td class="right">uint32_t odp_packet_l4_offset(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set layer 4 start offset</td><td> </td><td class="right"> * Set layer 4 start offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock"> * Set offset to the start of <span class="delete">the</span> layer <span class="delete">4 header.</span> The offset is calculated </td><td> </td><td class="rblock"> * Set offset to the start of layer <span class="insert">4.</span> The offset is calculated from the <span class="insert">cu</span></td></tr>
      <tr><td class="lblock">from</td><td> </td><td class="rblock"><span class="insert">rrent</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> the <span class="delete">current</span> odp_packet_data() position in bytes. Offset must not exceed</td><td> </td><td class="rblock"><span class="insert"> *</span> odp_packet_data() position in bytes. Offset must not exceed packet data</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> packet data length. <span class="delete">Packet</span> is not modified on an error.</td><td> </td><td class="rblock"> <span class="insert">*</span> length. <span class="insert">Offset</span> is not modified on an error.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt     Packet handle</td><td> </td><td class="right"> * @param pkt     Packet handle</td></tr>
      <tr><td class="left"> * @param offset  Layer 4 start offset (0 ... odp_packet_len()-1)</td><td> </td><td class="right"> * @param offset  Layer 4 start offset (0 ... odp_packet_len()-1)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_l4_offset_set(odp_packet_t pkt, uint32_t offset);</td><td> </td><td class="right">int odp_packet_l4_offset_set(odp_packet_t pkt, uint32_t offset);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Layer 3 checksum check status</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the result of the latest layer 3 checksum check done for the pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The status tells if checksum check was attempted and the result of the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * attempt. It depends on packet input (or IPSEC) configuration, packet con</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tent</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and implementation capabilities if checksum check is attempted for a pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt     Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return L3 checksum check status</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_chksum_status_t odp_packet_l3_chksum_status(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Layer 4 checksum check status</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the result of the latest layer 4 checksum check done for the pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The status tells if checksum check was attempted and the result of the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * attempt. It depends on packet input (or IPSEC) configuration, packet con</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tent</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and implementation capabilities if checksum check is attempted for a pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt     Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return L4 checksum check status</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_chksum_status_t odp_packet_l4_chksum_status(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Layer 3 checksum insertion override</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Override checksum insertion configuration per packet. This per packet se</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tting</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * overrides a higher level configuration for checksum insertion into a L3</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * header during packet output processing.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Calling this function is always allowed but the checksum will not be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * inserted if the packet is output through a pktio that does not have</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the relevant checksum insertion enabled.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt     Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param insert  0: do not insert L3 checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                1: insert L3 checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_l3_chksum_insert(odp_packet_t pkt, int insert);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Layer 4 checksum insertion override</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Override checksum insertion configuration per packet. This per packet se</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tting</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * overrides a higher level configuration for checksum insertion into a L4</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * header during packet output processing.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Calling this function is always allowed but the checksum will not be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * inserted if the packet is output through a pktio that does not have</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the relevant checksum insertion enabled.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt     Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param insert  0: do not insert L4 checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                1: insert L4 checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_l4_chksum_insert(odp_packet_t pkt, int insert);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Ones' complement sum of packet data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns 16-bit ones' complement sum that was calculated over a portion o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">f</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet data during a packet processing operation (e.g. packet input or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * IPSEC offload). The data range is output with 'range' parameter, and usu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ally</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * includes IP payload (L4 headers and payload). When 'range.length' is zer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the sum has not been calculated. In case of odd number of bytes,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * calculation uses a zero byte as padding at the end. The sum may be used </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * part of e.g. UDP/TCP checksum checking, especially with IP fragments.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pkt    Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] range  Data range of the sum (output). The calculation start</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                    from range.offset and included range.length bytes. Wh</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">en</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                    range.length is zero, the sum has not been calculated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Ones' complement sum over the data range</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint16_t odp_packet_ones_comp(odp_packet_t pkt, odp_packet_data_range_t *ra</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nge);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Packet flow hash value</td><td> </td><td class="right"> * Packet flow hash value</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Returns the hash generated from the packet header. Use</td><td> </td><td class="right"> * Returns the hash generated from the packet header. Use</td></tr>
      <tr><td class="left"> * odp_packet_has_flow_hash() to check if packet contains a hash.</td><td> </td><td class="right"> * odp_packet_has_flow_hash() to check if packet contains a hash.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pkt      Packet handle</td><td> </td><td class="right"> * @param      pkt      Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return  Hash value</td><td> </td><td class="right"> * @return  Hash value</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Zero can be a valid hash value.</td><td> </td><td class="right"> * @note Zero can be a valid hash value.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 22 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>51 lines changed or deleted</i></th><th><i> </i></th><th><i>351 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_flags.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_flags.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 25</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 25</em></th></tr>
      <tr><td class="left">#include &lt;odp/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/std_types.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/std_types.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/packet.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/packet.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @addtogroup odp_packet</td><td> </td><td class="right">/** @addtogroup odp_packet</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> *  <span class="delete">Boolean operations on a packet</span>.</td><td> </td><td class="rblock"> *  <span class="insert">Operations on packet metadata flags</span>.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">packet errors</span></td><td> </td><td class="rblock"> * Check for <span class="insert">all errors in packet</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Checks all</span> error <span class="delete">flags at once.</span></td><td> </td><td class="rblock"> * <span class="insert">Check if packet parsing has found any errors in the packet. The level of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> error <span class="insert">checking depends on the parse configuration (e.g. included layers </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * checksums). Protocol layer functions (e.g. odp_packet_has_l3()) indicate</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * which layers have been checked, and layer error functions</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (e.g. odp_packet_has_l3_error()) which layers have errors.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">packet</span> has errors</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">packet has no</span> errors</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> has errors</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No</span> errors <span class="insert">were found</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_error(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_error(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">packet L2 errors</span></td><td> </td><td class="rblock"> * Check for <span class="insert">errors in layer 2</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * check <span class="delete">for all L2</span> errors</td><td> </td><td class="rblock"> * <span class="insert">When layer 2 is included in the parse configuration,</span> check <span class="insert">if any</span> errors</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">were</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * found in layer 2 of the packet.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">packet</span> has <span class="delete">L2</span> errors</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">packet has no L2 error</span></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> has errors <span class="insert">in layer 2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No errors were found in layer 2</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_l2_error(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_l2_error(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">L2 header, e.g. ethernet</span></td><td> </td><td class="rblock"> * Check for <span class="insert">errors in layer 3</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * <span class="insert">When layer 3 is included in the parse configuration, check if any errors</span></td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet contains a valid &amp; known L2 header</span></td><td> </td><td class="rblock"><span class="insert"> were</span></td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet does not contain a valid &amp; known L2 header</span></td><td> </td><td class="rblock"><span class="insert"> * found in layer 3 of the packet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet has errors in layer 3</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No errors found in layer 3</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock">int odp_packet_has_l<span class="delete">2</span>(odp_packet_t pkt);</td><td> </td><td class="rblock">int odp_packet_has_l<span class="insert">3_error</span>(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">packet L3 errors</span></td><td> </td><td class="rblock"> * Check for <span class="insert">errors in layer 4</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock"> * check <span class="delete">for all L3</span> errors</td><td> </td><td class="rblock"> * <span class="insert">When layer 4 is included in the parse configuration,</span> check <span class="insert">if any</span> errors</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">were</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * found in layer 4 of the packet.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">packet</span> has <span class="delete">L3</span> errors</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">packet has no L3 error</span></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> has errors <span class="insert">in layer 4</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No errors were found in layer 4</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock">int odp_packet_has_l<span class="delete">3</span>_error(odp_packet_t pkt);</td><td> </td><td class="rblock">int odp_packet_has_l<span class="insert">4</span>_error(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">L3 header, e.g. IPv4, IPv6</span></td><td> </td><td class="rblock"> * Check for <span class="insert">layer 2 protocols</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * <span class="insert">When layer 2 is included in the parse configuration, check if packet par</span></td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet contains a valid &amp; known L3</span> header</td><td> </td><td class="rblock"><span class="insert">sing</span></td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet does not contain a valid &amp; known L3 header</span></td><td> </td><td class="rblock"><span class="insert"> * has found and checked a layer 2 protocol (e.g. Ethernet) in the packet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">A layer 2 protocol</span> header <span class="insert">was found and checked</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No layer 2 protocol was found</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock">int odp_packet_has_l<span class="delete">3</span>(odp_packet_t pkt);</td><td> </td><td class="rblock">int odp_packet_has_l<span class="insert">2</span>(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">packet L4 error</span>s</td><td> </td><td class="rblock"> * Check for <span class="insert">layer 3 protocol</span>s</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"> * check <span class="delete">for all L4 errors</span></td><td> </td><td class="rblock"> * <span class="insert">When layer 3 is included in the parse configuration,</span> check <span class="insert">if packet par</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sing</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * has found and checked a layer 3 protocol (e.g. IPv4, IPv6) in the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">packet has L4 errors</span></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">packet has no L4 error</span></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">A layer 3 protocol header was found and checked</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No layer 3 protocol was found</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock">int odp_packet_has_l<span class="delete">4_error</span>(odp_packet_t pkt);</td><td> </td><td class="rblock">int odp_packet_has_l<span class="insert">3</span>(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock"> * Check for <span class="delete">L4 header, e.g. UDP, TCP, SCTP (also ICMP)</span></td><td> </td><td class="rblock"> * Check for <span class="insert">layer 4 protocols</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * <span class="insert">When layer 4 is included in the parse configuration, check if packet par</span></td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet contains a valid &amp; known L4</span> header</td><td> </td><td class="rblock"><span class="insert">sing</span></td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet does not contain a valid &amp; known L4 header</span></td><td> </td><td class="rblock"><span class="insert"> * has found and checked a layer 4 protocol (e.g. UDP, TCP, SCTP) in the pa</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cket.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">A layer 4 protocol</span> header <span class="insert">was found and checked</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">No layer 4 protocol was found</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_l4(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_l4(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for Ethernet header</td><td> </td><td class="right"> * Check for Ethernet header</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains <span class="delete">a valid eth</span> header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain <span class="delete">a valid eth</span> header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains <span class="insert">an Ethernet</span> header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain <span class="insert">an Ethernet</span> header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_eth(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_eth(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for Ethernet broadcast address</td><td> </td><td class="right"> * Check for Ethernet broadcast address</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ODP recognizes the destination MAC address FF:FF:FF:FF:FF:FF as</td><td> </td><td class="right"> * ODP recognizes the destination MAC address FF:FF:FF:FF:FF:FF as</td></tr>
      <tr><td class="left"> * a broadcast address. All others are considered non-broadcast.</td><td> </td><td class="right"> * a broadcast address. All others are considered non-broadcast.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if</span> Ethernet destination address is the broadcast addres</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock">s</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    Ethernet destination address is the broadcast addres</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if</span> Ethernet destination address is not the broadcast <span class="delete">address</span></td><td> </td><td class="rblock">s</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           Ethernet destination address is not the broadcast <span class="insert">ad</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">dress</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_eth_bcast(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_eth_bcast(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for Ethernet multicast address</td><td> </td><td class="right"> * Check for Ethernet multicast address</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ODP recognizes the destination MAC address as multicast if bit 7 is 1.</td><td> </td><td class="right"> * ODP recognizes the destination MAC address as multicast if bit 7 is 1.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if</span> Ethernet destination address is a multicast address</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if</span> Ethernet destination address is not a multicast <span class="delete">address</span></td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    Ethernet destination address is a multicast address</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           Ethernet destination address is not a multicast <span class="insert">addr</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ess</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_eth_mcast(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_eth_mcast(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for jumbo frame</td><td> </td><td class="right"> * Check for jumbo frame</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet contains</span> a jumbo frame</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet does</span> not <span class="delete">contain</span> a jumbo frame</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet is</span> a jumbo frame</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet is</span> not a jumbo frame</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_jumbo(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_jumbo(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for VLAN</td><td> </td><td class="right"> * Check for VLAN</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a VLAN header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a VLAN header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains a VLAN header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a VLAN header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_vlan(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_vlan(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for VLAN QinQ (stacked VLAN)</td><td> </td><td class="right"> * Check for VLAN QinQ (stacked VLAN)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a VLAN QinQ header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a VLAN QinQ header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains a VLAN QinQ header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a VLAN QinQ header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_vlan_qinq(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_vlan_qinq(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for ARP</td><td> </td><td class="right"> * Check for ARP</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains an ARP message</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain an ARP message</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains an ARP message</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain an ARP message</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_arp(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_arp(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IPv4</td><td> </td><td class="right"> * Check for IPv4</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains an IPv4 header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain an IPv4 header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains an IPv4 header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain an IPv4 header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ipv4(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ipv4(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IPv6</td><td> </td><td class="right"> * Check for IPv6</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains an IPv6 header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain an IPv6 header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains an IPv6 header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain an IPv6 header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ipv6(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ipv6(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IP broadcast address</td><td> </td><td class="right"> * Check for IP broadcast address</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * For IPv4, ODP recognizes the destination IP address 255.255.255.255 as</td><td> </td><td class="right"> * For IPv4, ODP recognizes the destination IP address 255.255.255.255 as</td></tr>
      <tr><td class="left"> * a broadcast address. All other addresses are considered non-broadcast.</td><td> </td><td class="right"> * a broadcast address. All other addresses are considered non-broadcast.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * For IPv6, no destination addresses are recognized as broadcast addresses
.</td><td> </td><td class="right"> * For IPv6, no destination addresses are recognized as broadcast addresses
.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if</span> IP destination address is a broadcast address</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if</span> IP destination address is not a broadcast address</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    IP destination address is a broadcast address</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           IP destination address is not a broadcast address</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ip_bcast(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ip_bcast(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IP multicast address</td><td> </td><td class="right"> * Check for IP multicast address</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * For IPv4 ODP recognizes destination IP addresses in the range 224.0.0.0</td><td> </td><td class="right"> * For IPv4 ODP recognizes destination IP addresses in the range 224.0.0.0</td></tr>
      <tr><td class="left"> * through 239.255.255.255 as multicast addresses.</td><td> </td><td class="right"> * through 239.255.255.255 as multicast addresses.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * For IPv6 ODP recognizes destination IP addresses with prefixes FF00::</td><td> </td><td class="right"> * For IPv6 ODP recognizes destination IP addresses with prefixes FF00::</td></tr>
      <tr><td class="left"> * through FFFF:: as multicast addresses.</td><td> </td><td class="right"> * through FFFF:: as multicast addresses.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if</span> IP destination address is a multicast address</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if</span> IP destination address is not a multicast address</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    IP destination address is a multicast address</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           IP destination address is not a multicast address</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ip_mcast(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ip_mcast(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IP fragment</td><td> </td><td class="right"> * Check for IP fragment</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> is an IP fragment</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> is not an IP fragment</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> is an IP fragment</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> is not an IP fragment</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ipfrag(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ipfrag(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IP options</td><td> </td><td class="right"> * Check for IP options</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains IP options</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain IP options</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains IP options</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain IP options</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ipopt(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ipopt(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for IPSec</td><td> </td><td class="right"> * Check for IPSec</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> requires IPSec processing</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not require IPSec processing</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> requires IPSec processing</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not require IPSec processing</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ipsec(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ipsec(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for UDP</td><td> </td><td class="right"> * Check for UDP</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a UDP header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a UDP header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains a UDP header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a UDP header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_udp(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_udp(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for TCP</td><td> </td><td class="right"> * Check for TCP</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a TCP header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a TCP header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains a TCP header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a TCP header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_tcp(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_tcp(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for SCTP</td><td> </td><td class="right"> * Check for SCTP</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a SCTP header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a SCTP header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains a SCTP header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a SCTP header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_sctp(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_sctp(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for ICMP</td><td> </td><td class="right"> * Check for ICMP</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains an ICMP header</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain an ICMP header</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains an ICMP header</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain an ICMP header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_icmp(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_icmp(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for packet flow hash</td><td> </td><td class="right"> * Check for packet flow hash</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt          Packet handle</td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a hash value</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a hash value</td><td> </td><td class="rblock"> <span class="insert">*</span> @retval non-zero    <span class="insert">Packet</span> contains a hash value</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a hash value</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_flow_hash(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_flow_hash(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for packet timestamp</td><td> </td><td class="right"> * Check for packet timestamp</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lblock"> * @param pkt Packet handle</td><td> </td><td class="rblock"> * @param pkt <span class="insert">         </span>Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lblock"> * @retval non-zero <span class="delete">if packet</span> contains a timestamp value</td><td> </td><td class="rblock"> * @retval non-zero    <span class="insert">Packet</span> contains a timestamp value</td></tr>
      <tr><td class="lblock"> * @retval 0 <span class="delete">if packet</span> does not contain a timestamp value</td><td> </td><td class="rblock"> * @retval 0           <span class="insert">Packet</span> does not contain a timestamp value</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_has_ts_clr()</td><td> </td><td class="right"> * @see odp_packet_has_ts_clr()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_ts(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_ts(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set flag for L2 header, e.g. ethernet</td><td> </td><td class="right"> * Set flag for L2 header, e.g. ethernet</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt Packet handle</td><td> </td><td class="right"> * @param pkt Packet handle</td></tr>
      <tr><td class="left"> * @param val Value</td><td> </td><td class="right"> * @param val Value</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 44 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>98 lines changed or deleted</i></th><th><i> </i></th><th><i>151 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_io.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_io.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 25</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 25</em></th></tr>
      <tr><td class="left">#include &lt;odp/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/deprecated.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/deprecated.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/packet_io_stats.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/packet_io_stats.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/queue.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/queue.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/time.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/time.h&gt;</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/packet.h&gt;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @defgroup odp_packet_io ODP PACKET IO</td><td> </td><td class="right">/** @defgroup odp_packet_io ODP PACKET IO</td></tr>
      <tr><td class="left"> *  Operations on a packet Input/Output interface.</td><td> </td><td class="right"> *  Operations on a packet Input/Output interface.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet IO is the Ingress and Egress interface to ODP processing. It</td><td> </td><td class="right"> * Packet IO is the Ingress and Egress interface to ODP processing. It</td></tr>
      <tr><td class="left"> * allows manipulation of the interface for setting such attributes as</td><td> </td><td class="right"> * allows manipulation of the interface for setting such attributes as</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">the mtu, mac</span> etc.</td><td> </td><td class="rblock"> * <span class="insert">number of queues, MAC address</span> etc.</td></tr>
      <tr><td class="left"> * Pktio is usually followed by the classifier and a default class COS</td><td> </td><td class="right"> * Pktio is usually followed by the classifier and a default class COS</td></tr>
      <tr><td class="left"> * can be set so that the scheduler may distribute flows. The interface</td><td> </td><td class="right"> * can be set so that the scheduler may distribute flows. The interface</td></tr>
      <tr><td class="left"> * may be used directly in polled mode with odp_pktin_recv() and</td><td> </td><td class="right"> * may be used directly in polled mode with odp_pktin_recv() and</td></tr>
      <tr><td class="left"> * odp_pktout_send().</td><td> </td><td class="right"> * odp_pktout_send().</td></tr>
      <tr><td class="left"> * Diagnostic messages can be enhanced by using odp_pktio_to_u64 which</td><td> </td><td class="right"> * Diagnostic messages can be enhanced by using odp_pktio_to_u64 which</td></tr>
      <tr><td class="left"> * will generate a printable reference for a pktio handle for use with</td><td> </td><td class="right"> * will generate a printable reference for a pktio handle for use with</td></tr>
      <tr><td class="left"> * the logging.</td><td> </td><td class="right"> * the logging.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 258</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 259</em></th></tr>
      <tr><td class="left">} odp_pktio_param_t;</td><td> </td><td class="right">} odp_pktio_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet input configuration options bit field</td><td> </td><td class="right"> * Packet input configuration options bit field</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet input configuration options listed in a bit field structure. Pack
et</td><td> </td><td class="right"> * Packet input configuration options listed in a bit field structure. Pack
et</td></tr>
      <tr><td class="left"> * input timestamping may be enabled for all packets or at least for those 
that</td><td> </td><td class="right"> * input timestamping may be enabled for all packets or at least for those 
that</td></tr>
      <tr><td class="left"> * belong to time synchronization protocol (PTP).</td><td> </td><td class="right"> * belong to time synchronization protocol (PTP).</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet input checksum checking may be enabled or disabled. When it is</td><td> </td><td class="right"> * Packet input checksum checking may be enabled or disabled. When it is</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"> * enabled, implementation will verify checksum correctness on <span class="delete">incoming pac</span></td><td> </td><td class="rblock"> * enabled, implementation will <span class="insert">attempt to</span> verify checksum correctness on</td></tr>
      <tr><td class="lblock"><span class="delete">kets</span></td><td> </td><td class="rblock"> * <span class="insert">incoming packets</span> and depending on drop configuration either deliver <span class="insert">erro</span></td></tr>
      <tr><td class="lblock"> * and depending on drop configuration either deliver <span class="delete">erroneous packets wit</span></td><td> </td><td class="rblock"><span class="insert">neous</span></td></tr>
      <tr><td class="lblock"><span class="delete">h</span></td><td> </td><td class="rblock"> * <span class="insert">packets with</span> appropriate flags set (e.g. <span class="insert">odp_packet_has_l3_error(),</span></td></tr>
      <tr><td class="lblock"> * appropriate flags set (e.g. <span class="delete">odp_packet_has_l3_error())</span> or drop those.</td><td> </td><td class="rblock"><span class="insert"> * odp_packet_l3_chksum_status())</span> or drop those. When packet dropping is</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> When packet dropping is enabled, application will never receive a packet</td><td> </td><td class="rblock"> <span class="insert">*</span> enabled, application will never receive a packet with the specified <span class="insert">erro</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> with the specified <span class="delete">error</span> and may avoid to check the error flag.</td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> and may avoid to check the error flag.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * If checksum checking is enabled, IPv4 header checksum checking is always</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * done for packets that do not have IP options and L4 checksum checking</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is done for unfragmented packets that do not have IPv4 options or IPv6</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * extension headers. In other cases checksum checking may or may not</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * be done. For example, L4 checksum of fragmented packets is typically</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * not checked.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * IPv4 checksum checking may be enabled only when parsing level is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_PROTO_LAYER_L3 or higher. Similarly, L4 level checksum checking</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * may be enabled only with parsing level ODP_PROTO_LAYER_L4 or higher.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Whether checksum checking was done and whether a checksum was correct</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * can be queried for each received packet with odp_packet_l3_chksum_status</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and odp_packet_l4_chksum_status().</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef union odp_pktin_config_opt_t {</td><td> </td><td class="right">typedef union odp_pktin_config_opt_t {</td></tr>
      <tr><td class="left">       /** Option flags */</td><td> </td><td class="right">       /** Option flags */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Timestamp all packets on packet input */</td><td> </td><td class="right">               /** Timestamp all packets on packet input */</td></tr>
      <tr><td class="left">               uint64_t ts_all        : 1;</td><td> </td><td class="right">               uint64_t ts_all        : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Timestamp (at least) IEEE1588 / PTP packets</td><td> </td><td class="right">               /** Timestamp (at least) IEEE1588 / PTP packets</td></tr>
      <tr><td class="left">                 * on packet input */</td><td> </td><td class="right">                 * on packet input */</td></tr>
      <tr><td class="left">               uint64_t ts_ptp        : 1;</td><td> </td><td class="right">               uint64_t ts_ptp        : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 314</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 331</em></th></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * This field can be used to set/clear all flags, or bitwise</td><td> </td><td class="right">         * This field can be used to set/clear all flags, or bitwise</td></tr>
      <tr><td class="left">         * operations over the entire structure. */</td><td> </td><td class="right">         * operations over the entire structure. */</td></tr>
      <tr><td class="left">       uint64_t all_bits;</td><td> </td><td class="right">       uint64_t all_bits;</td></tr>
      <tr><td class="left">} odp_pktin_config_opt_t;</td><td> </td><td class="right">} odp_pktin_config_opt_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet output configuration options bit field</td><td> </td><td class="right"> * Packet output configuration options bit field</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet output configuration options listed in a bit field structure. Pac
ket</td><td> </td><td class="right"> * Packet output configuration options listed in a bit field structure. Pac
ket</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * output checksum insertion may be enabled or <span class="delete">disabled. When it is enabled</span></td><td> </td><td class="rblock"> * output checksum insertion may be enabled or <span class="insert">disabled (e.g. ipv4_chksum_e</span></td></tr>
      <tr><td class="lblock"><span class="delete">,</span></td><td> </td><td class="rblock"><span class="insert">na):</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">implementation</span> will <span class="delete">calculate and insert</span> checksum <span class="delete">into every outgoing pa</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"><span class="delete">cket</span></td><td> </td><td class="rblock"> *  <span class="insert">0: Disable checksum insertion. Application</span> will <span class="insert">not request</span> checksum</td></tr>
      <tr><td class="lblock"> * <span class="delete">by default.</span> Application may use <span class="delete">a packet metadata flag</span> to <span class="delete">disable checks</span></td><td> </td><td class="rblock"> *     <span class="insert">insertion for any packet. This is the default value for xxx_chksum_e</span></td></tr>
      <tr><td class="lblock"><span class="delete">um</span></td><td> </td><td class="rblock"><span class="insert">na</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">insertion</span> per packet <span class="delete">bases.</span> For correct operation, packet metadata must</td><td> </td><td class="rblock"><span class="insert"> *     bits.</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> provide valid offsets for <span class="delete">the</span> appropriate protocols. For example, UDP</td><td> </td><td class="rblock"><span class="insert"> *  1: Enable checksum insertion.</span> Application <span class="insert">will request checksum inserti</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> checksum calculation needs both L3 and L4 offsets (to access IP and UDP</td><td> </td><td class="rblock"><span class="insert">on</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> headers). When application (e.g. a switch) does not modify L3/L4 data <span class="delete">an</span></td><td> </td><td class="rblock"><span class="insert"> *     for some packets.</span></td></tr>
      <tr><td class="lblock"><span class="delete">d</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> thus checksum does not <span class="delete">need</span> to be updated, <span class="delete">output</span> checksum insertion <span class="delete">sho</span></td><td> </td><td class="rblock"><span class="insert"> * When checksum insertion is enabled, application</span> may use <span class="insert">configuration op</span></td></tr>
      <tr><td class="lblock"><span class="delete">uld</span></td><td> </td><td class="rblock"><span class="insert">tions</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> be disabled for optimal <span class="delete">performance.</span></td><td> </td><td class="rblock"><span class="insert"> *</span> to <span class="insert">set the default behaviour on packet output (e.g. ipv4_chksum):</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*  0: Do not insert checksum by default. This is the default value for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *     xxx_chksum bits.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *  1: Calculate and insert checksum by default.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * These defaults may be overridden on</span> per packet <span class="insert">basis using e.g.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_packet_l4_chksum_insert().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> For correct operation, packet metadata must provide valid offsets for <span class="insert">th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> appropriate protocols. For example, UDP checksum calculation needs both </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">L3</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> and L4 offsets (to access IP and UDP headers). When application</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> (e.g. a switch) does not modify L3/L4 data <span class="insert">and</span> thus checksum does not <span class="insert">ne</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> to be updated, checksum insertion <span class="insert">should</span> be disabled for optimal <span class="insert">perform</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ance.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet flags (odp_packet_has_*()) are ignored for the purpose of checksu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * insertion in packet output.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * UDP, TCP and SCTP checksum insertion must not be requested for IP fragme</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nts.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Use checksum override function (odp_packet_l4_chksum_insert()) to disabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * checksumming when sending a fragment through a packet IO interface that </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">has</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the relevant L4 checksum insertion enabled.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Result of checksum insertion at packet output is undefined if the protoc</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ol</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * headers required for checksum calculation are not well formed. Packet mu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">st</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * contain at least as many data bytes after L3/L4 offsets as the headers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * indicate. Other data bytes of the packet are ignored for the checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * insertion.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef union odp_pktout_config_opt_t {</td><td> </td><td class="right">typedef union odp_pktout_config_opt_t {</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">       /** Option flags */</td><td> </td><td class="rblock">       /** Option flags <span class="insert">for packet output </span>*/</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock">               /** <span class="delete">Insert</span> IPv4 header checksum <span class="delete">on packet output</span> */</td><td> </td><td class="rblock">               /** <span class="insert">Enable</span> IPv4 header checksum <span class="insert">insertion.</span> */</td></tr>
      <tr><td class="lblock">               uint64_t <span class="delete">ipv4_chksum</span>  : 1;</td><td> </td><td class="rblock">               uint64_t <span class="insert">ipv4_chksum_ena</span> : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock">               /** <span class="delete">Insert</span> UDP checksum <span class="delete">on packet output</span> */</td><td> </td><td class="rblock">               /** <span class="insert">Enable</span> UDP checksum <span class="insert">insertion</span> */</td></tr>
      <tr><td class="lblock">               uint64_t <span class="delete">udp_chksum</span>   : 1;</td><td> </td><td class="rblock">               uint64_t <span class="insert">udp_chksum_ena</span>  : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock">               /** <span class="delete">Insert</span> TCP checksum <span class="delete">on packet output</span> */</td><td> </td><td class="rblock">               /** <span class="insert">Enable</span> TCP checksum <span class="insert">insertion</span> */</td></tr>
      <tr><td class="lblock">               uint64_t <span class="delete">tcp_chksum</span>   : 1;</td><td> </td><td class="rblock">               uint64_t <span class="insert">tcp_chksum_ena</span>  : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock">               /** Insert SCTP checksum on packet <span class="delete">output</span> */</td><td> </td><td class="rblock">               /** <span class="insert">Enable SCTP checksum insertion */</span></td></tr>
      <tr><td class="lblock">               uint64_t sctp_chksum  : 1;</td><td> </td><td class="rblock"><span class="insert">               uint64_t sctp_chksum_ena : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert IPv4 header checksum by default */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t ipv4_chksum     : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert UDP checksum on packet by default */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t udp_chksum      : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert TCP checksum on packet by default */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t tcp_chksum      : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /**</span> Insert SCTP checksum on packet <span class="insert">by default</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               uint64_t sctp_chksum     : 1;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       } bit;</td><td> </td><td class="right">       } bit;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** All bits of the bit field structure</td><td> </td><td class="right">       /** All bits of the bit field structure</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * This field can be used to set/clear all flags, or bitwise</td><td> </td><td class="right">         * This field can be used to set/clear all flags, or bitwise</td></tr>
      <tr><td class="left">         * operations over the entire structure. */</td><td> </td><td class="right">         * operations over the entire structure. */</td></tr>
      <tr><td class="left">       uint64_t all_bits;</td><td> </td><td class="right">       uint64_t all_bits;</td></tr>
      <tr><td class="left">} odp_pktout_config_opt_t;</td><td> </td><td class="right">} odp_pktout_config_opt_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Parser layers</td><td> </td><td class="right"> * Parser layers</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @deprecated Use odp_proto_layer_t instead</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">typedef <span class="delete">enum odp_pktio_parser_layer_t {</span></td><td> </td><td class="rblock">typedef <span class="insert">odp_proto_layer_t odp_pktio_parser_layer_t;</span></td></tr>
      <tr><td class="lblock"><span class="delete">       /** No layers */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       ODP_PKTIO_PARSER_LAYER_NONE = 0,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">Layer L2 protocols (Ethernet, VLAN, ARP, etc)</span> */</td><td> </td><td class="rblock">/** <span class="insert">No layers</span></td></tr>
      <tr><td class="lblock">       <span class="delete">ODP_PKTIO_PARSER_LAYER_L2,</span></td><td> </td><td class="rblock"><span class="insert"> *  @deprecated Use ODP_PROTO_LAYER_NONE, instead</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIO_PARSER_LAYER_NONE ODP_PROTO_LAYER_NONE</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock">       /** Layer <span class="delete">L3</span> protocols <span class="delete">(IPv4, IPv6, ICMP, IPsec,</span> etc) */</td><td> </td><td class="rblock">/** Layer <span class="insert">L2</span> protocols <span class="insert">(Ethernet, VLAN, ARP,</span> etc)</td></tr>
      <tr><td class="lblock">       <span class="delete">ODP_PKTIO_PARSER_LAYER_L3,</span></td><td> </td><td class="rblock"> <span class="insert">*  @deprecated Use ODP_PROTO_LAYER_L2, instead</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIO_PARSER_LAYER_L2 ODP_PROTO_LAYER_L2</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock">       /** Layer <span class="delete">L4</span> protocols <span class="delete">(UDP, TCP, SCTP)</span> */</td><td> </td><td class="rblock">/** Layer <span class="insert">L3</span> protocols <span class="insert">(IPv4, IPv6, ICMP, IPsec, etc)</span></td></tr>
      <tr><td class="lblock">       <span class="delete">ODP_PKTIO_PARSER_LAYER_L4,</span></td><td> </td><td class="rblock"><span class="insert"> *  @deprecated Use ODP_PROTO_LAYER_L3, instead</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIO_PARSER_LAYER_L3 ODP_PROTO_LAYER_L3</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">All layers</span> */</td><td> </td><td class="rblock">/** <span class="insert">Layer L4 protocols (UDP, TCP, SCTP)</span></td></tr>
      <tr><td class="lblock">       <span class="delete">ODP_PKTIO_PARSER_LAYER_ALL</span></td><td> </td><td class="rblock"><span class="insert"> *  @deprecated Use ODP_PROTO_LAYER_L4, instead</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIO_PARSER_LAYER_L4 ODP_PROTO_LAYER_L4</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"><span class="delete">} odp_pktio_parser_layer_t;</span></td><td> </td><td class="rblock"><span class="insert">/** All layers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *  @deprecated Use ODP_PROTO_LAYER_ALL instead */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIO_PARSER_LAYER_ALL ODP_PROTO_LAYER_ALL</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Parser configuration</td><td> </td><td class="right"> * Parser configuration</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pktio_parser_config_t {</td><td> </td><td class="right">typedef struct odp_pktio_parser_config_t {</td></tr>
      <tr><td class="left">       /** Protocol parsing level in packet input</td><td> </td><td class="right">       /** Protocol parsing level in packet input</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock">         * <span class="delete">Parse</span> protocol <span class="delete">layers</span> in <span class="delete">minimum</span> up to this <span class="delete">level</span> during packet</td><td> </td><td class="rblock">         * <span class="insert">Application requires that</span> protocol <span class="insert">headers</span> in <span class="insert">a packet are check</span></td></tr>
      <tr><td class="lblock">         <span class="delete">*</span> input. The default value is <span class="delete">ODP_PKTIO_PARSER_LAYER_ALL.</span> */</td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock">       <span class="delete">odp_pktio_parser_layer_t</span> layer;</td><td> </td><td class="rblock"><span class="insert">         *</span> up to this <span class="insert">layer</span> during packet input. <span class="insert">Use ODP_PROTO_LAYER_ALL fo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * all layers. Packet metadata for this and all preceding layers ar</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * set. In addition, offset (and pointer) to the next layer is set.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * Other layer/protocol specific metadata have undefined values.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span> The default value is <span class="insert">ODP_PROTO_LAYER_ALL.</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">odp_proto_layer_t</span> layer;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_pktio_parser_config_t;</td><td> </td><td class="right">} odp_pktio_parser_config_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO configuration options</td><td> </td><td class="right"> * Packet IO configuration options</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet IO interface level configuration options. Use odp_pktio_capabilit
y()</td><td> </td><td class="right"> * Packet IO interface level configuration options. Use odp_pktio_capabilit
y()</td></tr>
      <tr><td class="left"> * to see which options are supported by the implementation.</td><td> </td><td class="right"> * to see which options are supported by the implementation.</td></tr>
      <tr><td class="left"> * Use odp_pktio_config_init() to initialize the structure with default val
ues.</td><td> </td><td class="right"> * Use odp_pktio_config_init() to initialize the structure with default val
ues.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 410</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 478</em></th></tr>
      <tr><td class="left">       odp_pktio_parser_config_t parser;</td><td> </td><td class="right">       odp_pktio_parser_config_t parser;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Interface loopback mode</td><td> </td><td class="right">       /** Interface loopback mode</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        * In this mode the packets sent out through the interface is</td><td> </td><td class="right">        * In this mode the packets sent out through the interface is</td></tr>
      <tr><td class="left">        * looped back to input of the same interface. Supporting loopback m
ode</td><td> </td><td class="right">        * looped back to input of the same interface. Supporting loopback m
ode</td></tr>
      <tr><td class="left">        * is an optional feature per interface and should be queried in the</td><td> </td><td class="right">        * is an optional feature per interface and should be queried in the</td></tr>
      <tr><td class="left">        * interface capability before enabling the same. */</td><td> </td><td class="right">        * interface capability before enabling the same. */</td></tr>
      <tr><td class="left">       odp_bool_t enable_loop;</td><td> </td><td class="right">       odp_bool_t enable_loop;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Inbound IPSEC inlined with packet input</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Enable/disable inline inbound IPSEC operation. When enabled pack</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">et</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  input directs all IPSEC packets automatically to IPSEC inbound</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  processing. IPSEC configuration is done through the IPSEC API.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Packets that are not (recognized as) IPSEC are processed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  according to the packet input configuration.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  0: Disable inbound IPSEC inline operation (default)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  1: Enable inbound IPSEC inline operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  @see odp_ipsec_config(), odp_ipsec_sa_create()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t inbound_ipsec;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Outbound IPSEC inlined with packet output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Enable/disable inline outbound IPSEC operation. When enabled IPS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">EC</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  outbound processing can send outgoing IPSEC packets directly</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  to the pktio interface for output. IPSEC configuration is done</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  through the IPSEC API.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Outbound IPSEC inline operation cannot be combined with traffic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  manager (ODP_PKTOUT_MODE_TM).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  0: Disable outbound IPSEC inline operation (default)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  1: Enable outbound IPSEC inline operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  @see odp_ipsec_config(), odp_ipsec_sa_create()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t outbound_ipsec;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">} odp_pktio_config_t;</td><td> </td><td class="right">} odp_pktio_config_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO set operations</td><td> </td><td class="right"> * Packet IO set operations</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Supported packet IO interface set operations listed in a bit field struc
ture.</td><td> </td><td class="right"> * Supported packet IO interface set operations listed in a bit field struc
ture.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef union odp_pktio_set_op_t {</td><td> </td><td class="right">typedef union odp_pktio_set_op_t {</td></tr>
      <tr><td class="left">       /** Operation flags */</td><td> </td><td class="right">       /** Operation flags */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Promiscuous mode */</td><td> </td><td class="right">               /** Promiscuous mode */</td></tr>
      <tr><td class="left">               uint32_t promisc_mode : 1;</td><td> </td><td class="right">               uint32_t promisc_mode : 1;</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** MAC address  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t mac_addr : 1;</span></td></tr>
      <tr><td class="left">       } op;</td><td> </td><td class="right">       } op;</td></tr>
      <tr><td class="left">       /** All bits of the bit field structure.</td><td> </td><td class="right">       /** All bits of the bit field structure.</td></tr>
      <tr><td class="left">         * This field can be used to set/clear all flags, or bitwise</td><td> </td><td class="right">         * This field can be used to set/clear all flags, or bitwise</td></tr>
      <tr><td class="left">         * operations over the entire structure. */</td><td> </td><td class="right">         * operations over the entire structure. */</td></tr>
      <tr><td class="left">       uint32_t all_bits;</td><td> </td><td class="right">       uint32_t all_bits;</td></tr>
      <tr><td class="left">} odp_pktio_set_op_t;</td><td> </td><td class="right">} odp_pktio_set_op_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO capabilities</td><td> </td><td class="right"> * Packet IO capabilities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 875</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 977</em></th></tr>
      <tr><td class="left"> * @param packets[]    Array of packets to send</td><td> </td><td class="right"> * @param packets[]    Array of packets to send</td></tr>
      <tr><td class="left"> * @param num          Number of packets to send</td><td> </td><td class="right"> * @param num          Number of packets to send</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Number of packets sent</td><td> </td><td class="right"> * @return Number of packets sent</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktout_send(odp_pktout_queue_t queue, const odp_packet_t packets[],</td><td> </td><td class="right">int odp_pktout_send(odp_pktout_queue_t queue, const odp_packet_t packets[],</td></tr>
      <tr><td class="left">                   int num);</td><td> </td><td class="right">                   int num);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Return the currently configured MTU value of a packet IO interface.</span></td><td> </td><td class="rblock"> * <span class="insert">MTU value of a packet IO interface</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> pktio  Packet IO handle.</td><td> </td><td class="rblock"> * <span class="insert">@deprecated  Use odp_pktin_maxlen() and odp_pktout_maxlen() instead. MTU</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> was</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * not well defined. There may be difference between MTU and maximum frame</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * length values.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param</span> pktio  Packet IO handle.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return MTU value on success</td><td> </td><td class="right"> * @return MTU value on success</td></tr>
      <tr><td class="left"> * @retval 0 on failure</td><td> </td><td class="right"> * @retval 0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock">uint32_t <span class="delete">odp_pktio_mtu</span>(odp_pktio_t pktio);</td><td> </td><td class="rblock">uint32_t <span class="insert">ODP_DEPRECATE(odp_pktio_mtu)</span>(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Enable/Disable promiscuous mode on a packet IO interface.</td><td> </td><td class="right"> * Enable/Disable promiscuous mode on a packet IO interface.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> pktio    Packet IO handle.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio   Packet IO handle.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> enable   1 to enable, 0 to disable.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> enable  1 to enable, 0 to disable.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_promisc_mode_set(odp_pktio_t pktio, odp_bool_t enable);</td><td> </td><td class="right">int odp_pktio_promisc_mode_set(odp_pktio_t pktio, odp_bool_t enable);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Determine if promiscuous mode is enabled for a packet IO interface.</td><td> </td><td class="right"> * Determine if promiscuous mode is enabled for a packet IO interface.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in] pktio</span> Packet IO handle.</td><td> </td><td class="rblock"> * @param<span class="insert"> pktio </span> Packet IO handle.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval  1 if promiscuous mode is enabled.</td><td> </td><td class="right"> * @retval  1 if promiscuous mode is enabled.</td></tr>
      <tr><td class="left"> * @retval  0 if promiscuous mode is disabled.</td><td> </td><td class="right"> * @retval  0 if promiscuous mode is disabled.</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">int odp_pktio_promisc_mode(odp_pktio_t pktio);</td><td> </td><td class="right">int odp_pktio_promisc_mode(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Maximum frame length at packet input</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Maximum frame length in bytes that the packet IO interface can receive.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For Ethernet, the frame length bytes start with MAC addresses and contin</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ue</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to the end of the payload. So, Ethernet checksum, interpacket gap</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and preamble bytes are excluded from the length.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pktio  Packet IO handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Maximum frame length at packet input</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint32_t odp_pktin_maxlen(odp_pktio_t pktio);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Maximum frame length at packet output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Maximum frame length in bytes that the packet IO interface can transmit.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For Ethernet, the frame length bytes start with MAC addresses and contin</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ue</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to the end of the payload. So, Ethernet checksum, interpacket gap</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and preamble bytes are excluded from the length.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pktio  Packet IO handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Maximum frame length at packet output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint32_t odp_pktout_maxlen(odp_pktio_t pktio);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Get the default MAC address of a packet IO interface.</td><td> </td><td class="right"> * Get the default MAC address of a packet IO interface.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pktio     Packet IO handle</td><td> </td><td class="right"> * @param      pktio     Packet IO handle</td></tr>
      <tr><td class="left"> * @param[out] mac_addr  Output buffer (use ODP_PKTIO_MACADDR_MAXSIZE)</td><td> </td><td class="right"> * @param[out] mac_addr  Output buffer (use ODP_PKTIO_MACADDR_MAXSIZE)</td></tr>
      <tr><td class="left"> * @param       size      Size of output buffer</td><td> </td><td class="right"> * @param       size      Size of output buffer</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Number of bytes written (actual size of MAC address)</td><td> </td><td class="right"> * @return Number of bytes written (actual size of MAC address)</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_mac_addr(odp_pktio_t pktio, void *mac_addr, int size);</td><td> </td><td class="right">int odp_pktio_mac_addr(odp_pktio_t pktio, void *mac_addr, int size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Set the default MAC address of a packet IO interface.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Support of this operation on a packet IO interface is reported</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * through ‘mac_addr’ set operation capability.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pktio     Packet IO handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      mac_addr  MAC address to be set as default address</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      size      Size of the MAC address</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_pktio_mac_addr_set(odp_pktio_t pktio, const void *mac_addr,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          int size);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Setup per-port default class-of-service.</td><td> </td><td class="right"> * Setup per-port default class-of-service.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  pktio           Ingress port pktio handle.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio        Ingress port pktio handle.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  default_cos     Class-of-service set to all packets arriving</td><td> </td><td class="rblock"> * <span class="insert">@param</span> default_cos  Class-of-service set to all packets arriving at this</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             at this ingress port,</td><td> </td><td class="rblock"> <span class="insert">*</span>                     ingress port, unless overridden by subsequent</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             unless overridden by subsequent</td><td> </td><td class="rblock"> *                     header-based filters.</td></tr>
      <tr><td class="lblock"> *                             header-based filters.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note The default_cos has to be unique per odp_pktio_t instance.</td><td> </td><td class="right"> * @note The default_cos has to be unique per odp_pktio_t instance.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_default_cos_set(odp_pktio_t pktio, odp_cos_t default_cos);</td><td> </td><td class="right">int odp_pktio_default_cos_set(odp_pktio_t pktio, odp_cos_t default_cos);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Setup per-port error class-of-service</td><td> </td><td class="right"> * Setup per-port error class-of-service</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  pktio           Ingress port pktio handle.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio      Ingress port pktio handle.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  error_cos       class-of-service set to all packets arriving</td><td> </td><td class="rblock"> * <span class="insert">@param</span> error_cos  class-of-service set to all packets arriving at this</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             at this ingress port that contain an error.</td><td> </td><td class="rblock"> <span class="insert">*</span>                   ingress port that contain an error.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Optional.</td><td> </td><td class="right"> * @note Optional.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_error_cos_set(odp_pktio_t pktio, odp_cos_t error_cos);</td><td> </td><td class="right">int odp_pktio_error_cos_set(odp_pktio_t pktio, odp_cos_t error_cos);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Setup per-port header offset</td><td> </td><td class="right"> * Setup per-port header offset</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  pktio           Ingress port pktio handle.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio      Ingress port pktio handle.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  offset          Number of bytes the classifier must skip.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> offset     Number of bytes the classifier must skip.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lblock"> * @retval                     0 on success</td><td> </td><td class="rblock"> * @retval  0 on success</td></tr>
      <tr><td class="lblock"> * @retval                     &lt;0 on failure</td><td> </td><td class="rblock"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="lblock"> <span class="delete">* @note  Optional.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @note Optional.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_skip_set(odp_pktio_t pktio, uint32_t offset);</td><td> </td><td class="right">int odp_pktio_skip_set(odp_pktio_t pktio, uint32_t offset);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Specify per-port buffer headroom</td><td> </td><td class="right"> * Specify per-port buffer headroom</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  pktio           Ingress port pktio handle.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pktio     Ingress port pktio handle.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  headroom        Number of bytes of space preceding</td><td> </td><td class="rblock"> * <span class="insert">@param</span> headroom  Number of bytes of space preceding packet data to <span class="insert">reser</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             packet data to <span class="delete">reserve</span> for use as headroom.</td><td> </td><td class="rblock"><span class="insert">ve</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                             Must not exceed the implementation</td><td> </td><td class="rblock"><span class="insert"> *</span>                  for use as headroom. Must not exceed the implementation</td></tr>
      <tr><td class="lblock"> *                             defined ODP_PACKET_MAX_HEADROOM.</td><td> </td><td class="rblock"> *                  defined ODP_PACKET_MAX_HEADROOM.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval                     0 on success</td><td> </td><td class="right"> * @retval                     0 on success</td></tr>
      <tr><td class="left"> * @retval                     &lt;0 on failure</td><td> </td><td class="right"> * @retval                     &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Optional.</td><td> </td><td class="right"> * @note Optional.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_headroom_set(odp_pktio_t pktio, uint32_t headroom);</td><td> </td><td class="right">int odp_pktio_headroom_set(odp_pktio_t pktio, uint32_t headroom);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get pktio interface index</td><td> </td><td class="right"> * Get pktio interface index</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 34 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>74 lines changed or deleted</i></th><th><i> </i></th><th><i>243 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;pool.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;pool.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 43</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 43</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_POOL_INVALID</td><td> </td><td class="right"> * @def ODP_POOL_INVALID</td></tr>
      <tr><td class="left"> * Invalid pool</td><td> </td><td class="right"> * Invalid pool</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_POOL_NAME_LEN</td><td> </td><td class="right"> * @def ODP_POOL_NAME_LEN</td></tr>
      <tr><td class="left"> * Maximum pool name length in chars including null char</td><td> </td><td class="right"> * Maximum pool name length in chars including null char</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Maximum number of packet pool subparameters */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_POOL_MAX_SUBPARAMS  7</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Pool capabilities</td><td> </td><td class="right"> * Pool capabilities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pool_capability_t {</td><td> </td><td class="right">typedef struct odp_pool_capability_t {</td></tr>
      <tr><td class="left">       /** Maximum number of pools of any type */</td><td> </td><td class="right">       /** Maximum number of pools of any type */</td></tr>
      <tr><td class="left">       unsigned max_pools;</td><td> </td><td class="right">       unsigned max_pools;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Buffer pool capabilities  */</td><td> </td><td class="right">       /** Buffer pool capabilities  */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Maximum number of buffer pools */</td><td> </td><td class="right">               /** Maximum number of buffer pools */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 99</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 102</em></th></tr>
      <tr><td class="left">                * memory size for the pool. */</td><td> </td><td class="right">                * memory size for the pool. */</td></tr>
      <tr><td class="left">               uint32_t max_num;</td><td> </td><td class="right">               uint32_t max_num;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Minimum packet level headroom length in bytes</td><td> </td><td class="right">               /** Minimum packet level headroom length in bytes</td></tr>
      <tr><td class="left">                *</td><td> </td><td class="right">                *</td></tr>
      <tr><td class="left">                * The minimum number of headroom bytes that newly created</td><td> </td><td class="right">                * The minimum number of headroom bytes that newly created</td></tr>
      <tr><td class="left">                * packets have by default. The default apply to both ODP</td><td> </td><td class="right">                * packets have by default. The default apply to both ODP</td></tr>
      <tr><td class="left">                * packet input and user allocated packets.*/</td><td> </td><td class="right">                * packet input and user allocated packets.*/</td></tr>
      <tr><td class="left">               uint32_t min_headroom;</td><td> </td><td class="right">               uint32_t min_headroom;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** Maximum packet level headroom length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The maximum value of packet pool headroom parameter</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * that can be configured. This value applies to both ODP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * packet input and user allocated packets.*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_headroom;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">               /** Minimum packet level tailroom length in bytes</td><td> </td><td class="right">               /** Minimum packet level tailroom length in bytes</td></tr>
      <tr><td class="left">                *</td><td> </td><td class="right">                *</td></tr>
      <tr><td class="left">                * The minimum number of tailroom bytes that newly created</td><td> </td><td class="right">                * The minimum number of tailroom bytes that newly created</td></tr>
      <tr><td class="left">                * packets have by default. The default apply to both ODP</td><td> </td><td class="right">                * packets have by default. The default apply to both ODP</td></tr>
      <tr><td class="left">                * packet input and user allocated packets.*/</td><td> </td><td class="right">                * packet input and user allocated packets.*/</td></tr>
      <tr><td class="left">               uint32_t min_tailroom;</td><td> </td><td class="right">               uint32_t min_tailroom;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Maximum number of segments per packet */</td><td> </td><td class="right">               /** Maximum number of segments per packet */</td></tr>
      <tr><td class="left">               uint32_t max_segs_per_pkt;</td><td> </td><td class="right">               uint32_t max_segs_per_pkt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 129</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 139</em></th></tr>
      <tr><td class="left">                *</td><td> </td><td class="right">                *</td></tr>
      <tr><td class="left">                * The value of zero means that limited only by the availabl
e</td><td> </td><td class="right">                * The value of zero means that limited only by the availabl
e</td></tr>
      <tr><td class="left">                * memory size for the pool. */</td><td> </td><td class="right">                * memory size for the pool. */</td></tr>
      <tr><td class="left">               uint32_t max_seg_len;</td><td> </td><td class="right">               uint32_t max_seg_len;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Maximum user area size in bytes</td><td> </td><td class="right">               /** Maximum user area size in bytes</td></tr>
      <tr><td class="left">                *</td><td> </td><td class="right">                *</td></tr>
      <tr><td class="left">                * The value of zero means that limited only by the availabl
e</td><td> </td><td class="right">                * The value of zero means that limited only by the availabl
e</td></tr>
      <tr><td class="left">                * memory size for the pool. */</td><td> </td><td class="right">                * memory size for the pool. */</td></tr>
      <tr><td class="left">               uint32_t max_uarea_size;</td><td> </td><td class="right">               uint32_t max_uarea_size;</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** Maximum number of subparameters</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  Maximum number of packet pool subparameters. Valid range</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  0 ... ODP_POOL_MAX_SUBPARAMS. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint8_t max_num_subparam;</span></td></tr>
      <tr><td class="left">       } pkt;</td><td> </td><td class="right">       } pkt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Timeout pool capabilities  */</td><td> </td><td class="right">       /** Timeout pool capabilities  */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Maximum number of timeout pools */</td><td> </td><td class="right">               /** Maximum number of timeout pools */</td></tr>
      <tr><td class="left">               unsigned max_pools;</td><td> </td><td class="right">               unsigned max_pools;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Maximum number of timeout events in a pool</td><td> </td><td class="right">               /** Maximum number of timeout events in a pool</td></tr>
      <tr><td class="left">                *</td><td> </td><td class="right">                *</td></tr>
      <tr><td class="left">                * The value of zero means that limited only by the availabl
e</td><td> </td><td class="right">                * The value of zero means that limited only by the availabl
e</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 158</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 174</em></th></tr>
      <tr><td class="left"> * Outputs pool capabilities on success.</td><td> </td><td class="right"> * Outputs pool capabilities on success.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[out] capa   Pointer to capability structure for output</td><td> </td><td class="right"> * @param[out] capa   Pointer to capability structure for output</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pool_capability(odp_pool_capability_t *capa);</td><td> </td><td class="right">int odp_pool_capability(odp_pool_capability_t *capa);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Packet pool subparameters</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_pool_pkt_subparam_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Number of 'len' byte packets. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t num;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Packet length in bytes */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t len;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_pool_pkt_subparam_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Pool parameters</td><td> </td><td class="right"> * Pool parameters</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Used to communicate pool creation options.</span></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * <span class="delete">@note</span> A single thread may not be able to allocate <span class="delete">all</span> 'num' elements</td><td> </td><td class="rblock"> * A <span class="insert">note for all pool types: a</span> single thread may not be able to allocate <span class="insert">a</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> from the pool at any particular time, as <span class="delete">other threads or hardware</span></td><td> </td><td class="rblock"><span class="insert">ll</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * blocks</span> are allowed to <span class="delete">keep</span> some for caching purposes.</td><td> </td><td class="rblock"><span class="insert"> *</span> 'num' elements from the pool at any particular time, as <span class="insert">implementations</span> </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">are</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> allowed to <span class="insert">store</span> some <span class="insert">elements (per thread and HW engine)</span> for caching</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> purposes.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pool_param_t {</td><td> </td><td class="right">typedef struct odp_pool_param_t {</td></tr>
      <tr><td class="left">       /** Pool type */</td><td> </td><td class="right">       /** Pool type */</td></tr>
      <tr><td class="left">       int type;</td><td> </td><td class="right">       int type;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">Variant parameters for different pool types */</span></td><td> </td><td class="rblock">       /** Parameters for buffer pools */</td></tr>
      <tr><td class="lblock"><span class="delete">       union {</span></td><td> </td><td class="rblock">       struct {</td></tr>
      <tr><td class="lblock"><span class="delete">               /**</span> Parameters for buffer pools */</td><td> </td><td class="rblock">               /** Number of buffers in the pool */</td></tr>
      <tr><td class="lblock">               struct {</td><td> </td><td class="rblock">               uint32_t num;</td></tr>
      <tr><td class="lblock">                       /** Number of buffers in the pool */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                       uint32_t num;</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock">                       /** Buffer size in bytes. The maximum number of <span class="delete">byte</span></td><td> </td><td class="rblock">               /** Buffer size in bytes. The maximum number of <span class="insert">bytes</span></td></tr>
      <tr><td class="lblock"><span class="delete">s</span></td><td> </td><td class="rblock"><span class="insert">                *</span>  application will store in each buffer.</td></tr>
      <tr><td class="lblock">                           application will store in each buffer. */</td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock">                       uint32_t size;</td><td> </td><td class="rblock">               uint32_t size;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock">                       /** Minimum buffer alignment in bytes. Valid values </td><td> </td><td class="rblock">               /** Minimum buffer alignment in bytes. Valid values are</td></tr>
      <tr><td class="lblock">are</td><td> </td><td class="rblock">                <span class="insert">*</span>  powers of two. Use 0 for default alignment.</td></tr>
      <tr><td class="lblock">                           powers of two. Use 0 for default alignment.</td><td> </td><td class="rblock">                <span class="insert">*</span>  Default will always be a multiple of 8.</td></tr>
      <tr><td class="lblock">                           Default will always be a multiple of 8. */</td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock">                       uint32_t align;</td><td> </td><td class="rblock">               uint32_t align;</td></tr>
      <tr><td class="lblock">               } buf;</td><td> </td><td class="rblock">       } buf;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock">               /** Parameters for packet pools */</td><td> </td><td class="rblock">       /** Parameters for packet pools */</td></tr>
      <tr><td class="lblock">               struct {</td><td> </td><td class="rblock">       struct {</td></tr>
      <tr><td class="lblock">                       /** <span class="delete">The</span> number of <span class="delete">packets that the</span> pool must <span class="delete">provide</span></td><td> </td><td class="rblock">               /** <span class="insert">Minimum</span> number of <span class="insert">'len' byte packets.</span></td></tr>
      <tr><td class="lblock">                           that <span class="delete">are packet length</span> 'len' bytes or smaller.</td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock">                           The maximum value is defined by pool capability</td><td> </td><td class="rblock"><span class="insert">                *  The</span> pool must <span class="insert">contain at least this many packets</span> that <span class="insert">ar</span></td></tr>
      <tr><td class="lblock">                           pkt.max_num. */</td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock">                       uint32_t num;</td><td> </td><td class="rblock"><span class="insert">                *</span>  'len' bytes or smaller. <span class="insert">An implementation may round up t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  value, as long as the 'max_num' parameter below is not</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  violated.</span> The maximum value <span class="insert">for this field</span> is defined by</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                <span class="insert">*</span>  pool capability pkt.max_num.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               uint32_t num;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock">                       /** <span class="delete">Minimum packet length that the pool must provide</span></td><td> </td><td class="rblock">               /** <span class="insert">Maximum number of</span> packets.</td></tr>
      <tr><td class="lblock"><span class="delete">                           'num'</span> packets. <span class="delete">The</span> number of packets <span class="delete">may</span> be <span class="delete">less</span></td><td> </td><td class="rblock">                <span class="insert">*</span></td></tr>
      <tr><td class="lblock"><span class="delete">                           than 'num' when packets are larger than 'len'.</span></td><td> </td><td class="rblock"><span class="insert">                *  This is the maximum</span> number of packets <span class="insert">of any length that</span></td></tr>
      <tr><td class="lblock">                           The maximum value is defined by pool capability</td><td> </td><td class="rblock"><span class="insert"> can</span></td></tr>
      <tr><td class="lblock">                           <span class="delete">pkt.max_len.</span> Use 0 for <span class="delete">default.</span> */</td><td> </td><td class="rblock"><span class="insert">                *</span>  be <span class="insert">allocated from the pool.</span> The maximum value is defined</td></tr>
      <tr><td class="lblock">                       uint32_t <span class="delete">len;</span></td><td> </td><td class="rblock"> by</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                <span class="insert">*</span>  pool capability <span class="insert">pkt.max_num.</span> Use 0 <span class="insert">when there's no</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  requirement</span> for <span class="insert">the maximum number of packets. The defau</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  value is 0.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               uint32_t <span class="insert">max_num;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">                       /** <span class="delete">Maximum</span> packet length <span class="delete">that will be allocated fro</span></td><td> </td><td class="rblock">               /** <span class="insert">Minimum length of 'num' packets.</span></td></tr>
      <tr><td class="lblock"><span class="delete">m</span></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"><span class="delete">                           the pool.</span> The maximum value is defined by pool</td><td> </td><td class="rblock"><span class="insert">                *  The pool must contain at least 'num' packets up to this</span></td></tr>
      <tr><td class="lblock">                           capability pkt.max_len. Use 0 for <span class="delete">default (the</span></td><td> </td><td class="rblock"><span class="insert">                *</span>  packet length <span class="insert">(1 ... 'len' bytes).</span> The maximum value <span class="insert">for</span></td></tr>
      <tr><td class="lblock"><span class="delete">                           pool maximum).</span> */</td><td> </td><td class="rblock"><span class="insert">                *  this field</span> is defined by pool capability pkt.max_len.</td></tr>
      <tr><td class="lblock">                       uint32_t <span class="delete">max_len;</span></td><td> </td><td class="rblock">                <span class="insert">*</span>  Use 0 for <span class="insert">default.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               uint32_t <span class="insert">len;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock">                       /** <span class="delete">Minimum number of</span> packet <span class="delete">data bytes</span> that <span class="delete">are sto</span></td><td> </td><td class="rblock">               /** <span class="insert">Maximum</span> packet <span class="insert">length</span> that <span class="insert">will be allocated from</span></td></tr>
      <tr><td class="lblock"><span class="delete">red</span></td><td> </td><td class="rblock"><span class="insert">                *</span>  the <span class="insert">pool.</span> The maximum <span class="insert">value</span> is defined by pool <span class="insert">capabilit</span></td></tr>
      <tr><td class="lblock"><span class="delete">                           in</span> the <span class="delete">first segment of a packet.</span> The maximum <span class="delete">va</span></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"><span class="delete">lue</span></td><td> </td><td class="rblock"><span class="insert">                *  pkt.max_len.</span> Use 0 for <span class="insert">default (the pool maximum).</span></td></tr>
      <tr><td class="lblock">                           is defined by pool <span class="delete">capability pkt.max_seg_len.</span></td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock">                           Use 0 for <span class="delete">default.</span> */</td><td> </td><td class="rblock">               uint32_t <span class="insert">max_len;</span></td></tr>
      <tr><td class="lblock">                       uint32_t <span class="delete">seg_len;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock">                       /** User area size in bytes. The maximum value is</td><td> </td><td class="rblock">               /** <span class="insert">Minimum number of packet data bytes that are stored in t</span></td></tr>
      <tr><td class="lblock">                           defined by pool capability pkt.max_uarea_size.</td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock">                           Specify as 0 if no <span class="delete">user</span> area is needed. */</td><td> </td><td class="rblock"><span class="insert">                *  first segment of a packet. The maximum value is defined </span></td></tr>
      <tr><td class="lblock">                       uint32_t uarea_size;</td><td> </td><td class="rblock"><span class="insert">by</span></td></tr>
      <tr><td class="lblock">               } pkt;</td><td> </td><td class="rblock"><span class="insert">                *  pool capability pkt.max_seg_len. Use 0 for default.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t seg_len;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /**</span> User area size in bytes. The maximum value is defined by</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                <span class="insert">*</span>  pool capability pkt.max_uarea_size. Specify as 0 if no <span class="insert">u</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ser</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span>  area is needed.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               uint32_t uarea_size;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** Minimum headroom size in bytes. Each newly allocated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  packet from the pool must have at least this much headro</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">om.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  The maximum value is defined by pool capability</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  pkt.max_headroom. Use zero if headroom is not needed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t headroom;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Number of subparameters</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  The number of subparameter table entries used. The maxim</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">um</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  value is defined by pool capability pkt.max_num_subparam</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  The default value is 0.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint8_t num_subparam;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Subparameter table</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  Subparameters continue pool configuration with additiona</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  packet length requirements. The first table entry follow</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  the num/len specification above. So that, sub[0].len &gt; '</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">len'</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  and sub[0].num refers to packet lengths between 'len' + </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  and sub[0].len. Similarly, sub[1] follows sub[0]</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  specification, and so on.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  Each requirement is supported separately and may be roun</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ded</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  up, as long as the 'max_num' parameter is not violated. </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">It's</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  implementation specific if some requirements are support</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  simultaneously (e.g. due to subpool design).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               odp_pool_pkt_subparam_t sub[ODP_POOL_MAX_SUBPARAMS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       } pkt;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Parameters for timeout pools */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Number of timeouts in the pool */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t num;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } tmo;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock">               <span class="delete">/** Parameters for timeout pools */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               struct {</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                       /** Number of timeouts in the pool */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                       uint32_t num;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               } tmo;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       };</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">} odp_pool_param_t;</td><td> </td><td class="right">} odp_pool_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Packet pool*/</td><td> </td><td class="right">/** Packet pool*/</td></tr>
      <tr><td class="left">#define ODP_POOL_PACKET       ODP_EVENT_PACKET</td><td> </td><td class="right">#define ODP_POOL_PACKET       ODP_EVENT_PACKET</td></tr>
      <tr><td class="left">/** Buffer pool */</td><td> </td><td class="right">/** Buffer pool */</td></tr>
      <tr><td class="left">#define ODP_POOL_BUFFER       ODP_EVENT_BUFFER</td><td> </td><td class="right">#define ODP_POOL_BUFFER       ODP_EVENT_BUFFER</td></tr>
      <tr><td class="left">/** Timeout pool */</td><td> </td><td class="right">/** Timeout pool */</td></tr>
      <tr><td class="left">#define ODP_POOL_TIMEOUT      ODP_EVENT_TIMEOUT</td><td> </td><td class="right">#define ODP_POOL_TIMEOUT      ODP_EVENT_TIMEOUT</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 280</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 357</em></th></tr>
      <tr><td class="left"> * @return Handle of the first matching pool</td><td> </td><td class="right"> * @return Handle of the first matching pool</td></tr>
      <tr><td class="left"> * @retval ODP_POOL_INVALID  Pool could not be found</td><td> </td><td class="right"> * @retval ODP_POOL_INVALID  Pool could not be found</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pool_t odp_pool_lookup(const char *name);</td><td> </td><td class="right">odp_pool_t odp_pool_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Pool information struct</td><td> </td><td class="right"> * Pool information struct</td></tr>
      <tr><td class="left"> * Used to get information about a pool.</td><td> </td><td class="right"> * Used to get information about a pool.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pool_info_t {</td><td> </td><td class="right">typedef struct odp_pool_info_t {</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock">       const char *name;          <span class="delete">/**&lt;</span> pool <span class="delete">name</span> */</td><td> </td><td class="rblock">       <span class="insert">/** Pool name */</span></td></tr>
      <tr><td class="lblock">       odp_pool_param_t params;   <span class="delete">/**&lt;</span> pool <span class="delete">parameters</span> */</td><td> </td><td class="rblock">       const char *name;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Copy of</span> pool <span class="insert">parameters</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       odp_pool_param_t params;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Additional info for packet pools */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of packets of any length</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  This is the maximum number of packets that can be alloca</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ted</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  from the</span> pool <span class="insert">at anytime. Application can use this e.g.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *  to prepare enough per packet contexts.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_num;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Minimum data address.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  This is the minimum address that application accessible</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  data of any object (event) allocated from the pool may</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  locate. When there's no application accessible data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  (e.g. ODP_POOL_TIMEOUT pools), the value may be zero.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uintptr_t min_data_addr;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum data address.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  This is the maximum address that application accessible</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  data of any object (event) allocated from the pool may</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  locate. When there's no application accessible data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  (e.g. ODP_POOL_TIMEOUT pools), the value may be zero.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">uintptr_t max_data_addr;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">} odp_pool_info_t;</td><td> </td><td class="right">} odp_pool_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Retrieve information about a pool</td><td> </td><td class="right"> * Retrieve information about a pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pool         Pool handle</td><td> </td><td class="right"> * @param pool         Pool handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[out] info    Receives an odp_pool_info_t object</td><td> </td><td class="right"> * @param[out] info    Receives an odp_pool_info_t object</td></tr>
      <tr><td class="left"> *                     that describes the pool.</td><td> </td><td class="right"> *                     that describes the pool.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 15 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>59 lines changed or deleted</i></th><th><i> </i></th><th><i>188 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;queue.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;queue.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 99</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 99</em></th></tr>
      <tr><td class="left">         * An attempt to enqueue/dequeue directly will result undefined</td><td> </td><td class="right">         * An attempt to enqueue/dequeue directly will result undefined</td></tr>
      <tr><td class="left">         * behaviour. Various ODP functions (e.g. packet input, timer,</td><td> </td><td class="right">         * behaviour. Various ODP functions (e.g. packet input, timer,</td></tr>
      <tr><td class="left">         * crypto, scheduler, etc) are able to perform enqueue or</td><td> </td><td class="right">         * crypto, scheduler, etc) are able to perform enqueue or</td></tr>
      <tr><td class="left">         * dequeue operations normally on the queue.</td><td> </td><td class="right">         * dequeue operations normally on the queue.</td></tr>
      <tr><td class="left">         * */</td><td> </td><td class="right">         * */</td></tr>
      <tr><td class="left">       ODP_QUEUE_OP_DISABLED</td><td> </td><td class="right">       ODP_QUEUE_OP_DISABLED</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_queue_op_mode_t;</td><td> </td><td class="right">} odp_queue_op_mode_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Non-blocking level</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A non-blocking level defines implementation guarantees for application</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * progress when multiple threads operate on the same resource (e.g. a queu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * simultaneously. The first level (ODP_BLOCKING) does not have any block</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * freedom guarantees, but a suspending thread may block the other threads </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the entire time it remains suspended (infinitely if crashed).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * On the contrary, actual non-blocking levels provide guarantees of progre</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ss:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_NONBLOCKING_LF:  A non-blocking and lock-free implementation guarant</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ees</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      that at least one of the threads successfully compl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">etes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      its operations, regardless of what other threads do</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Application progress is guaranteed, but individual</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      threads may starve while trying to execute their</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      operations on the shared resource.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_NONBLOCKING_WF:  A non-blocking and wait-free implementation guarant</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ees</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      application progress with starvation freedom. All</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      threads are guaranteed to complete their operations</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      a bounded number of steps, regardless of what other</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      threads do.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Non-blocking levels are listed from the weakest to the strongest guarant</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ee of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * block freedom. Performance of a non-blocking implementation may be lower</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the blocking one. Non-blocking guarantees are important e.g. for real-ti</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">me</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * applications when real-time and non real-time threads share a resource.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum odp_nonblocking_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Blocking implementation. A suspeding thread may block all other</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  threads, i.e. no block freedom guarantees. This is the lowest le</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">vel.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_BLOCKING = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Non-blocking and lock-free implementation. Other threads can mak</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  progress while a thread is suspended. Starvation freedom is not</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  guaranteed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_NONBLOCKING_LF,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Non-blocking and wait-free implementation. Other threads can mak</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  progress while a thread is suspended. Starvation freedom is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  guaranteed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_NONBLOCKING_WF</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_nonblocking_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Queue capabilities</td><td> </td><td class="right"> * Queue capabilities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_queue_capability_t {</td><td> </td><td class="right">typedef struct odp_queue_capability_t {</td></tr>
      <tr><td class="left">       /** Maximum number of event queues of any type (default size). Use</td><td> </td><td class="right">       /** Maximum number of event queues of any type (default size). Use</td></tr>
      <tr><td class="left">         * this in addition to queue type specific 'max_num', if both queue</td><td> </td><td class="right">         * this in addition to queue type specific 'max_num', if both queue</td></tr>
      <tr><td class="left">         * types are used simultaneously. */</td><td> </td><td class="right">         * types are used simultaneously. */</td></tr>
      <tr><td class="left">       uint32_t max_queues;</td><td> </td><td class="right">       uint32_t max_queues;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Maximum number of ordered locks per queue */</td><td> </td><td class="right">       /** Maximum number of ordered locks per queue */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">       u<span class="delete">nsigned</span> max_ordered_locks;</td><td> </td><td class="rblock">       u<span class="insert">int32_t</span> max_ordered_locks;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Maximum number of scheduling groups */</td><td> </td><td class="right">       /** Maximum number of scheduling groups */</td></tr>
      <tr><td class="left">       unsigned max_sched_groups;</td><td> </td><td class="right">       unsigned max_sched_groups;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Number of scheduling priorities */</td><td> </td><td class="right">       /** Number of scheduling priorities */</td></tr>
      <tr><td class="left">       unsigned sched_prios;</td><td> </td><td class="right">       unsigned sched_prios;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Plain queue capabilities */</td><td> </td><td class="right">       /** Plain queue capabilities */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Maximum number of plain queues of the default size. */</td><td> </td><td class="right">               /** Maximum number of plain queues of the default size. */</td></tr>
      <tr><td class="left">               uint32_t max_num;</td><td> </td><td class="right">               uint32_t max_num;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Maximum number of events a plain queue can store</td><td> </td><td class="right">               /** Maximum number of events a plain queue can store</td></tr>
      <tr><td class="left">                 * simultaneously. The value of zero means that plain</td><td> </td><td class="right">                 * simultaneously. The value of zero means that plain</td></tr>
      <tr><td class="left">                 * queues do not have a size limit, but a single queue can</td><td> </td><td class="right">                 * queues do not have a size limit, but a single queue can</td></tr>
      <tr><td class="left">                 * store all available events. */</td><td> </td><td class="right">                 * store all available events. */</td></tr>
      <tr><td class="left">               uint32_t max_size;</td><td> </td><td class="right">               uint32_t max_size;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** The strongest guarantee of block freedom that is support</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                 * for plain queues. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               odp_nonblocking_t nonblocking;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       } plain;</td><td> </td><td class="right">       } plain;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Scheduled queue capabilities */</td><td> </td><td class="right">       /** Scheduled queue capabilities */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Maximum number of scheduled queues of the default size. 
*/</td><td> </td><td class="right">               /** Maximum number of scheduled queues of the default size. 
*/</td></tr>
      <tr><td class="left">               uint32_t max_num;</td><td> </td><td class="right">               uint32_t max_num;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">               /** Maximum number of events a scheduled queue can store</td><td> </td><td class="right">               /** Maximum number of events a scheduled queue can store</td></tr>
      <tr><td class="left">                 * simultaneously. The value of zero means that scheduled</td><td> </td><td class="right">                 * simultaneously. The value of zero means that scheduled</td></tr>
      <tr><td class="left">                 * queues do not have a size limit, but a single queue can</td><td> </td><td class="right">                 * queues do not have a size limit, but a single queue can</td></tr>
      <tr><td class="left">                 * store all available events. */</td><td> </td><td class="right">                 * store all available events. */</td></tr>
      <tr><td class="left">               uint32_t max_size;</td><td> </td><td class="right">               uint32_t max_size;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">               <span class="insert">/** The strongest guarantee of block freedom that is support</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                 * for scheduled queues. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               odp_nonblocking_t nonblocking;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       } sched;</td><td> </td><td class="right">       } sched;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_queue_capability_t;</td><td> </td><td class="right">} odp_queue_capability_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ODP Queue parameters</td><td> </td><td class="right"> * ODP Queue parameters</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_queue_param_t {</td><td> </td><td class="right">typedef struct odp_queue_param_t {</td></tr>
      <tr><td class="left">       /** Queue type</td><td> </td><td class="right">       /** Queue type</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 180</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 236</em></th></tr>
      <tr><td class="left">         * For SCHED queues, the parameter is ignored in queue creation and</td><td> </td><td class="right">         * For SCHED queues, the parameter is ignored in queue creation and</td></tr>
      <tr><td class="left">         * the value is ODP_QUEUE_OP_DISABLED. */</td><td> </td><td class="right">         * the value is ODP_QUEUE_OP_DISABLED. */</td></tr>
      <tr><td class="left">       odp_queue_op_mode_t deq_mode;</td><td> </td><td class="right">       odp_queue_op_mode_t deq_mode;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Scheduler parameters</td><td> </td><td class="right">       /** Scheduler parameters</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * These parameters are considered only when queue type is</td><td> </td><td class="right">         * These parameters are considered only when queue type is</td></tr>
      <tr><td class="left">         * ODP_QUEUE_TYPE_SCHED. */</td><td> </td><td class="right">         * ODP_QUEUE_TYPE_SCHED. */</td></tr>
      <tr><td class="left">       odp_schedule_param_t sched;</td><td> </td><td class="right">       odp_schedule_param_t sched;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Non-blocking level</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * Queue implementation must guarantee at least this level of block</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * freedom for queue enqueue and dequeue/schedule operations.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * The default value is ODP_BLOCKING. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_nonblocking_t nonblocking;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** Queue context pointer</td><td> </td><td class="right">       /** Queue context pointer</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * User defined context pointer associated with the queue. The same</td><td> </td><td class="right">         * User defined context pointer associated with the queue. The same</td></tr>
      <tr><td class="left">         * pointer can be accessed with odp_queue_context() and</td><td> </td><td class="right">         * pointer can be accessed with odp_queue_context() and</td></tr>
      <tr><td class="left">         * odp_queue_context_set() calls. The implementation may read the</td><td> </td><td class="right">         * odp_queue_context_set() calls. The implementation may read the</td></tr>
      <tr><td class="left">         * pointer for prefetching the context data. Default value of the</td><td> </td><td class="right">         * pointer for prefetching the context data. Default value of the</td></tr>
      <tr><td class="left">         * pointer is NULL. */</td><td> </td><td class="right">         * pointer is NULL. */</td></tr>
      <tr><td class="left">       void *context;</td><td> </td><td class="right">       void *context;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Queue context data length</td><td> </td><td class="right">       /** Queue context data length</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 311</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 374</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Enqueue multiple events to a queue</td><td> </td><td class="right"> * Enqueue multiple events to a queue</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Enqueue the events from 'events[]' on 'queue'. A successful call returns
 the</td><td> </td><td class="right"> * Enqueue the events from 'events[]' on 'queue'. A successful call returns
 the</td></tr>
      <tr><td class="left"> * actual number of events enqueued. If return value is less than 'num', th
e</td><td> </td><td class="right"> * actual number of events enqueued. If return value is less than 'num', th
e</td></tr>
      <tr><td class="left"> * remaining events at the end of events[] are not consumed, and the caller</td><td> </td><td class="right"> * remaining events at the end of events[] are not consumed, and the caller</td></tr>
      <tr><td class="left"> * has to take care of them.</td><td> </td><td class="right"> * has to take care of them.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param queue   Queue handle</td><td> </td><td class="right"> * @param queue   Queue handle</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in] events</span> Array of event handles</td><td> </td><td class="rblock"> * @param<span class="insert"> events </span> Array of event handles</td></tr>
      <tr><td class="left"> * @param num     Number of event handles to enqueue</td><td> </td><td class="right"> * @param num     Number of event handles to enqueue</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Number of events actually enqueued (0 ... num)</td><td> </td><td class="right"> * @return Number of events actually enqueued (0 ... num)</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_queue_enq_multi(odp_queue_t queue, const odp_event_t events[], int 
num);</td><td> </td><td class="right">int odp_queue_enq_multi(odp_queue_t queue, const odp_event_t events[], int 
num);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Queue dequeue</td><td> </td><td class="right"> * Queue dequeue</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 395</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 458</em></th></tr>
      <tr><td class="left">odp_schedule_group_t odp_queue_sched_group(odp_queue_t queue);</td><td> </td><td class="right">odp_schedule_group_t odp_queue_sched_group(odp_queue_t queue);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Queue lock count</td><td> </td><td class="right"> * Queue lock count</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Return number of ordered locks associated with this ordered queue.</td><td> </td><td class="right"> * Return number of ordered locks associated with this ordered queue.</td></tr>
      <tr><td class="left"> * Lock count is defined in odp_schedule_param_t.</td><td> </td><td class="right"> * Lock count is defined in odp_schedule_param_t.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param queue   Queue handle</td><td> </td><td class="right"> * @param queue   Queue handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"> * @return Number of ordered locks associated with this ordered queue</td><td> </td><td class="rblock"> * @return     Number of ordered locks associated with this ordered queue</td></tr>
      <tr><td class="lblock"> * @retval <span class="delete">&lt;0</span> Specified queue is not ordered</td><td> </td><td class="rblock"> * @retval <span class="insert">0</span>   Specified queue is not ordered <span class="insert">or no ordered lock associated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *             with the ordered queue.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"><span class="delete">in</span>t odp_queue_lock_count(odp_queue_t queue);</td><td> </td><td class="rblock"><span class="insert">uint32_</span>t odp_queue_lock_count(odp_queue_t queue);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get printable value for an odp_queue_t</td><td> </td><td class="right"> * Get printable value for an odp_queue_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param hdl  odp_queue_t handle to be printed</td><td> </td><td class="right"> * @param hdl  odp_queue_t handle to be printed</td></tr>
      <tr><td class="left"> * @return     uint64_t value that can be used to print/display this</td><td> </td><td class="right"> * @return     uint64_t value that can be used to print/display this</td></tr>
      <tr><td class="left"> *             handle</td><td> </td><td class="right"> *             handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note This routine is intended to be used for diagnostic purposes</td><td> </td><td class="right"> * @note This routine is intended to be used for diagnostic purposes</td></tr>
      <tr><td class="left"> * to enable applications to generate a printable value that represents</td><td> </td><td class="right"> * to enable applications to generate a printable value that represents</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 8 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>5 lines changed or deleted</i></th><th><i> </i></th><th><i>85 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;schedule.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;schedule.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 349</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 349</em></th></tr>
      <tr><td class="left"> * called outside of an ordered context or with a lock_index that exceeds t
he</td><td> </td><td class="right"> * called outside of an ordered context or with a lock_index that exceeds t
he</td></tr>
      <tr><td class="left"> * number of available ordered locks in this context results are undefined.</td><td> </td><td class="right"> * number of available ordered locks in this context results are undefined.</td></tr>
      <tr><td class="left"> * The number of ordered locks associated with a given ordered queue may be</td><td> </td><td class="right"> * The number of ordered locks associated with a given ordered queue may be</td></tr>
      <tr><td class="left"> * queried by the odp_queue_lock_count() API.</td><td> </td><td class="right"> * queried by the odp_queue_lock_count() API.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Each ordered lock may be used only once per ordered context. If events</td><td> </td><td class="right"> * Each ordered lock may be used only once per ordered context. If events</td></tr>
      <tr><td class="left"> * are to be processed with multiple ordered critical sections, each should</td><td> </td><td class="right"> * are to be processed with multiple ordered critical sections, each should</td></tr>
      <tr><td class="left"> * be protected by its own ordered lock. This promotes maximum parallelism 
by</td><td> </td><td class="right"> * be protected by its own ordered lock. This promotes maximum parallelism 
by</td></tr>
      <tr><td class="left"> * allowing order to maintained on a more granular basis. If an ordered loc
k</td><td> </td><td class="right"> * allowing order to maintained on a more granular basis. If an ordered loc
k</td></tr>
      <tr><td class="left"> * is used multiple times in the same ordered context results are undefined
.</td><td> </td><td class="right"> * is used multiple times in the same ordered context results are undefined
.</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Only one ordered lock can be active in an ordered context at any given t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ime.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Results are undefined when multiple ordered locks are acquired in nested</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * fashion within the same ordered context.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param lock_index Index of the ordered lock in the current context to be</td><td> </td><td class="right"> * @param lock_index Index of the ordered lock in the current context to be</td></tr>
      <tr><td class="left"> *                   acquired. Must be in the range 0..odp_queue_lock_count
()</td><td> </td><td class="right"> *                   acquired. Must be in the range 0..odp_queue_lock_count
()</td></tr>
      <tr><td class="left"> *                   - 1</td><td> </td><td class="right"> *                   - 1</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">void odp_schedule_order_lock(u<span class="delete">nsigned</span> lock_index);</td><td> </td><td class="rblock">void odp_schedule_order_lock(u<span class="insert">int32_t</span> lock_index);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Release ordered context lock</td><td> </td><td class="right"> * Release ordered context lock</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This call is valid only when holding an ordered synchronization context.</td><td> </td><td class="right"> * This call is valid only when holding an ordered synchronization context.</td></tr>
      <tr><td class="left"> * Release a previously locked ordered context lock.</td><td> </td><td class="right"> * Release a previously locked ordered context lock.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param lock_index Index of the ordered lock in the current context to be</td><td> </td><td class="right"> * @param lock_index Index of the ordered lock in the current context to be</td></tr>
      <tr><td class="left"> *                   released. Results are undefined if the caller does not</td><td> </td><td class="right"> *                   released. Results are undefined if the caller does not</td></tr>
      <tr><td class="left"> *                   hold this lock. Must be in the range</td><td> </td><td class="right"> *                   hold this lock. Must be in the range</td></tr>
      <tr><td class="left"> *                   0..odp_queue_lock_count() - 1</td><td> </td><td class="right"> *                   0..odp_queue_lock_count() - 1</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">void <span class="delete">odp_schedule_order_unlock(unsigned</span> lock_index);</td><td> </td><td class="rblock">void <span class="insert">odp_schedule_order_unlock(uint32_t</span> lock_index);</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Release existing ordered context lock and acquire a new lock</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This call is valid only when holding an ordered synchronization context.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Release a previously locked ordered context lock and acquire a new order</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * context lock. The operation is equivalent to application calling first</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_schedule_order_unlock(unlock_index) and then</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_schedule_order_lock(lock_index). The same constraints apply with thi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * call as with those two.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param unlock_index Index of the acquired ordered lock in the current</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     context to be released.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param lock_index   Index of the ordered lock in the current context to </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     acquired. Must be in the range</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     0...odp_queue_lock_count() - 1.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see odp_schedule_order_lock(), odp_schedule_order_unlock()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_schedule_order_unlock_lock(uint32_t unlock_index, uint32_t lock_in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">dex);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_end.h&gt;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 3 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>31 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;schedule_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;schedule_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 149</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 149</em></th></tr>
      <tr><td class="left">       odp_schedule_sync_t  sync;</td><td> </td><td class="right">       odp_schedule_sync_t  sync;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Thread group</td><td> </td><td class="right">       /** Thread group</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * Default value is ODP_SCHED_GROUP_ALL. */</td><td> </td><td class="right">         * Default value is ODP_SCHED_GROUP_ALL. */</td></tr>
      <tr><td class="left">       odp_schedule_group_t group;</td><td> </td><td class="right">       odp_schedule_group_t group;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Ordered lock count for this queue</td><td> </td><td class="right">       /** Ordered lock count for this queue</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * Default value is 0. */</td><td> </td><td class="right">         * Default value is 0. */</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">       u<span class="delete">nsigned</span> lock_count;</td><td> </td><td class="rblock">       u<span class="insert">int32_t</span> lock_count;</td></tr>
      <tr><td class="left">} odp_schedule_param_t;</td><td> </td><td class="right">} odp_schedule_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;shared_memory.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;shared_memory.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 72</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 74</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * When set, the memory block becomes visible to other ODP instances</td><td> </td><td class="right"> * When set, the memory block becomes visible to other ODP instances</td></tr>
      <tr><td class="left"> * through odp_shm_import().</td><td> </td><td class="right"> * through odp_shm_import().</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_SHM_EXPORT         0x08</td><td> </td><td class="right">#define ODP_SHM_EXPORT         0x08</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Shared memory block info</td><td> </td><td class="right"> * Shared memory block info</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_shm_info_t {</td><td> </td><td class="right">typedef struct odp_shm_info_t {</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">       const char *name;      <span class="delete">/**&lt;</span> Block <span class="delete">name</span> */</td><td> </td><td class="rblock">       <span class="insert">/** Block name */</span></td></tr>
      <tr><td class="lblock">       void       *addr;      <span class="delete">/**&lt; Block address */</span></td><td> </td><td class="rblock">       const char *name;</td></tr>
      <tr><td class="lblock"><span class="delete">       uint64_t    size;      /**&lt;</span> Block size in bytes */</td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock">       uint64_t    <span class="delete">page_size; /**&lt;</span> Memory page size */</td><td> </td><td class="rblock">       <span class="insert">/**</span> Block <span class="insert">address</span> */</td></tr>
      <tr><td class="lblock">       <span class="delete">uint32_t    flags;     /**&lt;</span> ODP_SHM_* flags */</td><td> </td><td class="rblock">       void       *addr;</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/**</span> Block size in bytes */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       uint64_t    <span class="insert">size;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /**</span> Memory page size */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">uint64_t    page_size;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /**</span> ODP_SHM_* flags */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">uint32_t    flags;</span></td></tr>
      <tr><td class="left">} odp_shm_info_t;</td><td> </td><td class="right">} odp_shm_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Shared memory capabilities</td><td> </td><td class="right"> * Shared memory capabilities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_shm_capability_t {</td><td> </td><td class="right">typedef struct odp_shm_capability_t {</td></tr>
      <tr><td class="left">       /** Maximum number of shared memory blocks</td><td> </td><td class="right">       /** Maximum number of shared memory blocks</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        * This number of separate shared memory blocks can be</td><td> </td><td class="right">        * This number of separate shared memory blocks can be</td></tr>
      <tr><td class="left">        * reserved concurrently. */</td><td> </td><td class="right">        * reserved concurrently. */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 118</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 129</em></th></tr>
      <tr><td class="left"> * @param[out] capa   Pointer to capability structure for output</td><td> </td><td class="right"> * @param[out] capa   Pointer to capability structure for output</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_shm_capability(odp_shm_capability_t *capa);</td><td> </td><td class="right">int odp_shm_capability(odp_shm_capability_t *capa);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Reserve a contiguous block of shared memory</td><td> </td><td class="right"> * Reserve a contiguous block of shared memory</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name   Name of the block <span class="delete">(maximum ODP_SHM_NAME_LEN - 1 chars)</span></td><td> </td><td class="rblock"> * <span class="insert">Reserve a contiguous block of shared memory that fulfills size, alignmen</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> size   Block size in bytes</td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> align  Block alignment in bytes</td><td> </td><td class="rblock"><span class="insert"> * and shareability (ODP_SHM_* flags) requirements. In general, a name is</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> flags  Shared memory parameter flags (ODP_SHM_*).</td><td> </td><td class="rblock"><span class="insert"> * optional and does not need to be unique. However, if the block will be</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                   Default value <span class="delete">is</span> 0.</td><td> </td><td class="rblock"><span class="insert"> * searched with odp_shm_lookup() or odp_shm_import(), a unique name is nee</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ded</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * for correct match.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param</span> name   Name of the block <span class="insert">or NULL. Maximum string length is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *               ODP_SHM_NAME_LEN.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">@param</span> size   Block size in bytes</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">@param</span> align  Block alignment in bytes</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">@param</span> flags  Shared memory parameter flags (ODP_SHM_*). Default value <span class="insert">i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span> 0.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Handle of the reserved block</td><td> </td><td class="right"> * @return Handle of the reserved block</td></tr>
      <tr><td class="left"> * @retval ODP_SHM_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_SHM_INVALID on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_shm_t odp_shm_reserve(const char *name, uint64_t size, uint64_t align,</td><td> </td><td class="right">odp_shm_t odp_shm_reserve(const char *name, uint64_t size, uint64_t align,</td></tr>
      <tr><td class="left">                         uint32_t flags);</td><td> </td><td class="right">                         uint32_t flags);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Free a contiguous block of shared memory</td><td> </td><td class="right"> * Free a contiguous block of shared memory</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"> * Frees a previously reserved block of shared memory.</td><td> </td><td class="rblock"> * Frees a previously reserved block of shared memory. Freeing memory that </td></tr>
      <tr><td class="lblock"> <span class="delete">* @note</span> Freeing memory that is in use will result in UNDEFINED behavior</td><td> </td><td class="rblock">is</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span> in use will result in UNDEFINED behavior</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in] shm</span> Block handle</td><td> </td><td class="rblock"> * @param<span class="insert"> shm   </span> Block handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_shm_free(odp_shm_t shm);</td><td> </td><td class="right">int odp_shm_free(odp_shm_t shm);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Lookup for a block of shared memory</td><td> </td><td class="right"> * Lookup for a block of shared memory</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span> name   Name of the block</td><td> </td><td class="rblock"> * @param name   Name of the block</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return A handle to the block if it is found by name</td><td> </td><td class="right"> * @return A handle to the block if it is found by name</td></tr>
      <tr><td class="left"> * @retval ODP_SHM_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_SHM_INVALID on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_shm_t odp_shm_lookup(const char *name);</td><td> </td><td class="right">odp_shm_t odp_shm_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Import a block of shared memory, exported by another ODP instance</td><td> </td><td class="right"> * Import a block of shared memory, exported by another ODP instance</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This call creates a new handle for accessing a shared memory block creat
ed</td><td> </td><td class="right"> * This call creates a new handle for accessing a shared memory block creat
ed</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 179</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 196</em></th></tr>
      <tr><td class="left"> * @return A handle to access a block exported by another ODP instance.</td><td> </td><td class="right"> * @return A handle to access a block exported by another ODP instance.</td></tr>
      <tr><td class="left"> * @retval ODP_SHM_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_SHM_INVALID on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_shm_t odp_shm_import(const char *remote_name,</td><td> </td><td class="right">odp_shm_t odp_shm_import(const char *remote_name,</td></tr>
      <tr><td class="left">                        odp_instance_t odp_inst,</td><td> </td><td class="right">                        odp_instance_t odp_inst,</td></tr>
      <tr><td class="left">                        const char *local_name);</td><td> </td><td class="right">                        const char *local_name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Shared memory block address</td><td> </td><td class="right"> * Shared memory block address</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in] shm</span>   Block handle</td><td> </td><td class="rblock"> * @param<span class="insert"> shm </span>   Block handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Memory block address</td><td> </td><td class="right"> * @return Memory block address</td></tr>
      <tr><td class="left"> * @retval NULL on failure</td><td> </td><td class="right"> * @retval NULL on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_shm_addr(odp_shm_t shm);</td><td> </td><td class="right">void *odp_shm_addr(odp_shm_t shm);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Shared memory block info</td><td> </td><td class="right"> * Shared memory block info</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"> <span class="delete">* @note This is the only shared memory API function which accepts invalid</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * shm handles (any bit value) without causing undefined behavior.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  shm   Block handle</td><td> </td><td class="rblock"> * <span class="insert">Get information about the specified shared memory block. This is the onl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * shared memory API function which accepts invalid shm handles (any bit va</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lue)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * without causing undefined behavior.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param</span>      shm   Block handle</td></tr>
      <tr><td class="left"> * @param[out] info  Block info pointer for output</td><td> </td><td class="right"> * @param[out] info  Block info pointer for output</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_shm_info(odp_shm_t shm, odp_shm_info_t *info);</td><td> </td><td class="right">int odp_shm_info(odp_shm_t shm, odp_shm_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Print all shared memory blocks</td><td> </td><td class="right"> * Print all shared memory blocks</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_shm_print_all(void);</td><td> </td><td class="right">void odp_shm_print_all(void);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Print shared memory block info</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Print implementation defined information about the specified shared memo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ry</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * block to the ODP log. The information is intended to be used for debuggi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ng.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param shm        Block handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_shm_print(odp_shm_t shm);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Get printable value for an odp_shm_t</td><td> </td><td class="right"> * Get printable value for an odp_shm_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param hdl  odp_shm_t handle</span> to be <span class="delete">printed</span></td><td> </td><td class="rblock"> * <span class="insert">This routine is intended</span> to be <span class="insert">used for diagnostic purposes to enable</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@return     uint64_t</span> value that <span class="delete">can be used to print/display this</span></td><td> </td><td class="rblock"> * <span class="insert">applications to generate a printable</span> value that <span class="insert">represents an odp_shm_t</span></td></tr>
      <tr><td class="lblock"> *             <span class="delete">handle</span></td><td> </td><td class="rblock"> * <span class="insert">handle.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@note This routine is intended to be used for diagnostic purposes</span></td><td> </td><td class="rblock"> * <span class="insert">@param shm    Block handle</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">to enable applications to generate a printable</span> value that <span class="delete">represents</span></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"><span class="delete"> * an odp_shm_t handle.</span></td><td> </td><td class="rblock"> <span class="insert">* @return uint64_t</span> value that <span class="insert">can be used to print this handle</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock">uint64_t odp_shm_to_u64(odp_shm_t <span class="delete">hdl</span>);</td><td> </td><td class="rblock">uint64_t odp_shm_to_u64(odp_shm_t <span class="insert">shm</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_end.h&gt;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 12 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>25 lines changed or deleted</i></th><th><i> </i></th><th><i>60 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;std_types.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;std_types.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 17</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 17</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @file</td><td> </td><td class="right"> * @file</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Standard C language types and definitions for ODP.</td><td> </td><td class="right"> * Standard C language types and definitions for ODP.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_STD_TYPES_H_</td><td> </td><td class="right">#ifndef ODP_API_STD_TYPES_H_</td></tr>
      <tr><td class="left">#define ODP_API_STD_TYPES_H_</td><td> </td><td class="right">#define ODP_API_STD_TYPES_H_</td></tr>
      <tr><td class="left">#include &lt;odp/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_begin.h&gt;</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* uint64_t, uint32_t, etc */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;stdint.h&gt;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @addtogroup odp_system ODP SYSTEM</td><td> </td><td class="right">/** @addtogroup odp_system ODP SYSTEM</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_bool_t</td><td> </td><td class="right"> * @typedef odp_bool_t</td></tr>
      <tr><td class="left"> * Use odp boolean type to have it well-defined and known size,</td><td> </td><td class="right"> * Use odp boolean type to have it well-defined and known size,</td></tr>
      <tr><td class="left"> * regardless which compiler is used as this facilities interoperability</td><td> </td><td class="right"> * regardless which compiler is used as this facilities interoperability</td></tr>
      <tr><td class="left"> * between e.g. different compilers.</td><td> </td><td class="right"> * between e.g. different compilers.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Percentage type</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Use odp_percent_t for specifying fields that are percentages. It is a fi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">xed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * point integer whose units are expressed as one-hundredth of a percent.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Hence 100% is represented as integer value 10000.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef uint32_t odp_percent_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/visibility_end.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>11 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;time.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;time.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 79</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 79</em></th></tr>
      <tr><td class="left"> * Time difference</td><td> </td><td class="right"> * Time difference</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param t2    Second time stamp</td><td> </td><td class="right"> * @param t2    Second time stamp</td></tr>
      <tr><td class="left"> * @param t1    First time stamp</td><td> </td><td class="right"> * @param t1    First time stamp</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Difference of time stamps</td><td> </td><td class="right"> * @return Difference of time stamps</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_time_t odp_time_diff(odp_time_t t2, odp_time_t t1);</td><td> </td><td class="right">odp_time_t odp_time_diff(odp_time_t t2, odp_time_t t1);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Time difference in nanoseconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param t2    Second time stamp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param t1    First time stamp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Difference of time stamps (t2 - t1) in nanoseconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint64_t odp_time_diff_ns(odp_time_t t2, odp_time_t t1);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Time sum</td><td> </td><td class="right"> * Time sum</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param t1    Time stamp</td><td> </td><td class="right"> * @param t1    Time stamp</td></tr>
      <tr><td class="left"> * @param t2    Time stamp</td><td> </td><td class="right"> * @param t2    Time stamp</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Sum of time stamps</td><td> </td><td class="right"> * @return Sum of time stamps</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_time_t odp_time_sum(odp_time_t t1, odp_time_t t2);</td><td> </td><td class="right">odp_time_t odp_time_sum(odp_time_t t1, odp_time_t t2);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>10 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;timer.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;timer.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 134</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 134</em></th></tr>
      <tr><td class="left">        *  timer pool concurrently. When non-zero, only single thread uses 
the</td><td> </td><td class="right">        *  timer pool concurrently. When non-zero, only single thread uses 
the</td></tr>
      <tr><td class="left">        *  timer pool (concurrently). */</td><td> </td><td class="right">        *  timer pool (concurrently). */</td></tr>
      <tr><td class="left">       int priv;</td><td> </td><td class="right">       int priv;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Clock source for timers */</td><td> </td><td class="right">       /** Clock source for timers */</td></tr>
      <tr><td class="left">       odp_timer_clk_src_t clk_src;</td><td> </td><td class="right">       odp_timer_clk_src_t clk_src;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_timer_pool_param_t;</td><td> </td><td class="right">} odp_timer_pool_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Timer capability</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Highest timer resolution in nanoseconds.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  This defines the highest resolution supported by a timer.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  It's the minimum valid value for 'res_ns' timer pool</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  parameter.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint64_t highest_res_ns;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_timer_capability_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Query timer capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Outputs timer capabilities on success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      clk_src  Clock source for timers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capa     Pointer to capability structure for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_timer_capability(odp_timer_clk_src_t clk_src,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                        odp_timer_capability_t *capa);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Create a timer pool</td><td> </td><td class="right"> * Create a timer pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The use of pool name is optional. Unique names are not required.</td><td> </td><td class="right"> * The use of pool name is optional. Unique names are not required.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param name       Name of the timer pool or NULL. Maximum string length 
is</td><td> </td><td class="right"> * @param name       Name of the timer pool or NULL. Maximum string length 
is</td></tr>
      <tr><td class="left"> *                   ODP_TIMER_POOL_NAME_LEN.</td><td> </td><td class="right"> *                   ODP_TIMER_POOL_NAME_LEN.</td></tr>
      <tr><td class="left"> * @param params     Timer pool parameters. The content will be copied.</td><td> </td><td class="right"> * @param params     Timer pool parameters. The content will be copied.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Timer pool handle on success</td><td> </td><td class="right"> * @return Timer pool handle on success</td></tr>
      <tr><td class="left"> * @retval ODP_TIMER_POOL_INVALID on failure and errno set</td><td> </td><td class="right"> * @retval ODP_TIMER_POOL_INVALID on failure and errno set</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>27 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;traffic_mngr.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;traffic_mngr.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 487</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 487</em></th></tr>
      <tr><td class="left">               odp_tm_egress_fcn_t egress_fcn; /**&lt; Output to user func */</td><td> </td><td class="right">               odp_tm_egress_fcn_t egress_fcn; /**&lt; Output to user func */</td></tr>
      <tr><td class="left">       };</td><td> </td><td class="right">       };</td></tr>
      <tr><td class="left">} odp_tm_egress_t;</td><td> </td><td class="right">} odp_tm_egress_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Initialize Requirements record.</td><td> </td><td class="right">/** Initialize Requirements record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * odp_tm_requirements_init() must be called to initialize any</td><td> </td><td class="right"> * odp_tm_requirements_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_requirements_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_requirements_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> * This is done to allow for vendor specific additions to this record.</td><td> </td><td class="right"> * This is done to allow for vendor specific additions to this record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> requirements  A pointer to an odp_tm_requirements_t record <span class="delete">wh</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> requirements  A pointer to an odp_tm_requirements_t record <span class="insert">which</span></td></tr>
      <tr><td class="lblock"><span class="delete">ich</span></td><td> </td><td class="rblock"> *                      is to be initialized.</td></tr>
      <tr><td class="lblock"> *                          is to be initialized.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_requirements_init(odp_tm_requirements_t *requirements);</td><td> </td><td class="right">void odp_tm_requirements_init(odp_tm_requirements_t *requirements);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Initialize Egress record.</td><td> </td><td class="right">/** Initialize Egress record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * odp_tm_egress_init() must be called to initialize any odp_tm_egress_t</td><td> </td><td class="right"> * odp_tm_egress_init() must be called to initialize any odp_tm_egress_t</td></tr>
      <tr><td class="left"> * record before it is first used or assigned to.</td><td> </td><td class="right"> * record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> * This is done to allow for vendor specific additions to this record.</td><td> </td><td class="right"> * This is done to allow for vendor specific additions to this record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> egress  A pointer to an odp_tm_egress_t record which</td><td> </td><td class="rblock"> * <span class="insert">@param</span> egress  A pointer to an odp_tm_egress_t record which</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_egress_init(odp_tm_egress_t *egress);</td><td> </td><td class="right">void odp_tm_egress_init(odp_tm_egress_t *egress);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Query All TM Capabilities</td><td> </td><td class="right">/** Query All TM Capabilities</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_capabilities() function can be used to obtain the complete se
t of</td><td> </td><td class="right"> * The odp_tm_capabilities() function can be used to obtain the complete se
t of</td></tr>
      <tr><td class="left"> * TM limits supported by this implementation.  The reason that this return
s</td><td> </td><td class="right"> * TM limits supported by this implementation.  The reason that this return
s</td></tr>
      <tr><td class="left"> * a SET of capabilities and not just one, is because it is expected that</td><td> </td><td class="right"> * a SET of capabilities and not just one, is because it is expected that</td></tr>
      <tr><td class="left"> * many HW based implementations may have one set of limits for the HW and</td><td> </td><td class="right"> * many HW based implementations may have one set of limits for the HW and</td></tr>
      <tr><td class="left"> * also support a SW TM implementation with a (presumably larger) different</td><td> </td><td class="right"> * also support a SW TM implementation with a (presumably larger) different</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 521</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 521</em></th></tr>
      <tr><td class="left"> * SW implementation (one supporting say tens of thousands of tm_queues and</td><td> </td><td class="right"> * SW implementation (one supporting say tens of thousands of tm_queues and</td></tr>
      <tr><td class="left"> * a variant supporting tens of millions of tm_queues).</td><td> </td><td class="right"> * a variant supporting tens of millions of tm_queues).</td></tr>
      <tr><td class="left"> * The caller passes in an array of odp_tm_capabilities_t records and the</td><td> </td><td class="right"> * The caller passes in an array of odp_tm_capabilities_t records and the</td></tr>
      <tr><td class="left"> * number of such records.  Then the first N of these records will be fille
d</td><td> </td><td class="right"> * number of such records.  Then the first N of these records will be fille
d</td></tr>
      <tr><td class="left"> * in by the implementation and the number N will be returned.  In the even
t</td><td> </td><td class="right"> * in by the implementation and the number N will be returned.  In the even
t</td></tr>
      <tr><td class="left"> * that N is larger than the capabilities_size, N will still be returned,</td><td> </td><td class="right"> * that N is larger than the capabilities_size, N will still be returned,</td></tr>
      <tr><td class="left"> * but only capabilities_size records will be filled in.</td><td> </td><td class="right"> * but only capabilities_size records will be filled in.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[out] capabilities      An array of odp_tm_capabilities_t records 
to</td><td> </td><td class="right"> * @param[out] capabilities      An array of odp_tm_capabilities_t records 
to</td></tr>
      <tr><td class="left"> *                               be filled in.</td><td> </td><td class="right"> *                               be filled in.</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  capabilities_size The number of odp_tm_capabilities_t record
s</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  capabilities_size The number of odp_tm_capabilities_t record
s</td></tr>
      <tr><td class="left"> *                               in the capabilities array.</td><td> </td><td class="right"> *                               in the capabilities array.</td></tr>
      <tr><td class="left"> * @return                       Returns &lt; 0 upon failure.  Returns N &gt; 0,</td><td> </td><td class="right"> * @return                       Returns &lt; 0 upon failure.  Returns N &gt; 0,</td></tr>
      <tr><td class="left"> *                               where N is the maximum number of different</td><td> </td><td class="right"> *                               where N is the maximum number of different</td></tr>
      <tr><td class="left"> *                               odp_tm_capabilities_t records that the</td><td> </td><td class="right"> *                               odp_tm_capabilities_t records that the</td></tr>
      <tr><td class="left"> *                               implementations supports. *NOTE* that this</td><td> </td><td class="right"> *                               implementations supports. *NOTE* that this</td></tr>
      <tr><td class="left"> *                               number can be &gt; capabilities_size!</td><td> </td><td class="right"> *                               number can be &gt; capabilities_size!</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_capabilities(odp_tm_capabilities_t capabilities[],</td><td> </td><td class="right">int odp_tm_capabilities(odp_tm_capabilities_t capabilities[],</td></tr>
      <tr><td class="left">                       uint32_t              capabilities_size);</td><td> </td><td class="right">                       uint32_t              capabilities_size);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Create/instantiate a TM Packet Scheduling system.</td><td> </td><td class="right">/** Create/instantiate a TM Packet Scheduling system.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name          The name to be assigned to this TM system.  <span class="delete">Can</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> name          The name to be assigned to this TM system.  <span class="insert">Cannot</span></td></tr>
      <tr><td class="lblock"><span class="delete">not</span></td><td> </td><td class="rblock"> *                      be NULL, and also must be unique amongst all <span class="insert">other</span></td></tr>
      <tr><td class="lblock"> *                          be NULL, and also must be unique amongst all <span class="delete">ot</span></td><td> </td><td class="rblock"> *                      TM system names.</td></tr>
      <tr><td class="lblock"><span class="delete">her</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> requirements  The minimum required feature set and limits <span class="insert">needed</span></td></tr>
      <tr><td class="lblock"> *                          TM system names.</td><td> </td><td class="rblock"> *                      by the ODP application.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> requirements  The minimum required feature set and limits <span class="delete">nee</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> egress        Describes the single egress "spigot" of this</td></tr>
      <tr><td class="lblock"><span class="delete">ded</span></td><td> </td><td class="rblock"> *                      TM system.</td></tr>
      <tr><td class="lblock"> *                          by the ODP application.</td><td> </td><td class="rblock"> * @return              Returns ODP_TM_INVALID upon failure, otherwise the</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> egress        Describes the single egress "spigot" of this</td><td> </td><td class="rblock"> *                      newly created TM system's odp_tm_t handle is</td></tr>
      <tr><td class="lblock"> *                          TM system.</td><td> </td><td class="rblock"> *                      returned.</td></tr>
      <tr><td class="lblock"> * @return                  Returns ODP_TM_INVALID upon failure, otherwise </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">the</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          newly created TM system's odp_tm_t handle is</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          returned.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_t odp_tm_create(const char            *name,</td><td> </td><td class="right">odp_tm_t odp_tm_create(const char            *name,</td></tr>
      <tr><td class="left">                      odp_tm_requirements_t *requirements,</td><td> </td><td class="right">                      odp_tm_requirements_t *requirements,</td></tr>
      <tr><td class="left">                      odp_tm_egress_t       *egress);</td><td> </td><td class="right">                      odp_tm_egress_t       *egress);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Find a pre-existing TM system.</td><td> </td><td class="right">/** Find a pre-existing TM system.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The  odp_tm_find() function can be</td><td> </td><td class="right"> * The  odp_tm_find() function can be</td></tr>
      <tr><td class="left"> * used either to find a TM system created previously with odp_tm_create OR</td><td> </td><td class="right"> * used either to find a TM system created previously with odp_tm_create OR</td></tr>
      <tr><td class="left"> * get the odp_tm_t of a built-in TM system - usually based on HW. In this</td><td> </td><td class="right"> * get the odp_tm_t of a built-in TM system - usually based on HW. In this</td></tr>
      <tr><td class="left"> * later case the format of the name used to refer to a specific built-in</td><td> </td><td class="right"> * later case the format of the name used to refer to a specific built-in</td></tr>
      <tr><td class="left"> * hardware TM system may be platform dependent, but in any case a name of</td><td> </td><td class="right"> * hardware TM system may be platform dependent, but in any case a name of</td></tr>
      <tr><td class="left"> * "HW_TM_%u" where the number starts at 1, can be used to find a built-in</td><td> </td><td class="right"> * "HW_TM_%u" where the number starts at 1, can be used to find a built-in</td></tr>
      <tr><td class="left"> * system independently of the best requirements match.  If name is NULL th
en</td><td> </td><td class="right"> * system independently of the best requirements match.  If name is NULL th
en</td></tr>
      <tr><td class="left"> * the existing (built-in or created by odp_tm_create) TM system that best</td><td> </td><td class="right"> * the existing (built-in or created by odp_tm_create) TM system that best</td></tr>
      <tr><td class="left"> * matches the requirements is returned.</td><td> </td><td class="right"> * matches the requirements is returned.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name          If NULL then only uses the requirements <span class="delete">paramet</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> name          If NULL then only uses the requirements <span class="insert">parameter t</span></td></tr>
      <tr><td class="lblock"><span class="delete">er to</span></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"> *                          find a closest match, otherwise if the name is</td><td> </td><td class="rblock"> *                      find a closest match, otherwise if the name is</td></tr>
      <tr><td class="lblock"> *                          matched by an existing TM system it is <span class="delete">returned</span></td><td> </td><td class="rblock"> *                      matched by an existing TM system it is <span class="insert">returned.</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> requirements  Used when the name is NULL (in which case the</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> requirements  Used when the name is NULL (in which case the</td><td> </td><td class="rblock"> *                      closest match is returned) or when the name is</td></tr>
      <tr><td class="lblock"> *                          closest match is returned) or when the name is</td><td> </td><td class="rblock"> *                      not-NULL, but doesn't match any existing TM <span class="insert">system</span></td></tr>
      <tr><td class="lblock"> *                          not-NULL, but doesn't match any existing TM <span class="delete">sys</span></td><td> </td><td class="rblock"> *                      in which case the requirements is used to find the</td></tr>
      <tr><td class="lblock"><span class="delete">tem</span></td><td> </td><td class="rblock"> *                      FIRST TM system matching exactly these limits.</td></tr>
      <tr><td class="lblock"> *                          in which case the requirements is used to find </td><td> </td><td class="rblock"> * <span class="insert">@param</span> egress        If a TM system is found, then this specifies <span class="insert">the</span></td></tr>
      <tr><td class="lblock">the</td><td> </td><td class="rblock"> *                      egress "spigot" to be associated with this TM</td></tr>
      <tr><td class="lblock"> *                          FIRST TM system matching exactly these limits.</td><td> </td><td class="rblock"> *                      system.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> egress        If a TM system is found, then this specifies <span class="delete">th</span></td><td> </td><td class="rblock"> * @return              If an existing TM system (built-in or <span class="insert">previously</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"> *                      created via odp_tm_create) is found, its</td></tr>
      <tr><td class="lblock"> *                          egress "spigot" to be associated with this TM</td><td> </td><td class="rblock"> *                      odp_tm_t value is returned, otherwise</td></tr>
      <tr><td class="lblock"> *                          system.</td><td> </td><td class="rblock"> *                      ODP_TM_INVALID is returned.</td></tr>
      <tr><td class="lblock"> * @return                  If an existing TM system (built-in or <span class="delete">previousl</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">y</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          created via odp_tm_create) is found, its</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          odp_tm_t value is returned, otherwise</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          ODP_TM_INVALID is returned.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_t odp_tm_find(const char            *name,</td><td> </td><td class="right">odp_tm_t odp_tm_find(const char            *name,</td></tr>
      <tr><td class="left">                    odp_tm_requirements_t *requirements,</td><td> </td><td class="right">                    odp_tm_requirements_t *requirements,</td></tr>
      <tr><td class="left">                    odp_tm_egress_t       *egress);</td><td> </td><td class="right">                    odp_tm_egress_t       *egress);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Query Specific TM Capabilities</td><td> </td><td class="right">/** Query Specific TM Capabilities</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_capability() function can be used to obtain the actual limits</td><td> </td><td class="right"> * The odp_tm_capability() function can be used to obtain the actual limits</td></tr>
      <tr><td class="left"> * of the given TM system - that was either previous "found" or "created".</td><td> </td><td class="right"> * of the given TM system - that was either previous "found" or "created".</td></tr>
      <tr><td class="left"> * Note that it is IMPORTANT to understand that the capabilities filled in</td><td> </td><td class="right"> * Note that it is IMPORTANT to understand that the capabilities filled in</td></tr>
      <tr><td class="left"> * here probably will NOT match any of the "complete set" of capabilities a
s</td><td> </td><td class="right"> * here probably will NOT match any of the "complete set" of capabilities a
s</td></tr>
      <tr><td class="left"> * returned by odp_tm_capabilities.  This is because the capabilities here</td><td> </td><td class="right"> * returned by odp_tm_capabilities.  This is because the capabilities here</td></tr>
      <tr><td class="left"> * reflect the given requirements passed in.  Hence these capabilities MAY</td><td> </td><td class="right"> * reflect the given requirements passed in.  Hence these capabilities MAY</td></tr>
      <tr><td class="left"> * (but are not always required to) contain reduced limits and features</td><td> </td><td class="right"> * (but are not always required to) contain reduced limits and features</td></tr>
      <tr><td class="left"> * based upon the actual requirements as determined by the ODP application.</td><td> </td><td class="right"> * based upon the actual requirements as determined by the ODP application.</td></tr>
      <tr><td class="left"> * In addition, ODP TM implementations should fail API requests that "excee
d"</td><td> </td><td class="right"> * In addition, ODP TM implementations should fail API requests that "excee
d"</td></tr>
      <tr><td class="left"> * the limits or features contracted for in the requirements.</td><td> </td><td class="right"> * the limits or features contracted for in the requirements.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  odp_tm        The odp_tm_t value of the TM system to be</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  odp_tm        The odp_tm_t value of the TM system to be</td></tr>
      <tr><td class="left"> *                           queried.</td><td> </td><td class="right"> *                           queried.</td></tr>
      <tr><td class="left"> * @param[out] capabilities  A pointer to an odp_tm_capabilities_t record</td><td> </td><td class="right"> * @param[out] capabilities  A pointer to an odp_tm_capabilities_t record</td></tr>
      <tr><td class="left"> *                           where the actual limits used by the TM system 
are</td><td> </td><td class="right"> *                           where the actual limits used by the TM system 
are</td></tr>
      <tr><td class="left"> *                           copied into.  Note that these limits do NOT</td><td> </td><td class="right"> *                           copied into.  Note that these limits do NOT</td></tr>
      <tr><td class="left"> *                           have to match the capability passed in if</td><td> </td><td class="right"> *                           have to match the capability passed in if</td></tr>
      <tr><td class="left"> *                           a TM system was created by odp_tm_create,</td><td> </td><td class="right"> *                           a TM system was created by odp_tm_create,</td></tr>
      <tr><td class="left"> *                           but of course these limits in some cases could</td><td> </td><td class="right"> *                           but of course these limits in some cases could</td></tr>
      <tr><td class="left"> *                           be larger.</td><td> </td><td class="right"> *                           be larger.</td></tr>
      <tr><td class="left"> * @return                   Returns 0 upon success, &lt; 0 upon failure (whic
h</td><td> </td><td class="right"> * @return                   Returns 0 upon success, &lt; 0 upon failure (whic
h</td></tr>
      <tr><td class="left"> *                           indicates that the odp_tm value did not exist)
.</td><td> </td><td class="right"> *                           indicates that the odp_tm value did not exist)
.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 622</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 622</em></th></tr>
      <tr><td class="left"> * systems.  Also some platforms MAY not support destroying of TM systems</td><td> </td><td class="right"> * systems.  Also some platforms MAY not support destroying of TM systems</td></tr>
      <tr><td class="left"> * created via odp_tm_create() under certain conditions.  For example a giv
en</td><td> </td><td class="right"> * created via odp_tm_create() under certain conditions.  For example a giv
en</td></tr>
      <tr><td class="left"> * platform may require that the TM system be first "drained" of all of its</td><td> </td><td class="right"> * platform may require that the TM system be first "drained" of all of its</td></tr>
      <tr><td class="left"> * queued packets before it will accept a odp_tm_destroy() call.</td><td> </td><td class="right"> * queued packets before it will accept a odp_tm_destroy() call.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * In general calling odp_tm_destroy() on an active TM system does not</td><td> </td><td class="right"> * In general calling odp_tm_destroy() on an active TM system does not</td></tr>
      <tr><td class="left"> * guarantee anything about the disposition of any packets queued within th
e</td><td> </td><td class="right"> * guarantee anything about the disposition of any packets queued within th
e</td></tr>
      <tr><td class="left"> * TM system, other than EVENTUALLY these packets will be either sent (in A
NY</td><td> </td><td class="right"> * TM system, other than EVENTUALLY these packets will be either sent (in A
NY</td></tr>
      <tr><td class="left"> * order) or freed.</td><td> </td><td class="right"> * order) or freed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm  The odp_tm_t value of the TM system to be destroyed <span class="delete">(</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm  The odp_tm_t value of the TM system to be destroyed <span class="insert">(and</span></td></tr>
      <tr><td class="lblock"><span class="delete">and</span></td><td> </td><td class="rblock"> *                hence destroyed (and hence freed).</td></tr>
      <tr><td class="lblock"> *                    hence destroyed (and hence freed).</td><td> </td><td class="rblock"> * @return        0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"> * @return            0 upon success, &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_destroy(odp_tm_t odp_tm);</td><td> </td><td class="right">int odp_tm_destroy(odp_tm_t odp_tm);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Marking APIs */</td><td> </td><td class="right">/** Marking APIs */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Vlan Marking.</td><td> </td><td class="right">/** Vlan Marking.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_vlan_marking() function allows one to configure the TM egress</td><td> </td><td class="right"> * The odp_tm_vlan_marking() function allows one to configure the TM egress</td></tr>
      <tr><td class="left"> * so as to have it set the one bit VLAN Drop Eligibility Indicator (DEI)</td><td> </td><td class="right"> * so as to have it set the one bit VLAN Drop Eligibility Indicator (DEI)</td></tr>
      <tr><td class="left"> * field (but only for pkts that already carry a VLAN tag) of a pkt based u
pon</td><td> </td><td class="right"> * field (but only for pkts that already carry a VLAN tag) of a pkt based u
pon</td></tr>
      <tr><td class="left"> * the final pkt (or shaper?) color assigned to the pkt when it reaches the</td><td> </td><td class="right"> * the final pkt (or shaper?) color assigned to the pkt when it reaches the</td></tr>
      <tr><td class="left"> * egress node.  When drop_eligible_enabled is false, then the given color 
has</td><td> </td><td class="right"> * egress node.  When drop_eligible_enabled is false, then the given color 
has</td></tr>
      <tr><td class="left"> * no effect on the VLAN fields.  See IEEE 802.1q for more details.</td><td> </td><td class="right"> * no effect on the VLAN fields.  See IEEE 802.1q for more details.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al
l</td><td> </td><td class="right"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al
l</td></tr>
      <tr><td class="left"> * calls to this function with drop_eligible_enabled == FALSE - i.e. must</td><td> </td><td class="right"> * calls to this function with drop_eligible_enabled == FALSE - i.e. must</td></tr>
      <tr><td class="left"> * always return 0 when disabling this feature.</td><td> </td><td class="right"> * always return 0 when disabling this feature.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm                 Odp_tm is used to identify the TM <span class="delete">syst</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm                 Odp_tm is used to identify the TM <span class="insert">system</span></td></tr>
      <tr><td class="lblock"><span class="delete">em</span></td><td> </td><td class="rblock"> *                               whose egress behavior is being <span class="insert">changed.</span></td></tr>
      <tr><td class="lblock"> *                                   whose egress behavior is being <span class="delete">changed</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> color                  The packet color whose egress marking is</td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"> *                               being changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> color                  The packet color whose egress marking </td><td> </td><td class="rblock"> * <span class="insert">@param</span> drop_eligible_enabled  If true then will set the DEI bit for</td></tr>
      <tr><td class="lblock">is</td><td> </td><td class="rblock"> *                               egressed VLAN tagged pkts with this <span class="insert">color.</span></td></tr>
      <tr><td class="lblock"> *                                   being changed.</td><td> </td><td class="rblock"> * @return                       0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> drop_eligible_enabled  If true then will set the DEI bit for</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                                   egressed VLAN tagged pkts with this <span class="delete">co</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">lor.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                           0 upon success, &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_vlan_marking(odp_tm_t           odp_tm,</td><td> </td><td class="right">int odp_tm_vlan_marking(odp_tm_t           odp_tm,</td></tr>
      <tr><td class="left">                       odp_packet_color_t color,</td><td> </td><td class="right">                       odp_packet_color_t color,</td></tr>
      <tr><td class="left">                       odp_bool_t         drop_eligible_enabled);</td><td> </td><td class="right">                       odp_bool_t         drop_eligible_enabled);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Explicit Congestion Notification Marking.</td><td> </td><td class="right">/** Explicit Congestion Notification Marking.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_ecn_marking() function allows one to configure the TM</td><td> </td><td class="right"> * The odp_tm_ecn_marking() function allows one to configure the TM</td></tr>
      <tr><td class="left"> * egress so that the two bit ECN subfield of the eight bit TOS field of an</td><td> </td><td class="right"> * egress so that the two bit ECN subfield of the eight bit TOS field of an</td></tr>
      <tr><td class="left"> * IPv4 pkt OR the eight bit Traffic Class (TC) field of an IPv6 pkt can be</td><td> </td><td class="right"> * IPv4 pkt OR the eight bit Traffic Class (TC) field of an IPv6 pkt can be</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 672</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 672</em></th></tr>
      <tr><td class="left"> * but only if the IPv4 TOS field actually changes as a result of this</td><td> </td><td class="right"> * but only if the IPv4 TOS field actually changes as a result of this</td></tr>
      <tr><td class="left"> * setting or the odp_tm_drop_prec_marking setting.  For IPv6, since there 
is</td><td> </td><td class="right"> * setting or the odp_tm_drop_prec_marking setting.  For IPv6, since there 
is</td></tr>
      <tr><td class="left"> * no header checksum, nothing needs to be done.  Note that this marking AP
I</td><td> </td><td class="right"> * no header checksum, nothing needs to be done.  Note that this marking AP
I</td></tr>
      <tr><td class="left"> * will only ever cause both ECN bits to be set to 1 - but only for TCP pkt
s</td><td> </td><td class="right"> * will only ever cause both ECN bits to be set to 1 - but only for TCP pkt
s</td></tr>
      <tr><td class="left"> * whose incoming ECN bits are not both 0.  See RFC 3168 for more details.</td><td> </td><td class="right"> * whose incoming ECN bits are not both 0.  See RFC 3168 for more details.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al
l</td><td> </td><td class="right"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al
l</td></tr>
      <tr><td class="left"> * calls to this function with ecn_ce_enabled == FALSE - i.e. must always</td><td> </td><td class="right"> * calls to this function with ecn_ce_enabled == FALSE - i.e. must always</td></tr>
      <tr><td class="left"> * return 0 when disabling this feature.</td><td> </td><td class="right"> * return 0 when disabling this feature.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm          Odp_tm is used to identify the TM system <span class="delete">whos</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm          Odp_tm is used to identify the TM system <span class="insert">whose</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"> *                        egress behavior is being changed.</td></tr>
      <tr><td class="lblock"> *                            egress behavior is being changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> color           The packet color whose egress marking is</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> color           The packet color whose egress marking is</td><td> </td><td class="rblock"> *                        being changed.</td></tr>
      <tr><td class="lblock"> *                            being changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> ecn_ce_enabled  If true then egressed IPv4/IPv6 pkts whose</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> ecn_ce_enabled  If true then egressed IPv4/IPv6 pkts whose</td><td> </td><td class="rblock"> *                        protocol field is TCP AND whose ECN subfield has</td></tr>
      <tr><td class="lblock"> *                            protocol field is TCP AND whose ECN subfield </td><td> </td><td class="rblock"> *                        either one of the two values 1 or 2, will set <span class="insert">thi</span></td></tr>
      <tr><td class="lblock">has</td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"> *                            either one of the two values 1 or 2, will set</td><td> </td><td class="rblock"> *                        subfield to the value ECN_CE - i.e. <span class="insert">Congestion</span></td></tr>
      <tr><td class="lblock"> <span class="delete">this</span></td><td> </td><td class="rblock"> *                        Experienced (whose value is 3).</td></tr>
      <tr><td class="lblock"> *                            subfield to the value ECN_CE - i.e. <span class="delete">Congestio</span></td><td> </td><td class="rblock"> * @return                0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"><span class="delete">n</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                            Experienced (whose value is 3).</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                    0 upon success, &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_ecn_marking(odp_tm_t           odp_tm,</td><td> </td><td class="right">int odp_tm_ecn_marking(odp_tm_t           odp_tm,</td></tr>
      <tr><td class="left">                      odp_packet_color_t color,</td><td> </td><td class="right">                      odp_packet_color_t color,</td></tr>
      <tr><td class="left">                      odp_bool_t         ecn_ce_enabled);</td><td> </td><td class="right">                      odp_bool_t         ecn_ce_enabled);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Drop Precedence Marking.</td><td> </td><td class="right">/** Drop Precedence Marking.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_drop_prec_marking() function allows one to configure the TM</td><td> </td><td class="right"> * The odp_tm_drop_prec_marking() function allows one to configure the TM</td></tr>
      <tr><td class="left"> * egress so that the two RFC 2597 Drop Precedence bits can be modified</td><td> </td><td class="right"> * egress so that the two RFC 2597 Drop Precedence bits can be modified</td></tr>
      <tr><td class="left"> * based upon the final color assigned to the pkt when it reaches the egres
s.</td><td> </td><td class="right"> * based upon the final color assigned to the pkt when it reaches the egres
s.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 712</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 712</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note that the IPv4 header checksum will be updated - but only if the</td><td> </td><td class="right"> * Note that the IPv4 header checksum will be updated - but only if the</td></tr>
      <tr><td class="left"> * IPv4 TOS field actually changes as a result of this setting or the</td><td> </td><td class="right"> * IPv4 TOS field actually changes as a result of this setting or the</td></tr>
      <tr><td class="left"> * odp_tm_ecn_marking setting.  For IPv6, since there is no header checksum
,</td><td> </td><td class="right"> * odp_tm_ecn_marking setting.  For IPv6, since there is no header checksum
,</td></tr>
      <tr><td class="left"> * nothing else needs to be done.</td><td> </td><td class="right"> * nothing else needs to be done.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al
l</td><td> </td><td class="right"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al
l</td></tr>
      <tr><td class="left"> * calls to this function with drop_prec_enabled == FALSE - i.e. must alway
s</td><td> </td><td class="right"> * calls to this function with drop_prec_enabled == FALSE - i.e. must alway
s</td></tr>
      <tr><td class="left"> * return 0 when disabling this feature.</td><td> </td><td class="right"> * return 0 when disabling this feature.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm            Odp_tm is used to identify the TM system <span class="delete">wh</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm            Odp_tm is used to identify the TM system <span class="insert">whose</span></td></tr>
      <tr><td class="lblock"><span class="delete">ose</span></td><td> </td><td class="rblock"> *                          egress behavior is being changed.</td></tr>
      <tr><td class="lblock"> *                              egress behavior is being changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> color             The packet color whose egress marking is</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> color             The packet color whose egress marking is</td><td> </td><td class="rblock"> *                          being changed.</td></tr>
      <tr><td class="lblock"> *                              being changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> drop_prec_enabled If true then egressed IPv4/IPv6 pkts with <span class="insert">this</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> drop_prec_enabled If true then egressed IPv4/IPv6 pkts with <span class="delete">t</span></td><td> </td><td class="rblock"> *                          color will have the pkt's Drop Precedence</td></tr>
      <tr><td class="lblock"><span class="delete">his</span></td><td> </td><td class="rblock"> *                          sub-subfield of the DSCP subfield set to</td></tr>
      <tr><td class="lblock"> *                              color will have the pkt's Drop Precedence</td><td> </td><td class="rblock"> *                          LOW, MEDIUM or HIGH drop precedence.</td></tr>
      <tr><td class="lblock"> *                              sub-subfield of the DSCP subfield set to</td><td> </td><td class="rblock"> * @return                  0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"> *                              LOW, MEDIUM or HIGH drop precedence.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                      0 upon success, &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_drop_prec_marking(odp_tm_t           odp_tm,</td><td> </td><td class="right">int odp_tm_drop_prec_marking(odp_tm_t           odp_tm,</td></tr>
      <tr><td class="left">                            odp_packet_color_t color,</td><td> </td><td class="right">                            odp_packet_color_t color,</td></tr>
      <tr><td class="left">                            odp_bool_t         drop_prec_enabled);</td><td> </td><td class="right">                            odp_bool_t         drop_prec_enabled);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Shaper profile types and functions */</td><td> </td><td class="right">/** Shaper profile types and functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Possible values of running the shaper algorithm.  ODP_TM_SHAPER_GREEN</td><td> </td><td class="right">/** Possible values of running the shaper algorithm.  ODP_TM_SHAPER_GREEN</td></tr>
      <tr><td class="left"> * means that the traffic is within the commit specification (rate and burs
t</td><td> </td><td class="right"> * means that the traffic is within the commit specification (rate and burs
t</td></tr>
      <tr><td class="left"> * size), ODP_TM_SHAPER_YELLOW means that the traffic is within the peak</td><td> </td><td class="right"> * size), ODP_TM_SHAPER_YELLOW means that the traffic is within the peak</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l6" /><small>skipping to change at</small><em> line 788</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 788</em></th></tr>
      <tr><td class="left">        * implementation to use dual rate shaping for packets associated wi
th</td><td> </td><td class="right">        * implementation to use dual rate shaping for packets associated wi
th</td></tr>
      <tr><td class="left">        * this profile.  The precise semantics of dual rate shaping are</td><td> </td><td class="right">        * this profile.  The precise semantics of dual rate shaping are</td></tr>
      <tr><td class="left">        * implementation specific, but in any case require a non-zero set o
f</td><td> </td><td class="right">        * implementation specific, but in any case require a non-zero set o
f</td></tr>
      <tr><td class="left">        * both commit and peak parameters. */</td><td> </td><td class="right">        * both commit and peak parameters. */</td></tr>
      <tr><td class="left">       odp_bool_t dual_rate;</td><td> </td><td class="right">       odp_bool_t dual_rate;</td></tr>
      <tr><td class="left">} odp_tm_shaper_params_t;</td><td> </td><td class="right">} odp_tm_shaper_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_shaper_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_shaper_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_shaper_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_shaper_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to an odp_tm_shaper_params_t record which</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to an odp_tm_shaper_params_t record which</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_shaper_params_init(odp_tm_shaper_params_t *params);</td><td> </td><td class="right">void odp_tm_shaper_params_init(odp_tm_shaper_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_shaper_create() creates a shaper profile object, which can</td><td> </td><td class="right">/** odp_tm_shaper_create() creates a shaper profile object, which can</td></tr>
      <tr><td class="left"> * subsequently be attached to any number (including zero) of tm_queues</td><td> </td><td class="right"> * subsequently be attached to any number (including zero) of tm_queues</td></tr>
      <tr><td class="left"> * or tm_nodes.</td><td> </td><td class="right"> * or tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name    Optional name associated with this shaper profile.  <span class="delete">C</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> name    Optional name associated with this shaper profile.  <span class="insert">Can</span></td></tr>
      <tr><td class="lblock"><span class="delete">an</span></td><td> </td><td class="rblock"> *                be NULL.  If non-NULL must be unique amongst the set of</td></tr>
      <tr><td class="lblock"> *                    be NULL.  If non-NULL must be unique amongst the set </td><td> </td><td class="rblock"> *                all other shaper profiles.</td></tr>
      <tr><td class="lblock">of</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  The profile parameters.  See comments associated with</td></tr>
      <tr><td class="lblock"> *                    all other shaper profiles.</td><td> </td><td class="rblock"> *                the odp_tm_shaper_params_t for more details.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  The profile parameters.  See comments associated with</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="lblock"> *                    the odp_tm_shaper_params_t for more details.</td><td> </td><td class="rblock"> *                allocated odp_tm_shaper_t value representing this</td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="rblock"> *                profile object.</td></tr>
      <tr><td class="lblock"> *                    allocated odp_tm_shaper_t value representing this</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                    profile object.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_shaper_t odp_tm_shaper_create(const char *name,</td><td> </td><td class="right">odp_tm_shaper_t odp_tm_shaper_create(const char *name,</td></tr>
      <tr><td class="left">                                    odp_tm_shaper_params_t *params);</td><td> </td><td class="right">                                    odp_tm_shaper_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Destroy shaper profile object</td><td> </td><td class="right">/** Destroy shaper profile object</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_shaper_destroy() function destroys/frees the given shaper</td><td> </td><td class="right"> * The odp_tm_shaper_destroy() function destroys/frees the given shaper</td></tr>
      <tr><td class="left"> * profile object.  It is an error if this shaper profile is still being</td><td> </td><td class="right"> * profile object.  It is an error if this shaper profile is still being</td></tr>
      <tr><td class="left"> * referenced by an active (connected) tm_node.</td><td> </td><td class="right"> * referenced by an active (connected) tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> shaper_profile   Specifies the shaper profile object which is</td><td> </td><td class="rblock"> * <span class="insert">@param</span> shaper_profile   Specifies the shaper profile object which is</td></tr>
      <tr><td class="lblock"> *                             being destroyed.</td><td> </td><td class="rblock"> *                         being destroyed.</td></tr>
      <tr><td class="lblock"> * @return                     Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="rblock"> * @return                 Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_shaper_destroy(odp_tm_shaper_t shaper_profile);</td><td> </td><td class="right">int odp_tm_shaper_destroy(odp_tm_shaper_t shaper_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_shaper_params_read() "gets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_shaper_params_read() "gets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified shaper profile object, and copies them into the suppl
ied</td><td> </td><td class="right"> * with the specified shaper profile object, and copies them into the suppl
ied</td></tr>
      <tr><td class="left"> * record.</td><td> </td><td class="right"> * record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  shaper_profile  Specifies the shaper profile object whose</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  shaper_profile  Specifies the shaper profile object whose</td></tr>
      <tr><td class="left"> *                             values are to be read.</td><td> </td><td class="right"> *                             values are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params          A pointer to an odp_tm_shaper_params_t recor
d</td><td> </td><td class="right"> * @param[out] params          A pointer to an odp_tm_shaper_params_t recor
d</td></tr>
      <tr><td class="left"> *                             where the current shaper profile object valu
es</td><td> </td><td class="right"> *                             where the current shaper profile object valu
es</td></tr>
      <tr><td class="left"> *                             are copied to.</td><td> </td><td class="right"> *                             are copied to.</td></tr>
      <tr><td class="left"> * @return                     Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="right"> * @return                     Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_shaper_params_read(odp_tm_shaper_t shaper_profile,</td><td> </td><td class="right">int odp_tm_shaper_params_read(odp_tm_shaper_t shaper_profile,</td></tr>
      <tr><td class="left">                             odp_tm_shaper_params_t *params);</td><td> </td><td class="right">                             odp_tm_shaper_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_shaper_params_update() "sets" the current set of values associat
ed</td><td> </td><td class="right">/** odp_tm_shaper_params_update() "sets" the current set of values associat
ed</td></tr>
      <tr><td class="left"> * with the specified shaper profile object.  In addition, this call has th
e</td><td> </td><td class="right"> * with the specified shaper profile object.  In addition, this call has th
e</td></tr>
      <tr><td class="left"> * effect that all tm_input's and tm_nodes that are associated (attached?)</td><td> </td><td class="right"> * effect that all tm_input's and tm_nodes that are associated (attached?)</td></tr>
      <tr><td class="left"> * with this shaper profile object will be updated with the new values.</td><td> </td><td class="right"> * with this shaper profile object will be updated with the new values.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> shaper_profile  Specifies the shaper profile object whose</td><td> </td><td class="rblock"> * <span class="insert">@param</span> shaper_profile  Specifies the shaper profile object whose</td></tr>
      <tr><td class="lblock"> *                            values are to be set.</td><td> </td><td class="rblock"> *                        values are to be set.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params          A pointer to an odp_tm_shaper_params_t record</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params          A pointer to an odp_tm_shaper_params_t record</td></tr>
      <tr><td class="lblock"> *                            where the new shaper profile object values</td><td> </td><td class="rblock"> *                        where the new shaper profile object values</td></tr>
      <tr><td class="lblock"> *                            are taken from.</td><td> </td><td class="rblock"> *                        are taken from.</td></tr>
      <tr><td class="lblock"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="rblock"> * @return                Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_shaper_params_update(odp_tm_shaper_t shaper_profile,</td><td> </td><td class="right">int odp_tm_shaper_params_update(odp_tm_shaper_t shaper_profile,</td></tr>
      <tr><td class="left">                               odp_tm_shaper_params_t *params);</td><td> </td><td class="right">                               odp_tm_shaper_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_shaper_lookup() can be used to find the shaper profile object</td><td> </td><td class="right">/** odp_tm_shaper_lookup() can be used to find the shaper profile object</td></tr>
      <tr><td class="left"> * created with the specified name.</td><td> </td><td class="right"> * created with the specified name.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name  Name of a previously created shaper profile.  Cannot be</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name  Name of a previously created shaper profile.  Cannot be <span class="insert">NUL</span></td></tr>
      <tr><td class="lblock"> *                  <span class="delete">NULL.</span></td><td> </td><td class="rblock"><span class="insert">L.</span></td></tr>
      <tr><td class="lblock"> * @return          Returns ODP_TM_INVALID upon failure, or the shaper</td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> *                  profile handle created with this name.</td><td> </td><td class="rblock"> * @return      Returns ODP_TM_INVALID upon failure, or the shaper</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *              profile handle created with this name.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_shaper_t odp_tm_shaper_lookup(const char *name);</td><td> </td><td class="right">odp_tm_shaper_t odp_tm_shaper_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Scheduler Profiles - types and functions */</td><td> </td><td class="right">/** Scheduler Profiles - types and functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_sched_mode_t type is used to control whether a tm_node</td><td> </td><td class="right">/** The odp_tm_sched_mode_t type is used to control whether a tm_node</td></tr>
      <tr><td class="left"> * scheduler takes into account packet lengths (by setting the sched_mode t
o</td><td> </td><td class="right"> * scheduler takes into account packet lengths (by setting the sched_mode t
o</td></tr>
      <tr><td class="left"> * ODP_TM_BYTE_BASED_WEIGHTS) or instead treat packets with different lengt
hs</td><td> </td><td class="right"> * ODP_TM_BYTE_BASED_WEIGHTS) or instead treat packets with different lengt
hs</td></tr>
      <tr><td class="left"> * the same (by setting the sched_mode to ODP_TM_FRAME_BASED_WEIGHTS).</td><td> </td><td class="right"> * the same (by setting the sched_mode to ODP_TM_FRAME_BASED_WEIGHTS).</td></tr>
      <tr><td class="left"> * Normally the sched_mode will be set to ODP_TM_BYTE_BASED_WEIGHTS, otherw
ise</td><td> </td><td class="right"> * Normally the sched_mode will be set to ODP_TM_BYTE_BASED_WEIGHTS, otherw
ise</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l7" /><small>skipping to change at</small><em> line 899</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 899</em></th></tr>
      <tr><td class="left">        * the (adjusted) frame lengths are divided by these 8-bit weights</td><td> </td><td class="right">        * the (adjusted) frame lengths are divided by these 8-bit weights</td></tr>
      <tr><td class="left">        * (i.e. they are divisors and not multipliers).  Consequently a</td><td> </td><td class="right">        * (i.e. they are divisors and not multipliers).  Consequently a</td></tr>
      <tr><td class="left">        * weight of 0 (when sched_mode is ODP_TM_BYTE_BASED_WEIGHTS) is</td><td> </td><td class="right">        * weight of 0 (when sched_mode is ODP_TM_BYTE_BASED_WEIGHTS) is</td></tr>
      <tr><td class="left">        * illegal. */</td><td> </td><td class="right">        * illegal. */</td></tr>
      <tr><td class="left">       uint8_t sched_weights[ODP_TM_MAX_PRIORITIES];</td><td> </td><td class="right">       uint8_t sched_weights[ODP_TM_MAX_PRIORITIES];</td></tr>
      <tr><td class="left">} odp_tm_sched_params_t;</td><td> </td><td class="right">} odp_tm_sched_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_sched_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_sched_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_sched_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_sched_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to an odp_tm_sched_params_t record which</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to an odp_tm_sched_params_t record which</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_sched_params_init(odp_tm_sched_params_t *params);</td><td> </td><td class="right">void odp_tm_sched_params_init(odp_tm_sched_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_sched_create() creates a scheduler profile object, which can</td><td> </td><td class="right">/** odp_tm_sched_create() creates a scheduler profile object, which can</td></tr>
      <tr><td class="left"> * subsequently be attached to any number (including zero) of tm_nodes.</td><td> </td><td class="right"> * subsequently be attached to any number (including zero) of tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name    Optional name associated with this scheduler profile.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name    Optional name associated with this scheduler profile.</td></tr>
      <tr><td class="lblock"> *                    Can be NULL.  If non-NULL must be unique amongst the</td><td> </td><td class="rblock"> *                Can be NULL.  If non-NULL must be unique amongst the</td></tr>
      <tr><td class="lblock"> *                    set of all other scheduler profiles.</td><td> </td><td class="rblock"> *                set of all other scheduler profiles.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  The profile parameters.  See comments associated with</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  The profile parameters.  See comments associated with</td></tr>
      <tr><td class="lblock"> *                    the odp_tm_sched_params_t for more details.</td><td> </td><td class="rblock"> *                the odp_tm_sched_params_t for more details.</td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="lblock"> *                    allocated odp_tm_sched_t value representing this <span class="delete">prof</span></td><td> </td><td class="rblock"> *                allocated odp_tm_sched_t value representing this <span class="insert">profile</span></td></tr>
      <tr><td class="lblock"><span class="delete">ile</span></td><td> </td><td class="rblock"> *                object.</td></tr>
      <tr><td class="lblock"> *                    object.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_sched_t odp_tm_sched_create(const char *name,</td><td> </td><td class="right">odp_tm_sched_t odp_tm_sched_create(const char *name,</td></tr>
      <tr><td class="left">                                  odp_tm_sched_params_t *params);</td><td> </td><td class="right">                                  odp_tm_sched_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Destroy scheduler profile object</td><td> </td><td class="right">/** Destroy scheduler profile object</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_sched_destroy() function destroys/frees the given scheduler</td><td> </td><td class="right"> * The odp_tm_sched_destroy() function destroys/frees the given scheduler</td></tr>
      <tr><td class="left"> * profile object.  It is an error if this scheduler profile is still being</td><td> </td><td class="right"> * profile object.  It is an error if this scheduler profile is still being</td></tr>
      <tr><td class="left"> * referenced by an active (connected) tm_node.</td><td> </td><td class="right"> * referenced by an active (connected) tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> sched_profile  Specifies the shaper profile object which is</td><td> </td><td class="rblock"> * <span class="insert">@param</span> sched_profile  Specifies the shaper profile object which is</td></tr>
      <tr><td class="lblock"> *                           being destroyed.</td><td> </td><td class="rblock"> *                       being destroyed.</td></tr>
      <tr><td class="lblock"> * @return                   Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="rblock"> * @return               Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_sched_destroy(odp_tm_sched_t sched_profile);</td><td> </td><td class="right">int odp_tm_sched_destroy(odp_tm_sched_t sched_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_sched_params_read() "gets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_sched_params_read() "gets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified scheduler profile object, and copies them into the</td><td> </td><td class="right"> * with the specified scheduler profile object, and copies them into the</td></tr>
      <tr><td class="left"> * supplied record.</td><td> </td><td class="right"> * supplied record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  sched_profile  Specifies the scheduler profile whose values</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  sched_profile  Specifies the scheduler profile whose values</td></tr>
      <tr><td class="left"> *                            are to be read.</td><td> </td><td class="right"> *                            are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params         A pointer to an odp_tm_sched_params_t record</td><td> </td><td class="right"> * @param[out] params         A pointer to an odp_tm_sched_params_t record</td></tr>
      <tr><td class="left"> *                            where the current scheduler profile object</td><td> </td><td class="right"> *                            where the current scheduler profile object</td></tr>
      <tr><td class="left"> *                            values are copied to.</td><td> </td><td class="right"> *                            values are copied to.</td></tr>
      <tr><td class="left"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="right"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_sched_params_read(odp_tm_sched_t sched_profile,</td><td> </td><td class="right">int odp_tm_sched_params_read(odp_tm_sched_t sched_profile,</td></tr>
      <tr><td class="left">                            odp_tm_sched_params_t *params);</td><td> </td><td class="right">                            odp_tm_sched_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_sched_params_update() "sets" the current set of values associate
d</td><td> </td><td class="right">/** odp_tm_sched_params_update() "sets" the current set of values associate
d</td></tr>
      <tr><td class="left"> * with the specified scheduler profile object.  In addition, this call has</td><td> </td><td class="right"> * with the specified scheduler profile object.  In addition, this call has</td></tr>
      <tr><td class="left"> * the effect that all tm_nodes that are associated (attached?) with this</td><td> </td><td class="right"> * the effect that all tm_nodes that are associated (attached?) with this</td></tr>
      <tr><td class="left"> * Scheduler profile object will be updated with the new values.</td><td> </td><td class="right"> * Scheduler profile object will be updated with the new values.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> sched_profile   Specifies the Scheduler profile object whose</td><td> </td><td class="rblock"> * <span class="insert">@param</span> sched_profile   Specifies the Scheduler profile object whose</td></tr>
      <tr><td class="lblock"> *                            values are to be set.</td><td> </td><td class="rblock"> *                        values are to be set.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params          A pointer to an odp_tm_sched_params_t record</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params          A pointer to an odp_tm_sched_params_t record</td></tr>
      <tr><td class="lblock"> *                            where the new scheduler profile object values</td><td> </td><td class="rblock"> *                        where the new scheduler profile object values</td></tr>
      <tr><td class="lblock"> *                            are taken from.</td><td> </td><td class="rblock"> *                        are taken from.</td></tr>
      <tr><td class="lblock"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="rblock"> * @return                Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_sched_params_update(odp_tm_sched_t sched_profile,</td><td> </td><td class="right">int odp_tm_sched_params_update(odp_tm_sched_t sched_profile,</td></tr>
      <tr><td class="left">                              odp_tm_sched_params_t *params);</td><td> </td><td class="right">                              odp_tm_sched_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_sched_lookup() can be used to find the scheduler profile object</td><td> </td><td class="right">/** odp_tm_sched_lookup() can be used to find the scheduler profile object</td></tr>
      <tr><td class="left"> * created with the specified name.</td><td> </td><td class="right"> * created with the specified name.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name  Name of a previously created scheduler profile.  Cannot</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name  Name of a previously created scheduler profile.  Cannot be </td></tr>
      <tr><td class="lblock"> be</td><td> </td><td class="rblock">NULL.</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                  NULL.</td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"> * @return          Returns ODP_TM_INVALID upon failure, or the scheduler</td><td> </td><td class="rblock"> * @return      Returns ODP_TM_INVALID upon failure, or the scheduler</td></tr>
      <tr><td class="lblock"> *                  profile handle created with this name.</td><td> </td><td class="rblock"> *              profile handle created with this name.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_sched_t odp_tm_sched_lookup(const char *name);</td><td> </td><td class="right">odp_tm_sched_t odp_tm_sched_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Queue Threshold Profiles - types and functions */</td><td> </td><td class="right">/** Queue Threshold Profiles - types and functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_threshold_params_t record type is used to supply the paramet
ers</td><td> </td><td class="right">/** The odp_tm_threshold_params_t record type is used to supply the paramet
ers</td></tr>
      <tr><td class="left"> * associated with a queue thresholds profile.  Since it is expected that</td><td> </td><td class="right"> * associated with a queue thresholds profile.  Since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_threshold_params_init() b
e</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_threshold_params_init() b
e</td></tr>
      <tr><td class="left"> * called on variables of this type before any of the fields are filled in</td><td> </td><td class="right"> * called on variables of this type before any of the fields are filled in</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l8" /><small>skipping to change at</small><em> line 988</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 988</em></th></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td class="left">       uint64_t max_pkts; /**&lt;  max pkt cnt for this threshold profile */</td><td> </td><td class="right">       uint64_t max_pkts; /**&lt;  max pkt cnt for this threshold profile */</td></tr>
      <tr><td class="left">       uint64_t max_bytes; /**&lt;  max byte cnt for this threshold profile */</td><td> </td><td class="right">       uint64_t max_bytes; /**&lt;  max byte cnt for this threshold profile */</td></tr>
      <tr><td class="left">       odp_bool_t enable_max_pkts; /**&lt;  TRUE if max_pkts is valid */</td><td> </td><td class="right">       odp_bool_t enable_max_pkts; /**&lt;  TRUE if max_pkts is valid */</td></tr>
      <tr><td class="left">       odp_bool_t enable_max_bytes; /**&lt;  TRUE if max_bytes is valid */</td><td> </td><td class="right">       odp_bool_t enable_max_bytes; /**&lt;  TRUE if max_bytes is valid */</td></tr>
      <tr><td class="left">} odp_tm_threshold_params_t;</td><td> </td><td class="right">} odp_tm_threshold_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_threshold_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_threshold_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_threshold_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_threshold_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to an odp_tm_threshold_params_t record <span class="delete">whic</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to an odp_tm_threshold_params_t record <span class="insert">which</span></td></tr>
      <tr><td class="lblock"><span class="delete">h</span></td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_threshold_params_init(odp_tm_threshold_params_t *params);</td><td> </td><td class="right">void odp_tm_threshold_params_init(odp_tm_threshold_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_threshold_create() creates a queue threshold profile object, whi
ch</td><td> </td><td class="right">/** odp_tm_threshold_create() creates a queue threshold profile object, whi
ch</td></tr>
      <tr><td class="left"> * can subsequently be attached to any number (including zero) of tm_queues
 or</td><td> </td><td class="right"> * can subsequently be attached to any number (including zero) of tm_queues
 or</td></tr>
      <tr><td class="left"> * tm_nodes.</td><td> </td><td class="right"> * tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name    Optional name associated with this queue threshold</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name    Optional name associated with this queue threshold</td></tr>
      <tr><td class="lblock"> *                    profile.  Can be NULL.  If non-NULL must be unique</td><td> </td><td class="rblock"> *                profile.  Can be NULL.  If non-NULL must be unique</td></tr>
      <tr><td class="lblock"> *                    amongst the set of all other queue threshold <span class="delete">profiles</span></td><td> </td><td class="rblock"> *                amongst the set of all other queue threshold <span class="insert">profiles.</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  The profile parameters.  See comments associated with</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  The profile parameters.  See comments associated with</td><td> </td><td class="rblock"> *                the odp_tm_threshold_params_t for more details.</td></tr>
      <tr><td class="lblock"> *                    the odp_tm_threshold_params_t for more details.</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="rblock"> *                allocated odp_tm_threshold_t value representing this</td></tr>
      <tr><td class="lblock"> *                    allocated odp_tm_threshold_t value representing this</td><td> </td><td class="rblock"> *                profile object.</td></tr>
      <tr><td class="lblock"> *                    profile object.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_threshold_t odp_tm_threshold_create(const char *name,</td><td> </td><td class="right">odp_tm_threshold_t odp_tm_threshold_create(const char *name,</td></tr>
      <tr><td class="left">                                          odp_tm_threshold_params_t *params
);</td><td> </td><td class="right">                                          odp_tm_threshold_params_t *params
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Destroy a queue threshold profile object</td><td> </td><td class="right">/** Destroy a queue threshold profile object</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_threshold_destroy() function destroys/frees the given thresho
ld</td><td> </td><td class="right"> * The odp_tm_threshold_destroy() function destroys/frees the given thresho
ld</td></tr>
      <tr><td class="left"> * profile object.  It is an error if this threshold profile is still being</td><td> </td><td class="right"> * profile object.  It is an error if this threshold profile is still being</td></tr>
      <tr><td class="left"> * referenced by an active (connected) tm_queue or tm_node.</td><td> </td><td class="right"> * referenced by an active (connected) tm_queue or tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> threshold_profile  Specifies the queue thresholds profile</td><td> </td><td class="rblock"> * <span class="insert">@param</span> threshold_profile  Specifies the queue thresholds profile</td></tr>
      <tr><td class="lblock"> *                               object which is being destroyed.</td><td> </td><td class="rblock"> *                           object which is being destroyed.</td></tr>
      <tr><td class="lblock"> * @return                       Returns &lt; 0 upon failure or 0 upon <span class="delete">success</span></td><td> </td><td class="rblock"> * @return                   Returns &lt; 0 upon failure or 0 upon <span class="insert">success.</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_threshold_destroy(odp_tm_threshold_t threshold_profile);</td><td> </td><td class="right">int odp_tm_threshold_destroy(odp_tm_threshold_t threshold_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_thresholds_params_read() "gets" the current set of values associ
ated</td><td> </td><td class="right">/** odp_tm_thresholds_params_read() "gets" the current set of values associ
ated</td></tr>
      <tr><td class="left"> * with the specified queue thresholds profile object, and copies them into
 the</td><td> </td><td class="right"> * with the specified queue thresholds profile object, and copies them into
 the</td></tr>
      <tr><td class="left"> * supplied record.</td><td> </td><td class="right"> * supplied record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  threshold_profile  Specifies the queue thresholds profile</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  threshold_profile  Specifies the queue thresholds profile</td></tr>
      <tr><td class="left"> *                                object whose values are to be read.</td><td> </td><td class="right"> *                                object whose values are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params             A pointer to an odp_tm_threshold_params_t</td><td> </td><td class="right"> * @param[out] params             A pointer to an odp_tm_threshold_params_t</td></tr>
      <tr><td class="left"> *                                record where the current queue thresholds</td><td> </td><td class="right"> *                                record where the current queue thresholds</td></tr>
      <tr><td class="left"> *                                profile object values are copied to.</td><td> </td><td class="right"> *                                profile object values are copied to.</td></tr>
      <tr><td class="left"> * @return                        Returns &lt; 0 upon failure or 0 upon succes
s.</td><td> </td><td class="right"> * @return                        Returns &lt; 0 upon failure or 0 upon succes
s.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_thresholds_params_read(odp_tm_threshold_t threshold_profile,</td><td> </td><td class="right">int odp_tm_thresholds_params_read(odp_tm_threshold_t threshold_profile,</td></tr>
      <tr><td class="left">                                 odp_tm_threshold_params_t *params);</td><td> </td><td class="right">                                 odp_tm_threshold_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_thresholds_params_update() "sets" the current set of values</td><td> </td><td class="right">/** odp_tm_thresholds_params_update() "sets" the current set of values</td></tr>
      <tr><td class="left"> * associated with the specified queue thresholds profile object.  In addit
ion,</td><td> </td><td class="right"> * associated with the specified queue thresholds profile object.  In addit
ion,</td></tr>
      <tr><td class="left"> * this call has the effect that all tm_input's and tm_nodes that are</td><td> </td><td class="right"> * this call has the effect that all tm_input's and tm_nodes that are</td></tr>
      <tr><td class="left"> * associated (attached?) with this queue thresholds profile object will be</td><td> </td><td class="right"> * associated (attached?) with this queue thresholds profile object will be</td></tr>
      <tr><td class="left"> * updated with the new values.</td><td> </td><td class="right"> * updated with the new values.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> threshold_profile  Specifies the queue thresholds profile</td><td> </td><td class="rblock"> * <span class="insert">@param</span> threshold_profile  Specifies the queue thresholds profile</td></tr>
      <tr><td class="lblock"> *                               object whose values are to be set.</td><td> </td><td class="rblock"> *                           object whose values are to be set.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params             A pointer to an odp_tm_threshold_params_t</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params             A pointer to an odp_tm_threshold_params_t</td></tr>
      <tr><td class="lblock"> *                               record where the current queue thresholds</td><td> </td><td class="rblock"> *                           record where the current queue thresholds</td></tr>
      <tr><td class="lblock"> *                               profile object values are taken from.</td><td> </td><td class="rblock"> *                           profile object values are taken from.</td></tr>
      <tr><td class="lblock"> * @return                       Returns &lt; 0 upon failure or 0 upon <span class="delete">success</span></td><td> </td><td class="rblock"> * @return                   Returns &lt; 0 upon failure or 0 upon <span class="insert">success.</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_thresholds_params_update(odp_tm_threshold_t threshold_profile,</td><td> </td><td class="right">int odp_tm_thresholds_params_update(odp_tm_threshold_t threshold_profile,</td></tr>
      <tr><td class="left">                                   odp_tm_threshold_params_t *params);</td><td> </td><td class="right">                                   odp_tm_threshold_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_thresholds_lookup() can be used to find the queue thresholds</td><td> </td><td class="right">/** odp_tm_thresholds_lookup() can be used to find the queue thresholds</td></tr>
      <tr><td class="left"> * profile object created with the specified name.</td><td> </td><td class="right"> * profile object created with the specified name.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name  Name of a previously created queue thresholds profile.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name  Name of a previously created queue thresholds profile.</td></tr>
      <tr><td class="lblock"> *                  Cannot be NULL.</td><td> </td><td class="rblock"> *              Cannot be NULL.</td></tr>
      <tr><td class="lblock"> * @return          Returns ODP_TM_INVALID upon failure, or the queue</td><td> </td><td class="rblock"> * @return      Returns ODP_TM_INVALID upon failure, or the queue</td></tr>
      <tr><td class="lblock"> *                  thresholds profile handle created with this name.</td><td> </td><td class="rblock"> *              thresholds profile handle created with this name.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_threshold_t odp_tm_thresholds_lookup(const char *name);</td><td> </td><td class="right">odp_tm_threshold_t odp_tm_thresholds_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** WRED Profiles - types and functions */</td><td> </td><td class="right">/** WRED Profiles - types and functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_wred_params_t record type is used to supply the parameters</td><td> </td><td class="right">/** The odp_tm_wred_params_t record type is used to supply the parameters</td></tr>
      <tr><td class="left"> * associated with a Random Early Detection profile.  Since it is expected 
that</td><td> </td><td class="right"> * associated with a Random Early Detection profile.  Since it is expected 
that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_wred_params_init() be cal
led</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_wred_params_init() be cal
led</td></tr>
      <tr><td class="left"> * on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l9" /><small>skipping to change at</small><em> line 1124</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 1124</em></th></tr>
      <tr><td class="left">        * is false, WRED will use the queue length (i.e. the number of</td><td> </td><td class="right">        * is false, WRED will use the queue length (i.e. the number of</td></tr>
      <tr><td class="left">        * packets in the queue) as the fullness criterion.  Often will be s
et</td><td> </td><td class="right">        * packets in the queue) as the fullness criterion.  Often will be s
et</td></tr>
      <tr><td class="left">        * to true for WRED profiles applied to tm_queues and set to false f
or</td><td> </td><td class="right">        * to true for WRED profiles applied to tm_queues and set to false f
or</td></tr>
      <tr><td class="left">        * WRED profiles applied to tm_nodes. */</td><td> </td><td class="right">        * WRED profiles applied to tm_nodes. */</td></tr>
      <tr><td class="left">       odp_bool_t use_byte_fullness;</td><td> </td><td class="right">       odp_bool_t use_byte_fullness;</td></tr>
      <tr><td class="left">} odp_tm_wred_params_t;</td><td> </td><td class="right">} odp_tm_wred_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_wred_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_wred_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_wred_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_wred_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to an odp_tm_wred_params_t record which</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to an odp_tm_wred_params_t record which</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_wred_params_init(odp_tm_wred_params_t *params);</td><td> </td><td class="right">void odp_tm_wred_params_init(odp_tm_wred_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_wred_create() creates a WRED (Weighted Random Early Detection)</td><td> </td><td class="right">/** odp_tm_wred_create() creates a WRED (Weighted Random Early Detection)</td></tr>
      <tr><td class="left"> * profile object, which can subsequently be attached to any number (includ
ing</td><td> </td><td class="right"> * profile object, which can subsequently be attached to any number (includ
ing</td></tr>
      <tr><td class="left"> * zero) of tm_queues or tm_nodes.</td><td> </td><td class="right"> * zero) of tm_queues or tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name    Optional name associated with this WRED profile.  Can</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name    Optional name associated with this WRED profile.  Can</td></tr>
      <tr><td class="lblock"> *                    be NULL.  If non-NULL must be unique amongst the set </td><td> </td><td class="rblock"> *                be NULL.  If non-NULL must be unique amongst the set of</td></tr>
      <tr><td class="lblock">of</td><td> </td><td class="rblock"> *                all other WRED profiles.</td></tr>
      <tr><td class="lblock"> *                    all other WRED profiles.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  The profile parameters.  See comments associated with the</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  The profile parameters.  See comments associated with</td><td> </td><td class="rblock"> *                odp_tm_wred_params_t for more details.</td></tr>
      <tr><td class="lblock"> the</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="lblock"> *                    odp_tm_wred_params_t for more details.</td><td> </td><td class="rblock"> *                allocated odp_tm_wred_t value representing this <span class="insert">profile</span></td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="rblock"> *                object.</td></tr>
      <tr><td class="lblock"> *                    allocated odp_tm_wred_t value representing this <span class="delete">profi</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">le</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                    object.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_wred_t odp_tm_wred_create(const char *name,</td><td> </td><td class="right">odp_tm_wred_t odp_tm_wred_create(const char *name,</td></tr>
      <tr><td class="left">                                odp_tm_wred_params_t *params);</td><td> </td><td class="right">                                odp_tm_wred_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Destroy WRED profile object</td><td> </td><td class="right">/** Destroy WRED profile object</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_wred_destroy() function destroys/frees the given WRED</td><td> </td><td class="right"> * The odp_tm_wred_destroy() function destroys/frees the given WRED</td></tr>
      <tr><td class="left"> * profile object.  It is an error if this profile object is still being</td><td> </td><td class="right"> * profile object.  It is an error if this profile object is still being</td></tr>
      <tr><td class="left"> * referenced by an active (connected) tm_node.</td><td> </td><td class="right"> * referenced by an active (connected) tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> wred_profile   Specifies the WRED profile object which is</td><td> </td><td class="rblock"> * <span class="insert">@param</span> wred_profile   Specifies the WRED profile object which is</td></tr>
      <tr><td class="lblock"> *                            being destroyed.</td><td> </td><td class="rblock"> *                       being destroyed.</td></tr>
      <tr><td class="lblock"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="rblock"> * @return               Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_wred_destroy(odp_tm_wred_t wred_profile);</td><td> </td><td class="right">int odp_tm_wred_destroy(odp_tm_wred_t wred_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_wred_params_read() "gets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_wred_params_read() "gets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified WRED profile object, and copies them into the supplie
d</td><td> </td><td class="right"> * with the specified WRED profile object, and copies them into the supplie
d</td></tr>
      <tr><td class="left"> * record.</td><td> </td><td class="right"> * record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  wred_profile  Specifies the WRED profile object whose</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  wred_profile  Specifies the WRED profile object whose</td></tr>
      <tr><td class="left"> *                           values are to be read.</td><td> </td><td class="right"> *                           values are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params        A pointer to an odp_tm_wred_params_t record</td><td> </td><td class="right"> * @param[out] params        A pointer to an odp_tm_wred_params_t record</td></tr>
      <tr><td class="left"> *                           where the current WRED profile object values</td><td> </td><td class="right"> *                           where the current WRED profile object values</td></tr>
      <tr><td class="left"> *                           are copied to.</td><td> </td><td class="right"> *                           are copied to.</td></tr>
      <tr><td class="left"> * @return                   Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="right"> * @return                   Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_wred_params_read(odp_tm_wred_t wred_profile,</td><td> </td><td class="right">int odp_tm_wred_params_read(odp_tm_wred_t wred_profile,</td></tr>
      <tr><td class="left">                           odp_tm_wred_params_t *params);</td><td> </td><td class="right">                           odp_tm_wred_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_wred_params_update() "sets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_wred_params_update() "sets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified WRED profile object.  In addition, this call has the</td><td> </td><td class="right"> * with the specified WRED profile object.  In addition, this call has the</td></tr>
      <tr><td class="left"> * effect that all tm_input's and tm_nodes that are associated (attached?)</td><td> </td><td class="right"> * effect that all tm_input's and tm_nodes that are associated (attached?)</td></tr>
      <tr><td class="left"> * with this WRED profile object will be updated with the new values.</td><td> </td><td class="right"> * with this WRED profile object will be updated with the new values.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> wred_profile  Specifies the WRED profile object whose</td><td> </td><td class="rblock"> * <span class="insert">@param</span> wred_profile  Specifies the WRED profile object whose</td></tr>
      <tr><td class="lblock"> *                          values are to be set.</td><td> </td><td class="rblock"> *                      values are to be set.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params        A pointer to an odp_tm_wred_params_t record</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params        A pointer to an odp_tm_wred_params_t record</td></tr>
      <tr><td class="lblock"> *                          where the new WRED profile object values</td><td> </td><td class="rblock"> *                      where the new WRED profile object values</td></tr>
      <tr><td class="lblock"> *                          are taken from.</td><td> </td><td class="rblock"> *                      are taken from.</td></tr>
      <tr><td class="lblock"> * @return                  Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="rblock"> * @return              Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_wred_params_update(odp_tm_wred_t wred_profile,</td><td> </td><td class="right">int odp_tm_wred_params_update(odp_tm_wred_t wred_profile,</td></tr>
      <tr><td class="left">                             odp_tm_wred_params_t *params);</td><td> </td><td class="right">                             odp_tm_wred_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_wred_lookup() can be used to find the WRED profile object create
d</td><td> </td><td class="right">/** odp_tm_wred_lookup() can be used to find the WRED profile object create
d</td></tr>
      <tr><td class="left"> * with the specified name.</td><td> </td><td class="right"> * with the specified name.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name  Name of a previously created WRED profile.  Cannot be</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name  Name of a previously created WRED profile.  Cannot be NULL.</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                  NULL.</td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"> * @return          Returns ODP_TM_INVALID upon failure, or the WRED</td><td> </td><td class="rblock"> * @return      Returns ODP_TM_INVALID upon failure, or the WRED</td></tr>
      <tr><td class="lblock"> *                  profile handle created with this name.</td><td> </td><td class="rblock"> *              profile handle created with this name.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_wred_t odp_tm_wred_lookup(const char *name);</td><td> </td><td class="right">odp_tm_wred_t odp_tm_wred_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_params_t record type is used to hold extra parameters w
hen</td><td> </td><td class="right">/** The odp_tm_node_params_t record type is used to hold extra parameters w
hen</td></tr>
      <tr><td class="left"> * calling the odp_tm_node_create() function.  Many of these fields are</td><td> </td><td class="right"> * calling the odp_tm_node_create() function.  Many of these fields are</td></tr>
      <tr><td class="left"> * optional EXCEPT for max_fanin and level.  Also since it is expected that</td><td> </td><td class="right"> * optional EXCEPT for max_fanin and level.  Also since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_node_params_init() be cal
led</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_node_params_init() be cal
led</td></tr>
      <tr><td class="left"> * on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l10" /><small>skipping to change at</small><em> line 1240</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 1240</em></th></tr>
      <tr><td class="left">        * must be in range 0..max_levels-1.  Note that the tm_node topology</td><td> </td><td class="right">        * must be in range 0..max_levels-1.  Note that the tm_node topology</td></tr>
      <tr><td class="left">        * is constrained such that only tm_node outputs with numerically</td><td> </td><td class="right">        * is constrained such that only tm_node outputs with numerically</td></tr>
      <tr><td class="left">        * greater levels may be connected to the fan-in of tm_node's with</td><td> </td><td class="right">        * greater levels may be connected to the fan-in of tm_node's with</td></tr>
      <tr><td class="left">        * numerically smaller levels. */</td><td> </td><td class="right">        * numerically smaller levels. */</td></tr>
      <tr><td class="left">       uint8_t level;</td><td> </td><td class="right">       uint8_t level;</td></tr>
      <tr><td class="left">} odp_tm_node_params_t;</td><td> </td><td class="right">} odp_tm_node_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_node_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_node_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_node_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_node_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to an odp_tm_node_params_t record which</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to an odp_tm_node_params_t record which</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_node_params_init(odp_tm_node_params_t *params);</td><td> </td><td class="right">void odp_tm_node_params_init(odp_tm_node_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Create an tm_node with a specific set of implemented strict priority</td><td> </td><td class="right">/** Create an tm_node with a specific set of implemented strict priority</td></tr>
      <tr><td class="left"> * levels as given by the priorities array parameter.  The set of priority</td><td> </td><td class="right"> * levels as given by the priorities array parameter.  The set of priority</td></tr>
      <tr><td class="left"> * levels does not have to "contiguous", but the "priorities" values for al
l</td><td> </td><td class="right"> * levels does not have to "contiguous", but the "priorities" values for al
l</td></tr>
      <tr><td class="left"> * indexes &gt; max_priority MUST be FALSE.  Note that the set of implemented</td><td> </td><td class="right"> * indexes &gt; max_priority MUST be FALSE.  Note that the set of implemented</td></tr>
      <tr><td class="left"> * strict priority levels for an tm_node cannot be changed after tm_node</td><td> </td><td class="right"> * strict priority levels for an tm_node cannot be changed after tm_node</td></tr>
      <tr><td class="left"> * creation.  The level parameter MUST be in the range 0..max_level - 1.</td><td> </td><td class="right"> * creation.  The level parameter MUST be in the range 0..max_level - 1.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm  Odp_tm is used to identify the TM system into which <span class="delete">t</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm  Odp_tm is used to identify the TM system into which <span class="insert">this</span></td></tr>
      <tr><td class="lblock"><span class="delete">his</span></td><td> </td><td class="rblock"> *                odp_tm_node object is created.</td></tr>
      <tr><td class="lblock"> *                    odp_tm_node object is created.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name    Optional name that can be used later later to find <span class="insert">this</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name    Optional name that can be used later later to find <span class="delete">th</span></td><td> </td><td class="rblock"> *                same odp_tm_node_t.  Can be NULL, otherwise must be</td></tr>
      <tr><td class="lblock"><span class="delete">is</span></td><td> </td><td class="rblock"> *                unique across all odp_tm_node objects.</td></tr>
      <tr><td class="lblock"> *                    same odp_tm_node_t.  Can be NULL, otherwise must be</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to a record holding (an extensible) set of</td></tr>
      <tr><td class="lblock"> *                    unique across all odp_tm_node objects.</td><td> </td><td class="rblock"> *                properties/attributes of this tm_node.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to a record holding (an extensible) set of</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, otherwise <span class="insert">returns</span></td></tr>
      <tr><td class="lblock"> *                    properties/attributes of this tm_node.</td><td> </td><td class="rblock"> *                a valid odp_tm_node_t handle if successful.</td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, otherwise <span class="delete">return</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">s</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                    a valid odp_tm_node_t handle if successful.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_node_t odp_tm_node_create(odp_tm_t              odp_tm,</td><td> </td><td class="right">odp_tm_node_t odp_tm_node_create(odp_tm_t              odp_tm,</td></tr>
      <tr><td class="left">                                const char           *name,</td><td> </td><td class="right">                                const char           *name,</td></tr>
      <tr><td class="left">                                odp_tm_node_params_t *params);</td><td> </td><td class="right">                                odp_tm_node_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Destroy  a tm_node object.</td><td> </td><td class="right">/** Destroy  a tm_node object.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_node_destroy frees the resources used by a tm_node_t object.</td><td> </td><td class="right"> * The odp_tm_node_destroy frees the resources used by a tm_node_t object.</td></tr>
      <tr><td class="left"> * The tm_node to be destroyed MUST not have any parent or child entities.</td><td> </td><td class="right"> * The tm_node to be destroyed MUST not have any parent or child entities.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node  Specifies the tm_node to be destroyed (freed).</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node  Specifies the tm_node to be destroyed (freed).</td></tr>
      <tr><td class="lblock"> * @return             Returns -1 upon failure, 0 upon success.</td><td> </td><td class="rblock"> * @return         Returns -1 upon failure, 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_destroy(odp_tm_node_t tm_node);</td><td> </td><td class="right">int odp_tm_node_destroy(odp_tm_node_t tm_node);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_shaper_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_node_shaper_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the shaper profile associated with this tm_node.</td><td> </td><td class="right"> * change the shaper profile associated with this tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node         Specifies the tm_node to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node         Specifies the tm_node to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> shaper_profile  Specifies the shaper profile that should</td><td> </td><td class="rblock"> * <span class="insert">@param</span> shaper_profile  Specifies the shaper profile that should</td></tr>
      <tr><td class="lblock"> *                            now be used for the shaper entity within the</td><td> </td><td class="rblock"> *                        now be used for the shaper entity within the</td></tr>
      <tr><td class="lblock"> *                            given tm_node.  Note that it is legal to <span class="delete">spec</span></td><td> </td><td class="rblock"> *                        given tm_node.  Note that it is legal to <span class="insert">specify</span></td></tr>
      <tr><td class="lblock"><span class="delete">ify</span></td><td> </td><td class="rblock"> *                        ODP_TM_INVALID indicating that this tm_node</td></tr>
      <tr><td class="lblock"> *                            ODP_TM_INVALID indicating that this tm_node</td><td> </td><td class="rblock"> *                        no longer implements a shaper function.</td></tr>
      <tr><td class="lblock"> *                            no longer implements a shaper function.</td><td> </td><td class="rblock"> * @return                Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_shaper_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_node_shaper_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                             odp_tm_shaper_t shaper_profile);</td><td> </td><td class="right">                             odp_tm_shaper_t shaper_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_sched_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_node_sched_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the scheduler profile associated with a tm_node.</td><td> </td><td class="right"> * change the scheduler profile associated with a tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node         Specifies the tm_node to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node         Specifies the tm_node to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_fan_in_node  Specifies which of the specified tm_node's</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_fan_in_node  Specifies which of the specified tm_node's</td></tr>
      <tr><td class="lblock"> *                            fan-in's weights etc are to be changed. The</td><td> </td><td class="rblock"> *                        fan-in's weights etc are to be changed. The</td></tr>
      <tr><td class="lblock"> *                            fan-in is identified by the "producer"/parent</td><td> </td><td class="rblock"> *                        fan-in is identified by the "producer"/parent</td></tr>
      <tr><td class="lblock"> *                            tm_node actually connected to this fan-in.</td><td> </td><td class="rblock"> *                        tm_node actually connected to this fan-in.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> sched_profile   Specifies the scheduler profile that should</td><td> </td><td class="rblock"> * <span class="insert">@param</span> sched_profile   Specifies the scheduler profile that should</td></tr>
      <tr><td class="lblock"> *                            now be used for the WFQ/RR entity within the</td><td> </td><td class="rblock"> *                        now be used for the WFQ/RR entity within the</td></tr>
      <tr><td class="lblock"> *                            given tm_node.</td><td> </td><td class="rblock"> *                        given tm_node.</td></tr>
      <tr><td class="lblock"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"> * @return                Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_sched_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_node_sched_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                            odp_tm_node_t tm_fan_in_node,</td><td> </td><td class="right">                            odp_tm_node_t tm_fan_in_node,</td></tr>
      <tr><td class="left">                            odp_tm_sched_t sched_profile);</td><td> </td><td class="right">                            odp_tm_sched_t sched_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_threshold_config() function is used to dynamically set 
or</td><td> </td><td class="right">/** The odp_tm_node_threshold_config() function is used to dynamically set 
or</td></tr>
      <tr><td class="left"> * change the queue threshold profile associated with this tm_node.</td><td> </td><td class="right"> * change the queue threshold profile associated with this tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node             Specifies the tm_node to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node             Specifies the tm_node to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> thresholds_profile  Specifies the queue threshold profile <span class="delete">tha</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> thresholds_profile  Specifies the queue threshold profile <span class="insert">that</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"> *                            should now be used for the given tm_node.</td></tr>
      <tr><td class="lblock"> *                                should now be used for the given tm_node.</td><td> </td><td class="rblock"> * @return                    Returns 0 upon success and &lt; 0 upon <span class="insert">failure.</span></td></tr>
      <tr><td class="lblock"> * @return                        Returns 0 upon success and &lt; 0 upon <span class="delete">failu</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">re.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_threshold_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_node_threshold_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                                odp_tm_threshold_t thresholds_profile);</td><td> </td><td class="right">                                odp_tm_threshold_t thresholds_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_wred_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_node_wred_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the WRED profile associated with this tm_node or tm_node/pkt_colo
r</td><td> </td><td class="right"> * change the WRED profile associated with this tm_node or tm_node/pkt_colo
r</td></tr>
      <tr><td class="left"> * combination.</td><td> </td><td class="right"> * combination.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node       Specifies the tm_node to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node       Specifies the tm_node to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> pkt_color     Specifies the pkt_color that this profile is to</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pkt_color     Specifies the pkt_color that this profile is to be</td></tr>
      <tr><td class="lblock"> be</td><td> </td><td class="rblock"> *                      used with.  Can also be the special value</td></tr>
      <tr><td class="lblock"> *                          used with.  Can also be the special value</td><td> </td><td class="rblock"> *                      ALL_PKT_COLORS.</td></tr>
      <tr><td class="lblock"> *                          ALL_PKT_COLORS.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> wred_profile  Specifies the WRED profile that should now be <span class="insert">used</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> wred_profile  Specifies the WRED profile that should now be <span class="delete">u</span></td><td> </td><td class="rblock"> *                      by this tm_queue, when processing pkts of this</td></tr>
      <tr><td class="lblock"><span class="delete">sed</span></td><td> </td><td class="rblock"> *                      pkt_color.  It can be the value ODP_TM_INVALID</td></tr>
      <tr><td class="lblock"> *                          by this tm_queue, when processing pkts of this</td><td> </td><td class="rblock"> *                      indicating that this tm_queue/pkt_color <span class="insert">combination</span></td></tr>
      <tr><td class="lblock"> *                          pkt_color.  It can be the value ODP_TM_INVALID</td><td> </td><td class="rblock"> *                      no longer implements WRED.</td></tr>
      <tr><td class="lblock"> *                          indicating that this tm_queue/pkt_color <span class="delete">combina</span></td><td> </td><td class="rblock"> * @return              Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"><span class="delete">tion</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          no longer implements WRED.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                  Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_wred_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_node_wred_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                           odp_packet_color_t pkt_color,</td><td> </td><td class="right">                           odp_packet_color_t pkt_color,</td></tr>
      <tr><td class="left">                           odp_tm_wred_t wred_profile);</td><td> </td><td class="right">                           odp_tm_wred_t wred_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_node_lookup() can be used to find the tm_node object created wit
h</td><td> </td><td class="right">/** odp_tm_node_lookup() can be used to find the tm_node object created wit
h</td></tr>
      <tr><td class="left"> * the specified name.</td><td> </td><td class="right"> * the specified name.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm  Odp_tm is used to identify the TM system into which <span class="delete">t</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm  Odp_tm is used to identify the TM system into which <span class="insert">this</span></td></tr>
      <tr><td class="lblock"><span class="delete">his</span></td><td> </td><td class="rblock"> *                odp_tm_node object is created.</td></tr>
      <tr><td class="lblock"> *                    odp_tm_node object is created.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> name    Name of a previously created tm_node.  Cannot be NULL.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> name    Name of a previously created tm_node.  Cannot be</td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                    NULL.</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, or the tm_node</td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, or the tm_node</td><td> </td><td class="rblock"> *                handle created with this name.</td></tr>
      <tr><td class="lblock"> *                    handle created with this name.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_node_t odp_tm_node_lookup(odp_tm_t odp_tm, const char *name);</td><td> </td><td class="right">odp_tm_node_t odp_tm_node_lookup(odp_tm_t odp_tm, const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_node_context() can be used to get the user_context value that is</td><td> </td><td class="right">/** odp_tm_node_context() can be used to get the user_context value that is</td></tr>
      <tr><td class="left"> * associated with the given tm_node.</td><td> </td><td class="right"> * associated with the given tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node Specifies the tm_node whose user_context is to be <span class="delete">got</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node Specifies the tm_node whose user_context is to be <span class="insert">gotten.</span></td></tr>
      <tr><td class="lblock"><span class="delete">ten.</span></td><td> </td><td class="rblock"> * @return        Returns the user_context pointer associated with this</td></tr>
      <tr><td class="lblock"> * @return            Returns the user_context pointer associated with this</td><td> </td><td class="rblock"> *                tm_node.  Returns NULL if the tm_node is not valid OR</td></tr>
      <tr><td class="lblock"> *                    tm_node.  Returns NULL if the tm_node is not valid OR</td><td> </td><td class="rblock"> *                if the user_context was <span class="insert">NULL.</span></td></tr>
      <tr><td class="lblock"> *                    if the user_context was <span class="delete">NLL.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *                    handle created with this name.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_tm_node_context(odp_tm_node_t tm_node);</td><td> </td><td class="right">void *odp_tm_node_context(odp_tm_node_t tm_node);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_node_context_set() can be used to set the user_context value tha
t is</td><td> </td><td class="right">/** odp_tm_node_context_set() can be used to set the user_context value tha
t is</td></tr>
      <tr><td class="left"> * associated with the given tm_node.</td><td> </td><td class="right"> * associated with the given tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node Specifies the tm_node whose user_context is to be <span class="delete">set</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node       Specifies the tm_node whose user_context is to be <span class="insert">s</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"><span class="insert">et.</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> user_context  Generic pointer associated with the given <span class="delete">tm_no</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> user_context  Generic pointer associated with the given <span class="insert">tm_node.</span></td></tr>
      <tr><td class="lblock"><span class="delete">de.</span></td><td> </td><td class="rblock"> *                      Does not have any effect on the tm_node <span class="insert">semantics.</span></td></tr>
      <tr><td class="lblock"> *                          Does not have any effect on the tm_node <span class="delete">semanti</span></td><td> </td><td class="rblock"> * @return              Returns 0 upon success and -1 if the given <span class="insert">tm_node</span></td></tr>
      <tr><td class="lblock"><span class="delete">cs.</span></td><td> </td><td class="rblock"> *                      is not valid.</td></tr>
      <tr><td class="lblock"> * @return                  Returns 0 upon success and -1 if the given <span class="delete">tm_n</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">ode</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          is not valid.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_context_set(odp_tm_node_t tm_node, void *user_context);</td><td> </td><td class="right">int odp_tm_node_context_set(odp_tm_node_t tm_node, void *user_context);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_params_t record type is used to hold extra parameters</td><td> </td><td class="right">/** The odp_tm_queue_params_t record type is used to hold extra parameters</td></tr>
      <tr><td class="left"> * when calling the odp_tm_queue_create() function.  Many of these fields a
re</td><td> </td><td class="right"> * when calling the odp_tm_queue_create() function.  Many of these fields a
re</td></tr>
      <tr><td class="left"> * optional EXCEPT for priority.  Also since it is expected that</td><td> </td><td class="right"> * optional EXCEPT for priority.  Also since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_queue_params_init() be</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_queue_params_init() be</td></tr>
      <tr><td class="left"> * called on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * called on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l11" /><small>skipping to change at</small><em> line 1409</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 1408</em></th></tr>
      <tr><td class="left">       /** The strict priority level assigned to packets in this tm_queue -</td><td> </td><td class="right">       /** The strict priority level assigned to packets in this tm_queue -</td></tr>
      <tr><td class="left">        * in other words all packets associated with a given tm_queue MUST</td><td> </td><td class="right">        * in other words all packets associated with a given tm_queue MUST</td></tr>
      <tr><td class="left">        * have the same single strict priority level and this level must be</td><td> </td><td class="right">        * have the same single strict priority level and this level must be</td></tr>
      <tr><td class="left">        * in the range 0..max_priority. */</td><td> </td><td class="right">        * in the range 0..max_priority. */</td></tr>
      <tr><td class="left">       uint8_t priority;</td><td> </td><td class="right">       uint8_t priority;</td></tr>
      <tr><td class="left">} odp_tm_queue_params_t;</td><td> </td><td class="right">} odp_tm_queue_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_queue_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_queue_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_queue_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_queue_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to an odp_tm_queue_params_t record which</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to an odp_tm_queue_params_t record which</td></tr>
      <tr><td class="lblock"> *                    is to be initialized.</td><td> </td><td class="rblock"> *                is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_queue_params_init(odp_tm_queue_params_t *params);</td><td> </td><td class="right">void odp_tm_queue_params_init(odp_tm_queue_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Create an tm_queue object.  One can specify the maximum queue limits</td><td> </td><td class="right">/** Create an tm_queue object.  One can specify the maximum queue limits</td></tr>
      <tr><td class="left"> * either as a maximum number of packets in the queue OR as a maximum numbe
r</td><td> </td><td class="right"> * either as a maximum number of packets in the queue OR as a maximum numbe
r</td></tr>
      <tr><td class="left"> * of bytes in the queue, or if both are specified, then whichever limit is</td><td> </td><td class="right"> * of bytes in the queue, or if both are specified, then whichever limit is</td></tr>
      <tr><td class="left"> * hit first.  Note that in the case of specifying the maximum queue memory</td><td> </td><td class="right"> * hit first.  Note that in the case of specifying the maximum queue memory</td></tr>
      <tr><td class="left"> * size as bytes, the system is free to instead convert this byte value int
o a</td><td> </td><td class="right"> * size as bytes, the system is free to instead convert this byte value int
o a</td></tr>
      <tr><td class="left"> * number of buffers and instead limit the queue memory usage by buffer cou
nts</td><td> </td><td class="right"> * number of buffers and instead limit the queue memory usage by buffer cou
nts</td></tr>
      <tr><td class="left"> * versus strictly using byte counts.</td><td> </td><td class="right"> * versus strictly using byte counts.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm  Odp_tm is used to identify the TM system into which <span class="delete">t</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm  Odp_tm is used to identify the TM system into which <span class="insert">this</span></td></tr>
      <tr><td class="lblock"><span class="delete">his</span></td><td> </td><td class="rblock"> *                odp_tm_queue object is created.</td></tr>
      <tr><td class="lblock"> *                    odp_tm_queue object is created.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> params  A pointer to a record holding (an extensible) set of</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> params  A pointer to a record holding (an extensible) set of</td><td> </td><td class="rblock"> *                properties/attributes of this tm_queue.</td></tr>
      <tr><td class="lblock"> *                    properties/attributes of this tm_queue.</td><td> </td><td class="rblock"> * @return        Returns ODP_TM_INVALID upon failure, otherwise a <span class="insert">valid</span></td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, otherwise a <span class="delete">vali</span></td><td> </td><td class="rblock"> *                odp_tm_queue_t handle.</td></tr>
      <tr><td class="lblock"><span class="delete">d</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                    odp_tm_queue_t handle.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_queue_t odp_tm_queue_create(odp_tm_t odp_tm,</td><td> </td><td class="right">odp_tm_queue_t odp_tm_queue_create(odp_tm_t odp_tm,</td></tr>
      <tr><td class="left">                                  odp_tm_queue_params_t *params);</td><td> </td><td class="right">                                  odp_tm_queue_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Destroy an tm_queue object. The odp_tm_queue_destroy frees the resource
s</td><td> </td><td class="right">/** Destroy an tm_queue object. The odp_tm_queue_destroy frees the resource
s</td></tr>
      <tr><td class="left"> * used by a tm_queue_t object.  The tm_queue to be destroyed MUST not be</td><td> </td><td class="right"> * used by a tm_queue_t object.  The tm_queue to be destroyed MUST not be</td></tr>
      <tr><td class="left"> * connected in a tm system, and consequently cannot contain any pkts.</td><td> </td><td class="right"> * connected in a tm system, and consequently cannot contain any pkts.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue  Specifies the tm_queue to be destroyed (freed).</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue  Specifies the tm_queue to be destroyed (freed).</td></tr>
      <tr><td class="lblock"> * @return              Returns -1 upon failure, 0 upon success.</td><td> </td><td class="rblock"> * @return          Returns -1 upon failure, 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_destroy(odp_tm_queue_t tm_queue);</td><td> </td><td class="right">int odp_tm_queue_destroy(odp_tm_queue_t tm_queue);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_queue_context() can be used to get the user_context value that i
s</td><td> </td><td class="right">/** odp_tm_queue_context() can be used to get the user_context value that i
s</td></tr>
      <tr><td class="left"> * associated with the given tm_queue.</td><td> </td><td class="right"> * associated with the given tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue  Specifies the tm_queue whose user_context is to be</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue  Specifies the tm_queue whose user_context is to be</td></tr>
      <tr><td class="lblock"> *                      returned.</td><td> </td><td class="rblock"> *                  returned.</td></tr>
      <tr><td class="lblock"> * @return              Returns the user_context pointer associated with <span class="delete">th</span></td><td> </td><td class="rblock"> * @return          Returns the user_context pointer associated with <span class="insert">this</span></td></tr>
      <tr><td class="lblock"><span class="delete">is</span></td><td> </td><td class="rblock"> *                  tm_queue.  Returns NULL if the tm_quue is not valid OR</td></tr>
      <tr><td class="lblock"> *                      tm_queue.  Returns NULL if the tm_quue is not valid</td><td> </td><td class="rblock"> *                  if the user_context was NULL.</td></tr>
      <tr><td class="lblock"> OR</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                      if the user_context was NULL.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_tm_queue_context(odp_tm_queue_t tm_queue);</td><td> </td><td class="right">void *odp_tm_queue_context(odp_tm_queue_t tm_queue);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_queue_context_set() can be used to set the user_context value th
at is</td><td> </td><td class="right">/** odp_tm_queue_context_set() can be used to set the user_context value th
at is</td></tr>
      <tr><td class="left"> * associated with the given tm_queue.</td><td> </td><td class="right"> * associated with the given tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue      Specifies the tm_queue whose user_context is to</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue      Specifies the tm_queue whose user_context is to be </td></tr>
      <tr><td class="lblock"> be</td><td> </td><td class="rblock">set.</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                          set.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> user_context  Generic pointer associated with the given <span class="insert">tm_queue.</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> user_context  Generic pointer associated with the given <span class="delete">tm_qu</span></td><td> </td><td class="rblock"> *                      Does not have any effect on the tm_queue <span class="insert">semantics.</span></td></tr>
      <tr><td class="lblock"><span class="delete">eue.</span></td><td> </td><td class="rblock"> * @return              Returns 0 upon success and -1 if the given <span class="insert">tm_queue</span></td></tr>
      <tr><td class="lblock"> *                          Does not have any effect on the tm_queue <span class="delete">semant</span></td><td> </td><td class="rblock"> *                      is not valid.</td></tr>
      <tr><td class="lblock"><span class="delete">ics.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                  Returns 0 upon success and -1 if the given <span class="delete">tm_q</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">ueu</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          is not valid.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_context_set(odp_tm_queue_t tm_queue, void *user_context);</td><td> </td><td class="right">int odp_tm_queue_context_set(odp_tm_queue_t tm_queue, void *user_context);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_shaper_config() function is used to dynamically set</td><td> </td><td class="right">/** The odp_tm_queue_shaper_config() function is used to dynamically set</td></tr>
      <tr><td class="left"> * or change the shaper profile associated with this tm_queue.</td><td> </td><td class="right"> * or change the shaper profile associated with this tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue        Specifies the tm_queue to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue        Specifies the tm_queue to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> shaper_profile  Specifies the shaper profile that should now </td><td> </td><td class="rblock"> * <span class="insert">@param</span> shaper_profile  Specifies the shaper profile that should now be</td></tr>
      <tr><td class="lblock">be</td><td> </td><td class="rblock"> *                        used for shaping the tm_queue's packet <span class="insert">stream.</span></td></tr>
      <tr><td class="lblock"> *                            used for shaping the tm_queue's packet <span class="delete">stream</span></td><td> </td><td class="rblock"> *                        Note that it is legal to specify <span class="insert">ODP_TM_INVALID</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"> *                        indicating that this tm_queue no longer</td></tr>
      <tr><td class="lblock"> *                            Note that it is legal to specify <span class="delete">ODP_TM_INVAL</span></td><td> </td><td class="rblock"> *                        implements a shaper function.</td></tr>
      <tr><td class="lblock"><span class="delete">ID</span></td><td> </td><td class="rblock"> * @return                Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"> *                            indicating that this tm_queue no longer</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                            implements a shaper function.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_shaper_config(odp_tm_queue_t tm_queue,</td><td> </td><td class="right">int odp_tm_queue_shaper_config(odp_tm_queue_t tm_queue,</td></tr>
      <tr><td class="left">                              odp_tm_shaper_t shaper_profile);</td><td> </td><td class="right">                              odp_tm_shaper_t shaper_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_sched_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_queue_sched_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the scheduler profile associated with a tm_node.  Note that despi
te</td><td> </td><td class="right"> * change the scheduler profile associated with a tm_node.  Note that despi
te</td></tr>
      <tr><td class="left"> * the name, this function affects a tm_node scheduler - specifically the</td><td> </td><td class="right"> * the name, this function affects a tm_node scheduler - specifically the</td></tr>
      <tr><td class="left"> * scheduler fan-in when such fan-in comes from an tm_queue.</td><td> </td><td class="right"> * scheduler fan-in when such fan-in comes from an tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_node         Specifies the tm_node to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_node         Specifies the tm_node to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_fan_in_queue Specifies which of the specified tm_node's</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_fan_in_queue Specifies which of the specified tm_node's</td></tr>
      <tr><td class="lblock"> *                            fan-in's weights etc are to be changed. The</td><td> </td><td class="rblock"> *                        fan-in's weights etc are to be changed. The</td></tr>
      <tr><td class="lblock"> *                            fan-in is identified by the "producer"/parent</td><td> </td><td class="rblock"> *                        fan-in is identified by the "producer"/parent</td></tr>
      <tr><td class="lblock"> *                            tm_queue actually connected to this fan-in.</td><td> </td><td class="rblock"> *                        tm_queue actually connected to this fan-in.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> sched_profile   Specifies the scheduler profile that should</td><td> </td><td class="rblock"> * <span class="insert">@param</span> sched_profile   Specifies the scheduler profile that should</td></tr>
      <tr><td class="lblock"> *                            now be used for the WFQ/RR entity within the</td><td> </td><td class="rblock"> *                        now be used for the WFQ/RR entity within the</td></tr>
      <tr><td class="lblock"> *                            given tm_node.</td><td> </td><td class="rblock"> *                        given tm_node.</td></tr>
      <tr><td class="lblock"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"> * @return                Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_sched_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_queue_sched_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                             odp_tm_queue_t tm_fan_in_queue,</td><td> </td><td class="right">                             odp_tm_queue_t tm_fan_in_queue,</td></tr>
      <tr><td class="left">                             odp_tm_sched_t sched_profile);</td><td> </td><td class="right">                             odp_tm_sched_t sched_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_threshold_config() function is used to dynamically set
 or</td><td> </td><td class="right">/** The odp_tm_queue_threshold_config() function is used to dynamically set
 or</td></tr>
      <tr><td class="left"> * change the queue threshold profile associated with this tm_queue.</td><td> </td><td class="right"> * change the queue threshold profile associated with this tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue            Specifies the tm_queue to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue            Specifies the tm_queue to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> thresholds_profile  Specifies the queue threshold profile <span class="delete">tha</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> thresholds_profile  Specifies the queue threshold profile <span class="insert">that</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"> *                            should now be used for the given <span class="insert">tm_queue.</span></td></tr>
      <tr><td class="lblock"> *                                should now be used for the given <span class="delete">tm_queue</span></td><td> </td><td class="rblock"> * @return                    Returns 0 upon success and &lt; 0 upon <span class="insert">failure.</span></td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                        Returns 0 upon success and &lt; 0 upon <span class="delete">failu</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">re.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_threshold_config(odp_tm_queue_t tm_queue,</td><td> </td><td class="right">int odp_tm_queue_threshold_config(odp_tm_queue_t tm_queue,</td></tr>
      <tr><td class="left">                                 odp_tm_threshold_t thresholds_profile);</td><td> </td><td class="right">                                 odp_tm_threshold_t thresholds_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_queue_wred_config() function is used to dynamically set or chang
e</td><td> </td><td class="right">/** odp_tm_queue_wred_config() function is used to dynamically set or chang
e</td></tr>
      <tr><td class="left"> * the WRED profile associated with this tm_queue or tm_queue/pkt_color</td><td> </td><td class="right"> * the WRED profile associated with this tm_queue or tm_queue/pkt_color</td></tr>
      <tr><td class="left"> * combination.</td><td> </td><td class="right"> * combination.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue      Specifies the tm_queue to be changed.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue      Specifies the tm_queue to be changed.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> pkt_color     Specifies the pkt_color that this profile is to</td><td> </td><td class="rblock"> * <span class="insert">@param</span> pkt_color     Specifies the pkt_color that this profile is to be</td></tr>
      <tr><td class="lblock"> be</td><td> </td><td class="rblock"> *                      used with.  Can also be the special value</td></tr>
      <tr><td class="lblock"> *                          used with.  Can also be the special value</td><td> </td><td class="rblock"> *                      ALL_PKT_COLORS.</td></tr>
      <tr><td class="lblock"> *                          ALL_PKT_COLORS.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> wred_profile  Specifies the WRED profile that should now be <span class="insert">used</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> wred_profile  Specifies the WRED profile that should now be <span class="delete">u</span></td><td> </td><td class="rblock"> *                      by this tm_queue, when processing pkts of this</td></tr>
      <tr><td class="lblock"><span class="delete">sed</span></td><td> </td><td class="rblock"> *                      pkt_color.  It can be the value ODP_TM_INVALID</td></tr>
      <tr><td class="lblock"> *                          by this tm_queue, when processing pkts of this</td><td> </td><td class="rblock"> *                      indicating that this tm_queue/pkt_color <span class="insert">combination</span></td></tr>
      <tr><td class="lblock"> *                          pkt_color.  It can be the value ODP_TM_INVALID</td><td> </td><td class="rblock"> *                      no longer implements WRED.</td></tr>
      <tr><td class="lblock"> *                          indicating that this tm_queue/pkt_color <span class="delete">combina</span></td><td> </td><td class="rblock"> * @return              Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"><span class="delete">tion</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                          no longer implements WRED.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                  Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_wred_config(odp_tm_queue_t tm_queue,</td><td> </td><td class="right">int odp_tm_queue_wred_config(odp_tm_queue_t tm_queue,</td></tr>
      <tr><td class="left">                            odp_packet_color_t pkt_color,</td><td> </td><td class="right">                            odp_packet_color_t pkt_color,</td></tr>
      <tr><td class="left">                            odp_tm_wred_t wred_profile);</td><td> </td><td class="right">                            odp_tm_wred_t wred_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Topology setting functions */</td><td> </td><td class="right">/** Topology setting functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Connects two tm_nodes</td><td> </td><td class="right">/** Connects two tm_nodes</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Connects the "output" of the src_tm_node to be a "producer" of the given</td><td> </td><td class="right"> * Connects the "output" of the src_tm_node to be a "producer" of the given</td></tr>
      <tr><td class="left"> * dst_tm_node.  Note that an ODP_TM_ROOT handle passed in for the</td><td> </td><td class="right"> * dst_tm_node.  Note that an ODP_TM_ROOT handle passed in for the</td></tr>
      <tr><td class="left"> * dst_tm_node implies connection to the egress/root object of this TM syst
em.</td><td> </td><td class="right"> * dst_tm_node implies connection to the egress/root object of this TM syst
em.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> src_tm_node  odp_tm_node_t handle of the tm_node whose output</td><td> </td><td class="rblock"> * <span class="insert">@param</span> src_tm_node  odp_tm_node_t handle of the tm_node whose output is</td></tr>
      <tr><td class="lblock"> is</td><td> </td><td class="rblock"> *                     to be connected to the fan-in of the next <span class="insert">tm_node</span></td></tr>
      <tr><td class="lblock"> *                         to be connected to the fan-in of the next <span class="delete">tm_nod</span></td><td> </td><td class="rblock"> *                     as represented by the dst_tm_node.</td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> dst_tm_node  odp_tm_node_t handle of the tm_node object that will</td></tr>
      <tr><td class="lblock"> *                         as represented by the dst_tm_node.</td><td> </td><td class="rblock"> *                     receive all of the pkt_descs from the src <span class="insert">tm_node</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> dst_tm_node  odp_tm_node_t handle of the tm_node object that </td><td> </td><td class="rblock"> *                     output.  If ODP_TM_ROOT, then attachment is to</td></tr>
      <tr><td class="lblock">will</td><td> </td><td class="rblock"> *                     the root egress object/spigot.</td></tr>
      <tr><td class="lblock"> *                         receive all of the pkt_descs from the src <span class="delete">tm_nod</span></td><td> </td><td class="rblock"> * @return             0 upon success, &lt; 0 on failure.</td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                         output.  If ODP_TM_ROOT, then attachment is to</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                         the root egress object/spigot.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                 0 upon success, &lt; 0 on failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_connect(odp_tm_node_t src_tm_node, odp_tm_node_t dst_tm_nod
e);</td><td> </td><td class="right">int odp_tm_node_connect(odp_tm_node_t src_tm_node, odp_tm_node_t dst_tm_nod
e);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Disconnect a tm_node to tm_node linkage.</td><td> </td><td class="right">/** Disconnect a tm_node to tm_node linkage.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_node_disconnect() function is used to disconnect a given</td><td> </td><td class="right"> * The odp_tm_node_disconnect() function is used to disconnect a given</td></tr>
      <tr><td class="left"> * tm_node from its fanout.  This function requires that no active, enabled</td><td> </td><td class="right"> * tm_node from its fanout.  This function requires that no active, enabled</td></tr>
      <tr><td class="left"> * tm_queue to be in the fanin tree (directly or indirectly) of this tm_nod
e.</td><td> </td><td class="right"> * tm_queue to be in the fanin tree (directly or indirectly) of this tm_nod
e.</td></tr>
      <tr><td class="left"> * Note that it is legal for this tm_node to no fanout connection.</td><td> </td><td class="right"> * Note that it is legal for this tm_node to no fanout connection.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> src_tm_node  odp_tm_node_t handle of the tm_node whose output</td><td> </td><td class="rblock"> * <span class="insert">@param</span> src_tm_node  odp_tm_node_t handle of the tm_node whose output is</td></tr>
      <tr><td class="lblock"> is</td><td> </td><td class="rblock"> *                     to be disconnected from the fan-in of the next <span class="insert">tm_no</span></td></tr>
      <tr><td class="lblock"> *                         to be disconnected from the fan-in of the next</td><td> </td><td class="rblock"><span class="insert">de.</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*                         tm_node.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0056" /></td></tr>
      <tr><td class="lblock"> * @return             <span class="delete">    </span>0 upon success, &lt; 0 on failure.</td><td> </td><td class="rblock"> * @return             0 upon success, &lt; 0 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_disconnect(odp_tm_node_t src_tm_node);</td><td> </td><td class="right">int odp_tm_node_disconnect(odp_tm_node_t src_tm_node);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_connect() function connects the indicated tm_queue to 
a</td><td> </td><td class="right">/** The odp_tm_queue_connect() function connects the indicated tm_queue to 
a</td></tr>
      <tr><td class="left"> * parent tm_node or to the egress/root node.  The tm_queue will then becom
e</td><td> </td><td class="right"> * parent tm_node or to the egress/root node.  The tm_queue will then becom
e</td></tr>
      <tr><td class="left"> * one of the dst node's fan-in set.</td><td> </td><td class="right"> * one of the dst node's fan-in set.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0057" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue     Specifies the tm_queue.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue     Specifies the tm_queue.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> dst_tm_node  odp_tm_node_t handle of the tm_node object that </td><td> </td><td class="rblock"> * <span class="insert">@param</span> dst_tm_node  odp_tm_node_t handle of the tm_node object that will</td></tr>
      <tr><td class="lblock">will</td><td> </td><td class="rblock"> *                     receive all of the pkt_descs from the src <span class="insert">tm_node</span></td></tr>
      <tr><td class="lblock"> *                         receive all of the pkt_descs from the src <span class="delete">tm_nod</span></td><td> </td><td class="rblock"> *                     output.  If ODP_TM_ROOT, then attachment is to</td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"> *                     the root egress object/spigot.</td></tr>
      <tr><td class="lblock"> *                         output.  If ODP_TM_ROOT, then attachment is to</td><td> </td><td class="rblock"> * @return             Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"> *                         the root egress object/spigot.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                 Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_connect(odp_tm_queue_t tm_queue, odp_tm_node_t dst_tm_node
);</td><td> </td><td class="right">int odp_tm_queue_connect(odp_tm_queue_t tm_queue, odp_tm_node_t dst_tm_node
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Disconnect a tm_queue from a tm_system.</td><td> </td><td class="right">/** Disconnect a tm_queue from a tm_system.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_queue_disconnect() function is used to disconnect a given</td><td> </td><td class="right"> * The odp_tm_queue_disconnect() function is used to disconnect a given</td></tr>
      <tr><td class="left"> * tm_queue from its fanout. Note that it is legal for this tm_queue to</td><td> </td><td class="right"> * tm_queue from its fanout. Note that it is legal for this tm_queue to</td></tr>
      <tr><td class="left"> * have no fanout connection.</td><td> </td><td class="right"> * have no fanout connection.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0058" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue     Specifies the tm_queue.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue     Specifies the tm_queue.</td></tr>
      <tr><td class="lblock"> * @return                 0 upon success, &lt; 0 on failure.</td><td> </td><td class="rblock"> * @return             0 upon success, &lt; 0 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_disconnect(odp_tm_queue_t tm_queue);</td><td> </td><td class="right">int odp_tm_queue_disconnect(odp_tm_queue_t tm_queue);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Input API */</td><td> </td><td class="right">/** Input API */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_enq() function is used to add packets to a given TM system.</td><td> </td><td class="right">/** The odp_tm_enq() function is used to add packets to a given TM system.</td></tr>
      <tr><td class="left"> * Note that the System Metadata associated with the pkt needed by the TM</td><td> </td><td class="right"> * Note that the System Metadata associated with the pkt needed by the TM</td></tr>
      <tr><td class="left"> * system is (a) a drop_eligible bit, (b) a two bit "pkt_color", (c) a 16-b
it</td><td> </td><td class="right"> * system is (a) a drop_eligible bit, (b) a two bit "pkt_color", (c) a 16-b
it</td></tr>
      <tr><td class="left"> * pkt_len, and MAYBE? (d) a signed 8-bit shaper_len_adjust.</td><td> </td><td class="right"> * pkt_len, and MAYBE? (d) a signed 8-bit shaper_len_adjust.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If there is a non-zero shaper_len_adjust, then it is added to the pkt_le
n</td><td> </td><td class="right"> * If there is a non-zero shaper_len_adjust, then it is added to the pkt_le
n</td></tr>
      <tr><td class="left"> * after any non-zero shaper_len_adjust that is part of the shaper profile.</td><td> </td><td class="right"> * after any non-zero shaper_len_adjust that is part of the shaper profile.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The pkt_color bits are a result of some earlier Metering/Marking/Policin
g</td><td> </td><td class="right"> * The pkt_color bits are a result of some earlier Metering/Marking/Policin
g</td></tr>
      <tr><td class="left"> * processing (typically ingress based), and should not be confused with th
e</td><td> </td><td class="right"> * processing (typically ingress based), and should not be confused with th
e</td></tr>
      <tr><td class="left"> * shaper_color produced from the TM shaper entities within the tm_inputs a
nd</td><td> </td><td class="right"> * shaper_color produced from the TM shaper entities within the tm_inputs a
nd</td></tr>
      <tr><td class="left"> * tm_nodes.</td><td> </td><td class="right"> * tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0059" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue  Specifies the tm_queue (and indirectly the TM <span class="delete">syste</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue  Specifies the tm_queue (and indirectly the TM <span class="insert">system).</span></td></tr>
      <tr><td class="lblock"><span class="delete">m).</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> pkt       Handle to a packet.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> pkt       Handle to a packet.</td><td> </td><td class="rblock"> * @return          Returns 0 upon success, &lt; 0 upon failure. One of <span class="insert">the</span></td></tr>
      <tr><td class="lblock"> * @return              Returns 0 upon success, &lt; 0 upon failure. One of <span class="delete">th</span></td><td> </td><td class="rblock"> *                  more common failure reasons is WRED drop.</td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                      more common failure reasons is WRED drop.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_enq(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td><td> </td><td class="right">int odp_tm_enq(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_enq_with_cnt() function behaves identically to odp_tm_enq(),</td><td> </td><td class="right">/** The odp_tm_enq_with_cnt() function behaves identically to odp_tm_enq(),</td></tr>
      <tr><td class="left"> * except that it also returns (an approximation to?) the current tm_queue</td><td> </td><td class="right"> * except that it also returns (an approximation to?) the current tm_queue</td></tr>
      <tr><td class="left"> * packet queue count.</td><td> </td><td class="right"> * packet queue count.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0060" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> tm_queue  Specifies the tm_queue (and indirectly the TM <span class="delete">syste</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> tm_queue  Specifies the tm_queue (and indirectly the TM <span class="insert">system).</span></td></tr>
      <tr><td class="lblock"><span class="delete">m).</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> pkt       Handle to a packet.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> pkt       Handle to a packet.</td><td> </td><td class="rblock"> * @return          Returns the number of packets previously enqueued <span class="insert">on</span></td></tr>
      <tr><td class="lblock"> * @return              Returns the number of packets previously enqueued <span class="delete">o</span></td><td> </td><td class="rblock"> *                  this tm_queue upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="lblock"><span class="delete">n</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> *                      this tm_queue upon success, &lt; 0 upon failure.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_enq_with_cnt(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td><td> </td><td class="right">int odp_tm_enq_with_cnt(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Dynamic state query functions */</td><td> </td><td class="right">/* Dynamic state query functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_info_t record type  is used to return various bits of</td><td> </td><td class="right">/** The odp_tm_node_info_t record type  is used to return various bits of</td></tr>
      <tr><td class="left"> * information about a given tm_node via the odp_tm_node_info() function.</td><td> </td><td class="right"> * information about a given tm_node via the odp_tm_node_info() function.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td class="left">       /** The shaper profile currently associated with this tm_node.  Can 
be</td><td> </td><td class="right">       /** The shaper profile currently associated with this tm_node.  Can 
be</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l12" /><small>skipping to change at</small><em> line 1659</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 1656</em></th></tr>
      <tr><td class="left">       /** The level of this tm_node.  Note that this value cannot be modif
ied</td><td> </td><td class="right">       /** The level of this tm_node.  Note that this value cannot be modif
ied</td></tr>
      <tr><td class="left">        * after a tm_node has been created, */</td><td> </td><td class="right">        * after a tm_node has been created, */</td></tr>
      <tr><td class="left">       uint8_t level;</td><td> </td><td class="right">       uint8_t level;</td></tr>
      <tr><td class="left">} odp_tm_node_info_t;</td><td> </td><td class="right">} odp_tm_node_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Get tm_node Info</td><td> </td><td class="right">/** Get tm_node Info</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_node_info() function is used to extract various bits of</td><td> </td><td class="right"> * The odp_tm_node_info() function is used to extract various bits of</td></tr>
      <tr><td class="left"> * configuration associated with a given tm_node.</td><td> </td><td class="right"> * configuration associated with a given tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0061" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  tm_node  Specifies the tm_node to be queried.</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  tm_node  Specifies the tm_node to be queried.</td></tr>
      <tr><td class="left"> * @param[out] info     A pointer to an odp_tm_node_info_t record that is t
o</td><td> </td><td class="right"> * @param[out] info     A pointer to an odp_tm_node_info_t record that is t
o</td></tr>
      <tr><td class="left"> *                      be filled in by this call.</td><td> </td><td class="right"> *                      be filled in by this call.</td></tr>
      <tr><td class="left"> * @return              Returns &lt; 0 upon failure, 0 upon success.</td><td> </td><td class="right"> * @return              Returns &lt; 0 upon failure, 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_info(odp_tm_node_t tm_node, odp_tm_node_info_t *info);</td><td> </td><td class="right">int odp_tm_node_info(odp_tm_node_t tm_node, odp_tm_node_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_fanin_info_t record type is used to return various bits
 of</td><td> </td><td class="right">/** The odp_tm_node_fanin_info_t record type is used to return various bits
 of</td></tr>
      <tr><td class="left"> * information about a given "link"/"connection"/"fanin" between a tm_queue</td><td> </td><td class="right"> * information about a given "link"/"connection"/"fanin" between a tm_queue</td></tr>
      <tr><td class="left"> * and a tm_node OR between a tm_node and a tm_node,  It is also used as th
e</td><td> </td><td class="right"> * and a tm_node OR between a tm_node and a tm_node,  It is also used as th
e</td></tr>
      <tr><td class="left"> * state needed to implement an iterator that walks the complete fanin list</td><td> </td><td class="right"> * state needed to implement an iterator that walks the complete fanin list</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l13" /><small>skipping to change at</small><em> line 1719</em></th><th> </th><th><a name="part-r13" /><small>skipping to change at</small><em> line 1716</em></th></tr>
      <tr><td class="left"> * Note that this function will fail (returning &lt; 0 code) if the incoming</td><td> </td><td class="right"> * Note that this function will fail (returning &lt; 0 code) if the incoming</td></tr>
      <tr><td class="left"> * is_last field is set.</td><td> </td><td class="right"> * is_last field is set.</td></tr>
      <tr><td class="left"> * In general walking a fanin list while it is being changed (via _connect(
) or</td><td> </td><td class="right"> * In general walking a fanin list while it is being changed (via _connect(
) or</td></tr>
      <tr><td class="left"> * _disconnect() calls) is problematic - BUT as long as the incoming</td><td> </td><td class="right"> * _disconnect() calls) is problematic - BUT as long as the incoming</td></tr>
      <tr><td class="left"> * tm_queue/tm_node values refer to entities that have not been disconnecte
d</td><td> </td><td class="right"> * tm_queue/tm_node values refer to entities that have not been disconnecte
d</td></tr>
      <tr><td class="left"> * from their fanin list, a reasonable list walk can occur - even while pas
t or</td><td> </td><td class="right"> * from their fanin list, a reasonable list walk can occur - even while pas
t or</td></tr>
      <tr><td class="left"> * future entries are being removed or while future entries are being added
.</td><td> </td><td class="right"> * future entries are being removed or while future entries are being added
.</td></tr>
      <tr><td class="left"> * Note that all new additions to a fanin list always take place at the end
 of</td><td> </td><td class="right"> * Note that all new additions to a fanin list always take place at the end
 of</td></tr>
      <tr><td class="left"> * the list.</td><td> </td><td class="right"> * the list.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0062" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  tm_node    Specifies the tm_node to be queried.</td><td> </td><td class="rblock"> * <span class="insert">@param</span>         tm_node  Specifies the tm_node to be queried.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[inout]</span> info     A pointer to an odp_tm_node_fanin_info_t record <span class="delete">t</span></td><td> </td><td class="rblock"> * <span class="insert">@param[in,out]</span> info     A pointer to an odp_tm_node_fanin_info_t record </td></tr>
      <tr><td class="lblock"><span class="delete">hat</span></td><td> </td><td class="rblock"><span class="insert">that</span></td></tr>
      <tr><td class="lblock"> *                        is used to determine which fanin entry is to be</td><td> </td><td class="rblock"> *                         is used to determine which fanin entry is to be</td></tr>
      <tr><td class="lblock"> *                        next filled in by this call.</td><td> </td><td class="rblock"> *                         next filled in by this call.</td></tr>
      <tr><td class="lblock"> * @return                Returns &lt; 0 upon failure, 0 upon success.</td><td> </td><td class="rblock"> * @return                 Returns &lt; 0 upon failure, 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_fanin_info(odp_tm_node_t             tm_node,</td><td> </td><td class="right">int odp_tm_node_fanin_info(odp_tm_node_t             tm_node,</td></tr>
      <tr><td class="left">                          odp_tm_node_fanin_info_t *info);</td><td> </td><td class="right">                          odp_tm_node_fanin_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_info_t record type  is used to return various bits of</td><td> </td><td class="right">/** The odp_tm_queue_info_t record type  is used to return various bits of</td></tr>
      <tr><td class="left"> * information about a given tm_queue via the odp_tm_queue_info() function.</td><td> </td><td class="right"> * information about a given tm_queue via the odp_tm_queue_info() function.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td class="left">       /** The shaper profile currently associated with this tm_queue.  Can
 be</td><td> </td><td class="right">       /** The shaper profile currently associated with this tm_queue.  Can
 be</td></tr>
      <tr><td class="left">        * ODP_TM_INVALID indicating no shaper profile is currently associat
ed</td><td> </td><td class="right">        * ODP_TM_INVALID indicating no shaper profile is currently associat
ed</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l14" /><small>skipping to change at</small><em> line 1764</em></th><th> </th><th><a name="part-r14" /><small>skipping to change at</small><em> line 1761</em></th></tr>
      <tr><td class="left">       /** The active_pkt is the current packet "at the head of the queue"</td><td> </td><td class="right">       /** The active_pkt is the current packet "at the head of the queue"</td></tr>
      <tr><td class="left">        * that is being processed by this tm_queue. */</td><td> </td><td class="right">        * that is being processed by this tm_queue. */</td></tr>
      <tr><td class="left">       odp_packet_t active_pkt;</td><td> </td><td class="right">       odp_packet_t active_pkt;</td></tr>
      <tr><td class="left">} odp_tm_queue_info_t;</td><td> </td><td class="right">} odp_tm_queue_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Get tm_queue Info</td><td> </td><td class="right">/** Get tm_queue Info</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The odp_tm_queue_info() function is used to extract various bits of</td><td> </td><td class="right"> * The odp_tm_queue_info() function is used to extract various bits of</td></tr>
      <tr><td class="left"> * configuration associated with a given tm_queue.</td><td> </td><td class="right"> * configuration associated with a given tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0063" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  tm_queue  Specifies the tm_queue to be queried.</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  tm_queue  Specifies the tm_queue to be queried.</td></tr>
      <tr><td class="left"> * @param[out] info      A pointer to an odp_tm_queue_info_t record that is
 to</td><td> </td><td class="right"> * @param[out] info      A pointer to an odp_tm_queue_info_t record that is
 to</td></tr>
      <tr><td class="left"> *                       be filled in by this call.</td><td> </td><td class="right"> *                       be filled in by this call.</td></tr>
      <tr><td class="left"> * @return               Returns &lt; 0 upon failure, 0 upon success.</td><td> </td><td class="right"> * @return               Returns &lt; 0 upon failure, 0 upon success.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_info(odp_tm_queue_t tm_queue, odp_tm_queue_info_t *info);</td><td> </td><td class="right">int odp_tm_queue_info(odp_tm_queue_t tm_queue, odp_tm_queue_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The following bit mask constants are used to refine the queue query</td><td> </td><td class="right">/** The following bit mask constants are used to refine the queue query</td></tr>
      <tr><td class="left"> * functions defined below.</td><td> </td><td class="right"> * functions defined below.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_TM_QUERY_PKT_CNT     0x01   /**&lt;  The total_pkt_cnt value */</td><td> </td><td class="right">#define ODP_TM_QUERY_PKT_CNT     0x01   /**&lt;  The total_pkt_cnt value */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l15" /><small>skipping to change at</small><em> line 1848</em></th><th> </th><th><a name="part-r15" /><small>skipping to change at</small><em> line 1845</em></th></tr>
      <tr><td class="left">       odp_bool_t approx_byte_cnt;</td><td> </td><td class="right">       odp_bool_t approx_byte_cnt;</td></tr>
      <tr><td class="left">} odp_tm_query_info_t;</td><td> </td><td class="right">} odp_tm_query_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_query() function can be used to check a single tm_queu
e's</td><td> </td><td class="right">/** The odp_tm_queue_query() function can be used to check a single tm_queu
e's</td></tr>
      <tr><td class="left"> * queue utilization.  The query_flags indicate whether or not packet count
s,</td><td> </td><td class="right"> * queue utilization.  The query_flags indicate whether or not packet count
s,</td></tr>
      <tr><td class="left"> * byte counts or both are being requested.  It is an error to request</td><td> </td><td class="right"> * byte counts or both are being requested.  It is an error to request</td></tr>
      <tr><td class="left"> * neither.  The implementation may still return both sets of counts</td><td> </td><td class="right"> * neither.  The implementation may still return both sets of counts</td></tr>
      <tr><td class="left"> * regardless of query_flags if the cost of returning all the counts is</td><td> </td><td class="right"> * regardless of query_flags if the cost of returning all the counts is</td></tr>
      <tr><td class="left"> * comparable to the cost of checking the query_flags.</td><td> </td><td class="right"> * comparable to the cost of checking the query_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0064" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  tm_queue     Specifies the tm_queue (and indirectly the</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  tm_queue     Specifies the tm_queue (and indirectly the</td></tr>
      <tr><td class="left"> *                          TM system).</td><td> </td><td class="right"> *                          TM system).</td></tr>
      <tr><td class="left"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td><td> </td><td class="right"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td></tr>
      <tr><td class="left"> *                          being requested to be returned in the info reco
rd.</td><td> </td><td class="right"> *                          being requested to be returned in the info reco
rd.</td></tr>
      <tr><td class="left"> * @param[out] info         Pointer to an odp_tm_query_info_t record where 
the</td><td> </td><td class="right"> * @param[out] info         Pointer to an odp_tm_query_info_t record where 
the</td></tr>
      <tr><td class="left"> *                          requested queue info is returned.</td><td> </td><td class="right"> *                          requested queue info is returned.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_query(odp_tm_queue_t       tm_queue,</td><td> </td><td class="right">int odp_tm_queue_query(odp_tm_queue_t       tm_queue,</td></tr>
      <tr><td class="left">                      uint32_t             query_flags,</td><td> </td><td class="right">                      uint32_t             query_flags,</td></tr>
      <tr><td class="left">                      odp_tm_query_info_t *info);</td><td> </td><td class="right">                      odp_tm_query_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_priority_query() function can be used to check the queue</td><td> </td><td class="right">/** The odp_tm_priority_query() function can be used to check the queue</td></tr>
      <tr><td class="left"> * utilization of all tm_queue's with the given priority.  The query_flags</td><td> </td><td class="right"> * utilization of all tm_queue's with the given priority.  The query_flags</td></tr>
      <tr><td class="left"> * indicate whether or not packet counts, byte counts or both are being</td><td> </td><td class="right"> * indicate whether or not packet counts, byte counts or both are being</td></tr>
      <tr><td class="left"> * requested.  It is an error to request neither.  The implementation may</td><td> </td><td class="right"> * requested.  It is an error to request neither.  The implementation may</td></tr>
      <tr><td class="left"> * still return both sets of counts regardless of query_flags if the cost o
f</td><td> </td><td class="right"> * still return both sets of counts regardless of query_flags if the cost o
f</td></tr>
      <tr><td class="left"> * returning all the counts is comparable to the cost of checking the</td><td> </td><td class="right"> * returning all the counts is comparable to the cost of checking the</td></tr>
      <tr><td class="left"> * query_flags.</td><td> </td><td class="right"> * query_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0065" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  odp_tm       Specifies the TM system.</td><td> </td><td class="rblock"> * <span class="insert">@param</span>      odp_tm       Specifies the TM system.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span>  priority     Supplies the strict priority level used to spec</td><td> </td><td class="rblock"> * <span class="insert">@param</span>      priority     Supplies the strict priority level used to spec</td></tr>
      <tr><td class="lblock">ify</td><td> </td><td class="rblock">ify</td></tr>
      <tr><td class="left"> *                          which tm_queues are included in the info values
.</td><td> </td><td class="right"> *                          which tm_queues are included in the info values
.</td></tr>
      <tr><td class="left"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td><td> </td><td class="right"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td></tr>
      <tr><td class="left"> *                          being requested to be returned in the info reco
rd.</td><td> </td><td class="right"> *                          being requested to be returned in the info reco
rd.</td></tr>
      <tr><td class="left"> * @param[out] info         Pointer to an odp_tm_query_info_t record where 
the</td><td> </td><td class="right"> * @param[out] info         Pointer to an odp_tm_query_info_t record where 
the</td></tr>
      <tr><td class="left"> *                          requested queue info is returned.</td><td> </td><td class="right"> *                          requested queue info is returned.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_priority_query(odp_tm_t             odp_tm,</td><td> </td><td class="right">int odp_tm_priority_query(odp_tm_t             odp_tm,</td></tr>
      <tr><td class="left">                         uint8_t              priority,</td><td> </td><td class="right">                         uint8_t              priority,</td></tr>
      <tr><td class="left">                         uint32_t             query_flags,</td><td> </td><td class="right">                         uint32_t             query_flags,</td></tr>
      <tr><td class="left">                         odp_tm_query_info_t *info);</td><td> </td><td class="right">                         odp_tm_query_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_total_query() function can be used to check the queue</td><td> </td><td class="right">/** The odp_tm_total_query() function can be used to check the queue</td></tr>
      <tr><td class="left"> * utilization of all tm_queue's in a single TM system.  The query_flags</td><td> </td><td class="right"> * utilization of all tm_queue's in a single TM system.  The query_flags</td></tr>
      <tr><td class="left"> * indicate whether or not packet counts, byte counts or both are being</td><td> </td><td class="right"> * indicate whether or not packet counts, byte counts or both are being</td></tr>
      <tr><td class="left"> * requested.  It is an error to request neither.  The implementation may</td><td> </td><td class="right"> * requested.  It is an error to request neither.  The implementation may</td></tr>
      <tr><td class="left"> * still return both sets of counts regardless of query_flags if the cost o
f</td><td> </td><td class="right"> * still return both sets of counts regardless of query_flags if the cost o
f</td></tr>
      <tr><td class="left"> * returning all the counts is comparable to the cost of checking the</td><td> </td><td class="right"> * returning all the counts is comparable to the cost of checking the</td></tr>
      <tr><td class="left"> * query_flags.</td><td> </td><td class="right"> * query_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0066" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span>  odp_tm       Specifies the TM system.</td><td> </td><td class="rblock"> * @param<span class="insert">    </span>  odp_tm       Specifies the TM system.</td></tr>
      <tr><td class="left"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td><td> </td><td class="right"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td></tr>
      <tr><td class="left"> *                          being requested to be returned in the info reco
rd.</td><td> </td><td class="right"> *                          being requested to be returned in the info reco
rd.</td></tr>
      <tr><td class="left"> * @param[out] info         Pointer to an odp_tm_query_info_t record where 
the</td><td> </td><td class="right"> * @param[out] info         Pointer to an odp_tm_query_info_t record where 
the</td></tr>
      <tr><td class="left"> *                          requested queue info is returned.</td><td> </td><td class="right"> *                          requested queue info is returned.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_total_query(odp_tm_t             odp_tm,</td><td> </td><td class="right">int odp_tm_total_query(odp_tm_t             odp_tm,</td></tr>
      <tr><td class="left">                      uint32_t             query_flags,</td><td> </td><td class="right">                      uint32_t             query_flags,</td></tr>
      <tr><td class="left">                      odp_tm_query_info_t *info);</td><td> </td><td class="right">                      odp_tm_query_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_priority_threshold_config() function is only used to associa
te</td><td> </td><td class="right">/** The odp_tm_priority_threshold_config() function is only used to associa
te</td></tr>
      <tr><td class="left"> * a maximum packet count and/or a maximum byte count with a strict priorit
y</td><td> </td><td class="right"> * a maximum packet count and/or a maximum byte count with a strict priorit
y</td></tr>
      <tr><td class="left"> * level - for the benefit of the odp_tm_priority_query() function.  It has
 no</td><td> </td><td class="right"> * level - for the benefit of the odp_tm_priority_query() function.  It has
 no</td></tr>
      <tr><td class="left"> * semantic effects other than returning these queue threshold values in th
e</td><td> </td><td class="right"> * semantic effects other than returning these queue threshold values in th
e</td></tr>
      <tr><td class="left"> * odp_tm_query_info_t record.</td><td> </td><td class="right"> * odp_tm_query_info_t record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0067" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm              Specifies the TM system.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm              Specifies the TM system.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> priority            Supplies the strict priority level that</td><td> </td><td class="rblock"> * <span class="insert">@param</span> priority            Supplies the strict priority level that</td></tr>
      <tr><td class="lblock"> *                                the threshold profile params are <span class="delete">associat</span></td><td> </td><td class="rblock"> *                            the threshold profile params are <span class="insert">associated w</span></td></tr>
      <tr><td class="lblock"><span class="delete">ed</span></td><td> </td><td class="rblock"><span class="insert">ith.</span></td></tr>
      <tr><td class="lblock"> *                                <span class="delete">with.</span></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> thresholds_profile  Specifies the queue threshold profile <span class="delete">tha</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> thresholds_profile  Specifies the queue threshold profile <span class="insert">that</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"> *                            should now be associated with the <span class="insert">supplied</span></td></tr>
      <tr><td class="lblock"> *                                should now be associated with the <span class="delete">supplie</span></td><td> </td><td class="rblock"> *                            strict priority level.</td></tr>
      <tr><td class="lblock"><span class="delete">d</span></td><td> </td><td class="rblock"> * @return                    Returns 0 upon success and &lt; 0 upon <span class="insert">failure.</span></td></tr>
      <tr><td class="lblock"> *                                strict priority level.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"> * @return                        Returns 0 upon success and &lt; 0 upon <span class="delete">failu</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">re.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_priority_threshold_config(odp_tm_t           odp_tm,</td><td> </td><td class="right">int odp_tm_priority_threshold_config(odp_tm_t           odp_tm,</td></tr>
      <tr><td class="left">                                    uint8_t            priority,</td><td> </td><td class="right">                                    uint8_t            priority,</td></tr>
      <tr><td class="left">                                    odp_tm_threshold_t thresholds_profile);</td><td> </td><td class="right">                                    odp_tm_threshold_t thresholds_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_total_threshold_config() function is only used to associate 
a</td><td> </td><td class="right">/** The odp_tm_total_threshold_config() function is only used to associate 
a</td></tr>
      <tr><td class="left"> * maximum packet count and/or a maximum byte count with a TM system - for 
the</td><td> </td><td class="right"> * maximum packet count and/or a maximum byte count with a TM system - for 
the</td></tr>
      <tr><td class="left"> * benefit of the odp_tm_total_query() function.  It has no semantic effect
s</td><td> </td><td class="right"> * benefit of the odp_tm_total_query() function.  It has no semantic effect
s</td></tr>
      <tr><td class="left"> * other than returning these queue threshold values in the</td><td> </td><td class="right"> * other than returning these queue threshold values in the</td></tr>
      <tr><td class="left"> * odp_tm_query_info_t record.</td><td> </td><td class="right"> * odp_tm_query_info_t record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0068" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm              Specifies the TM system.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm              Specifies the TM system.</td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> thresholds_profile  Specifies the queue threshold profile <span class="delete">tha</span></td><td> </td><td class="rblock"> * <span class="insert">@param</span> thresholds_profile  Specifies the queue threshold profile <span class="insert">that</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"> *                            should now be used for the entire TM</td></tr>
      <tr><td class="lblock"> *                                should now be used for the entire TM</td><td> </td><td class="rblock"> *                            system.</td></tr>
      <tr><td class="lblock"> *                                system.</td><td> </td><td class="rblock"> * @return                    Returns 0 upon success and &lt; 0 upon <span class="insert">failure.</span></td></tr>
      <tr><td class="lblock"> * @return                        Returns 0 upon success and &lt; 0 upon <span class="delete">failu</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">re.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_total_threshold_config(odp_tm_t odp_tm,</td><td> </td><td class="right">int odp_tm_total_threshold_config(odp_tm_t odp_tm,</td></tr>
      <tr><td class="left">                                 odp_tm_threshold_t thresholds_profile);</td><td> </td><td class="right">                                 odp_tm_threshold_t thresholds_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_is_idle function is used to determine if the specified ODP</td><td> </td><td class="right">/** The odp_tm_is_idle function is used to determine if the specified ODP</td></tr>
      <tr><td class="left"> * traffic management system still has "work" to do (i.e. has at least one</td><td> </td><td class="right"> * traffic management system still has "work" to do (i.e. has at least one</td></tr>
      <tr><td class="left"> * non-empty tm_queue and perhaps some outstanding timers etc).  This funct
ion</td><td> </td><td class="right"> * non-empty tm_queue and perhaps some outstanding timers etc).  This funct
ion</td></tr>
      <tr><td class="left"> * can be used by test programs and ODP applications that wish to know when</td><td> </td><td class="right"> * can be used by test programs and ODP applications that wish to know when</td></tr>
      <tr><td class="left"> * TM system has completed its work - presumably after they have stopped</td><td> </td><td class="right"> * TM system has completed its work - presumably after they have stopped</td></tr>
      <tr><td class="left"> * sending in new pkts.  Note that this function should not be called often</td><td> </td><td class="right"> * sending in new pkts.  Note that this function should not be called often</td></tr>
      <tr><td class="left"> * since for some implementations this call could take a fairly long time</td><td> </td><td class="right"> * since for some implementations this call could take a fairly long time</td></tr>
      <tr><td class="left"> * to execute!</td><td> </td><td class="right"> * to execute!</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0069" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in]</span> odp_tm  Specifies the TM system.</td><td> </td><td class="rblock"> * <span class="insert">@param</span> odp_tm  Specifies the TM system.</td></tr>
      <tr><td class="lblock"> * @return            Returns 1 if the TM system is idle and 0 otherwise.</td><td> </td><td class="rblock"> * @return        Returns 1 if the TM system is idle and 0 otherwise.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_bool_t odp_tm_is_idle(odp_tm_t odp_tm);</td><td> </td><td class="right">odp_bool_t odp_tm_is_idle(odp_tm_t odp_tm);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_stats_print function is used to write implementation-defined</td><td> </td><td class="right">/** The odp_tm_stats_print function is used to write implementation-defined</td></tr>
      <tr><td class="left"> * information about the specified TM system to the ODP log. The intended u
se</td><td> </td><td class="right"> * information about the specified TM system to the ODP log. The intended u
se</td></tr>
      <tr><td class="left"> * is for debugging.</td><td> </td><td class="right"> * is for debugging.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0070" /></td></tr>
      <tr><td class="lblock"> * @param<span class="delete">[in]</span> odp_tm  Specifies the TM system.</td><td> </td><td class="rblock"> * @param odp_tm  Specifies the TM system.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_stats_print(odp_tm_t odp_tm);</td><td> </td><td class="right">void odp_tm_stats_print(odp_tm_t odp_tm);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 70 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>405 lines changed or deleted</i></th><th><i> </i></th><th><i>328 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;version.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;version.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 47</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 47</em></th></tr>
      <tr><td class="left"> * versions are likely not backward compatible.</td><td> </td><td class="right"> * versions are likely not backward compatible.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_VERSION_API_GENERATION 1</td><td> </td><td class="right">#define ODP_VERSION_API_GENERATION 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ODP API major version</td><td> </td><td class="right"> * ODP API major version</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Introduction of major new features or changes. APIs with different major</td><td> </td><td class="right"> * Introduction of major new features or changes. APIs with different major</td></tr>
      <tr><td class="left"> * versions are likely not backward compatible.</td><td> </td><td class="right"> * versions are likely not backward compatible.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">#define  ODP_VERSION_API_MAJOR 1<span class="delete">6</span></td><td> </td><td class="rblock">#define  ODP_VERSION_API_MAJOR 1<span class="insert">7</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ODP API minor version</td><td> </td><td class="right"> * ODP API minor version</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Minor version is incremented when introducing backward compatible change
s</td><td> </td><td class="right"> * Minor version is incremented when introducing backward compatible change
s</td></tr>
      <tr><td class="left"> * to the API. For an API with common generation and major version, but wit
h</td><td> </td><td class="right"> * to the API. For an API with common generation and major version, but wit
h</td></tr>
      <tr><td class="left"> * different minor numbers the two versions are backward compatible.</td><td> </td><td class="right"> * different minor numbers the two versions are backward compatible.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_VERSION_API_MINOR 0</td><td> </td><td class="right">#define ODP_VERSION_API_MINOR 0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;event.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;event.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 32</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 32</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef _odp_abi_event_t *odp_event_t;</td><td> </td><td class="right">typedef _odp_abi_event_t *odp_event_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_EVENT_INVALID  ((odp_event_t)NULL)</td><td> </td><td class="right">#define ODP_EVENT_INVALID  ((odp_event_t)NULL)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef enum odp_event_type_t {</td><td> </td><td class="right">typedef enum odp_event_type_t {</td></tr>
      <tr><td class="left">       ODP_EVENT_BUFFER       = 1,</td><td> </td><td class="right">       ODP_EVENT_BUFFER       = 1,</td></tr>
      <tr><td class="left">       ODP_EVENT_PACKET       = 2,</td><td> </td><td class="right">       ODP_EVENT_PACKET       = 2,</td></tr>
      <tr><td class="left">       ODP_EVENT_TIMEOUT      = 3,</td><td> </td><td class="right">       ODP_EVENT_TIMEOUT      = 3,</td></tr>
      <tr><td class="left">       ODP_EVENT_CRYPTO_COMPL = 4,</td><td> </td><td class="right">       ODP_EVENT_CRYPTO_COMPL = 4,</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">       ODP_EVENT_IPSEC_<span class="delete">RESULT</span> = 5</td><td> </td><td class="rblock">       ODP_EVENT_IPSEC_<span class="insert">STATUS</span> = 5</td></tr>
      <tr><td class="left">} odp_event_type_t;</td><td> </td><td class="right">} odp_event_type_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum odp_event_subtype_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_NO_SUBTYPE   = 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_PACKET_BASIC = 1,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_PACKET_CRYPTO = 2,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODP_EVENT_PACKET_IPSEC = 3</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_event_subtype_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>8 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;chksum.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;chksum.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 38</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 38</em></th></tr>
      <tr><td class="left"> * This enumeration type is used to tell odph_udp_tcp_chksum what to do onc
e</td><td> </td><td class="right"> * This enumeration type is used to tell odph_udp_tcp_chksum what to do onc
e</td></tr>
      <tr><td class="left"> * it has calculated the TCP/UDP check sum.</td><td> </td><td class="right"> * it has calculated the TCP/UDP check sum.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum {</td><td> </td><td class="right">typedef enum {</td></tr>
      <tr><td class="left">       ODPH_CHKSUM_GENERATE, /**&lt; Set TCP/UDP header chksum field */</td><td> </td><td class="right">       ODPH_CHKSUM_GENERATE, /**&lt; Set TCP/UDP header chksum field */</td></tr>
      <tr><td class="left">       ODPH_CHKSUM_VERIFY,   /**&lt; See if TCP/UDP header chksum is correct *
/</td><td> </td><td class="right">       ODPH_CHKSUM_VERIFY,   /**&lt; See if TCP/UDP header chksum is correct *
/</td></tr>
      <tr><td class="left">       ODPH_CHKSUM_RETURN    /**&lt; Don't generate or verify chksum */</td><td> </td><td class="right">       ODPH_CHKSUM_RETURN    /**&lt; Don't generate or verify chksum */</td></tr>
      <tr><td class="left">} odph_chksum_op_t;</td><td> </td><td class="right">} odph_chksum_op_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> <span class="delete">* Checksum</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param buffer calculate chksum for buffer</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param len    buffer length</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return checksum value in network order</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">static inline odp_u16sum_t odph_chksum(void *buffer, int len)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">{</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       uint16_t *buf = (uint16_t *)buffer;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       uint32_t sum = 0;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       uint16_t result;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       for (sum = 0; len &gt; 1; len -= 2)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               sum += *buf++;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       if (len == 1)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               sum += *(unsigned char *)buf;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum = (sum &gt;&gt; 16) + (sum &amp; 0xFFFF);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum += (sum &gt;&gt; 16);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       result = ~sum;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       return  (__odp_force odp_u16sum_t) result;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">}</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * General Purpose TCP/UDP checksum function</td><td> </td><td class="right"> * General Purpose TCP/UDP checksum function</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This function handles all the different checksum operations like</td><td> </td><td class="right"> * This function handles all the different checksum operations like</td></tr>
      <tr><td class="left"> * ODPH_CHKSUM_GENERATE, ODPH_CHKSUM_VERIFY and ODPH_CHKSUM_RETURN for both</td><td> </td><td class="right"> * ODPH_CHKSUM_GENERATE, ODPH_CHKSUM_VERIFY and ODPH_CHKSUM_RETURN for both</td></tr>
      <tr><td class="left"> * TCP and UDP pkts over either IPv4 or IPv6.</td><td> </td><td class="right"> * TCP and UDP pkts over either IPv4 or IPv6.</td></tr>
      <tr><td class="left"> * Note that the packet will be modified only if op==ODPH_CHKSUM_GENERATE.</td><td> </td><td class="right"> * Note that the packet will be modified only if op==ODPH_CHKSUM_GENERATE.</td></tr>
      <tr><td class="left"> * In the case of ODPH_CHKSUM_RETURN, the checksum will be calculated, but</td><td> </td><td class="right"> * In the case of ODPH_CHKSUM_RETURN, the checksum will be calculated, but</td></tr>
      <tr><td class="left"> * will neither be written or compared, but just returned via the chksum_pt
r</td><td> </td><td class="right"> * will neither be written or compared, but just returned via the chksum_pt
r</td></tr>
      <tr><td class="left"> * parameter (assuming that chksum_ptr is non NULL).  Because the code does
n't</td><td> </td><td class="right"> * parameter (assuming that chksum_ptr is non NULL).  Because the code does
n't</td></tr>
      <tr><td class="left"> * know whether a GENERATE or VERIFY is occurring, when using</td><td> </td><td class="right"> * know whether a GENERATE or VERIFY is occurring, when using</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>27 lines changed or deleted</i></th><th><i> </i></th><th><i>0 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;ip.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;ip.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 128</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 128</em></th></tr>
      <tr><td class="left">       if (odp_unlikely(nleft &lt; sizeof(*ip)))</td><td> </td><td class="right">       if (odp_unlikely(nleft &lt; sizeof(*ip)))</td></tr>
      <tr><td class="left">               return -1;</td><td> </td><td class="right">               return -1;</td></tr>
      <tr><td class="left">       ip-&gt;chksum = 0;</td><td> </td><td class="right">       ip-&gt;chksum = 0;</td></tr>
      <tr><td class="left">       memcpy(buf, ip, sizeof(*ip));</td><td> </td><td class="right">       memcpy(buf, ip, sizeof(*ip));</td></tr>
      <tr><td class="left">       res = odp_packet_copy_to_mem(pkt, offset + sizeof(*ip),</td><td> </td><td class="right">       res = odp_packet_copy_to_mem(pkt, offset + sizeof(*ip),</td></tr>
      <tr><td class="left">                                    nleft - sizeof(*ip),</td><td> </td><td class="right">                                    nleft - sizeof(*ip),</td></tr>
      <tr><td class="left">                                    buf + sizeof(*ip) / 2);</td><td> </td><td class="right">                                    buf + sizeof(*ip) / 2);</td></tr>
      <tr><td class="left">       if (odp_unlikely(res &lt; 0))</td><td> </td><td class="right">       if (odp_unlikely(res &lt; 0))</td></tr>
      <tr><td class="left">               return res;</td><td> </td><td class="right">               return res;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">       *chksum = <span class="delete">odph_chksum</span>(buf, nleft);</td><td> </td><td class="rblock">       *chksum = <span class="insert">~odp_chksum_ones_comp16</span>(buf, nleft);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       return 0;</td><td> </td><td class="right">       return 0;</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check if IPv4 checksum is valid</td><td> </td><td class="right"> * Check if IPv4 checksum is valid</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  ODP packet</td><td> </td><td class="right"> * @param pkt  ODP packet</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return 1 if checksum is valid, otherwise 0</td><td> </td><td class="right"> * @return 1 if checksum is valid, otherwise 0</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;odp_api.h (1.16.0.0)&nbsp;</th><th> </th><th>&nbsp;odp_api.h (1.17.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 27</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 27</em></th></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/deprecated.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/deprecated.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/version.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/version.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/std_types.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/std_types.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/compiler.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/compiler.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/align.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/align.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/hash.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/hash.h&gt;</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/chksum.h&gt;</span></td></tr>
      <tr><td class="left">#include &lt;odp/api/hints.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/hints.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/debug.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/debug.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/byteorder.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/byteorder.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/cpu.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/cpu.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/cpumask.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/cpumask.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/barrier.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/barrier.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/spinlock.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/spinlock.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/atomic.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/atomic.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/feature.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/feature.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/init.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/init.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 62</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 63</em></th></tr>
      <tr><td class="left">#include &lt;odp/api/classification.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/classification.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/rwlock.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/rwlock.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/event.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/event.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/random.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/random.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/errno.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/errno.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/thrmask.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/thrmask.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/traffic_mngr.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/traffic_mngr.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/spinlock_recursive.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/spinlock_recursive.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/rwlock_recursive.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/rwlock_recursive.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/std_clib.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/std_clib.h&gt;</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/support.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/ipsec.h&gt;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>3 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
