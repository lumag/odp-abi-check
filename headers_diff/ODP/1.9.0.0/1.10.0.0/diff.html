<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="ODP, header, diff" />
    <meta name="description" content="Diff for header files between 1.9.0.0 and 1.10.0.0 versions of ODP" />
    <link rel="stylesheet" type="text/css" href="../../../../css/common.css" />
    <link rel="stylesheet" type="text/css" href="../../../../css/headers_diff.css" />
    
    
    <title>
        ODP: headers diff between 1.9.0.0 and 1.10.0.0 versions
    </title>
    
    </head>

<body>
<table width='100%' cellpadding='0' cellspacing='0'><tr><td><table cellpadding='0' cellspacing='0'><tr><td align='center'><h1 class='tool'><a title='ABI tracker for ODP' href='../../../../timeline/ODP/index.html' class='tool'>ABI<br/>Tracker</a></h1></td><td width='30px;'></td><td><h1>(ODP)</h1></td></tr></table><hr/>
<br/>
<br/>
<h1>Headers diff: <span class='version'>1.9.0.0</span> vs <span class='version'>1.10.0.0</span></h1><br/><br/> 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;debug.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;debug.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 22</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 22</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_PLAT_DEBUG_H_</td><td> </td><td class="right">#ifndef ODP_PLAT_DEBUG_H_</td></tr>
      <tr><td class="left">#define ODP_PLAT_DEBUG_H_</td><td> </td><td class="right">#define ODP_PLAT_DEBUG_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/spec/debug.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/spec/debug.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if defined(__GNUC__) &amp;&amp; !defined(__clang__)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#if __GNUC__ &lt; 4 || (__GNUC__ == 4 &amp;&amp; (__GNUC_MINOR__ &lt; 6))</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @internal _Static_assert was only added in GCC 4.6. Provide a weak repla</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cement</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * for previous versions.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define _Static_assert(e, s) (extern int (*static_assert_checker(void)) \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       [sizeof(struct { unsigned int error_if_negative:(e) ? 1 : -1; })])</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#endif</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @internal Compile time assertion macro. Fails compilation and outputs 'm</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sg'</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * if condition 'cond' is false. Macro definition is empty when compiler is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> not</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * supported or the compiler does not support static assertion.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_STATIC_ASSERT(cond, msg)  _Static_assert(cond, msg)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>25 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;init_types.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;init_types.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 28</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 28</em></th></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/std_types.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/std_types.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef uint64_t odp_instance_t;</td><td> </td><td class="right">typedef uint64_t odp_instance_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @internal platform specific data</td><td> </td><td class="right"> * @internal platform specific data</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_platform_init_t {</td><td> </td><td class="right">typedef struct odp_platform_init_t {</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       int ipc_ns; /**&lt; Name space for ipc shared objects. */</span></td></tr>
      <tr><td class="left">} odp_platform_init_t;</td><td> </td><td class="right">} odp_platform_init_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_io_types.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_io_types.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 46</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 46</em></th></tr>
      <tr><td class="left">/** @internal */</td><td> </td><td class="right">/** @internal */</td></tr>
      <tr><td class="left">typedef struct odp_pktout_queue_t {</td><td> </td><td class="right">typedef struct odp_pktout_queue_t {</td></tr>
      <tr><td class="left">       odp_pktio_t pktio; /**&lt; @internal pktio handle */</td><td> </td><td class="right">       odp_pktio_t pktio; /**&lt; @internal pktio handle */</td></tr>
      <tr><td class="left">       int index;         /**&lt; @internal pktio queue index */</td><td> </td><td class="right">       int index;         /**&lt; @internal pktio queue index */</td></tr>
      <tr><td class="left">} odp_pktout_queue_t;</td><td> </td><td class="right">} odp_pktout_queue_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_PKTIO_INVALID _odp_cast_scalar(odp_pktio_t, 0)</td><td> </td><td class="right">#define ODP_PKTIO_INVALID _odp_cast_scalar(odp_pktio_t, 0)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_PKTIO_MACADDR_MAXSIZE 16</td><td> </td><td class="right">#define ODP_PKTIO_MACADDR_MAXSIZE 16</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIN_NO_WAIT 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODP_PKTIN_WAIT    UINT64_MAX</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Get printable format of odp_pktio_t */</td><td> </td><td class="right">/** Get printable format of odp_pktio_t */</td></tr>
      <tr><td class="left">static inline uint64_t odp_pktio_to_u64(odp_pktio_t hdl)</td><td> </td><td class="right">static inline uint64_t odp_pktio_to_u64(odp_pktio_t hdl)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return _odp_pri(hdl);</td><td> </td><td class="right">       return _odp_pri(hdl);</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>3 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;schedule_types.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;schedule_types.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 31</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 31</em></th></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_WAIT     UINT64_MAX</td><td> </td><td class="right">#define ODP_SCHED_WAIT     UINT64_MAX</td></tr>
      <tr><td class="left">#define ODP_SCHED_NO_WAIT  0</td><td> </td><td class="right">#define ODP_SCHED_NO_WAIT  0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef int odp_schedule_prio_t;</td><td> </td><td class="right">typedef int odp_schedule_prio_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_PRIO_HIGHEST  0</td><td> </td><td class="right">#define ODP_SCHED_PRIO_HIGHEST  0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">#define ODP_SCHED_PRIO_NORMAL   <span class="delete">(ODP_CONFIG_SCHED_PRIOS / 2)</span></td><td> </td><td class="rblock">#define ODP_SCHED_PRIO_NORMAL   <span class="insert">4</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">#define ODP_SCHED_PRIO_LOWEST   <span class="delete">(ODP_CONFIG_SCHED_PRIOS - 1)</span></td><td> </td><td class="rblock">#define ODP_SCHED_PRIO_LOWEST   <span class="insert">7</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_PRIO_DEFAULT  ODP_SCHED_PRIO_NORMAL</td><td> </td><td class="right">#define ODP_SCHED_PRIO_DEFAULT  ODP_SCHED_PRIO_NORMAL</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef int odp_schedule_sync_t;</td><td> </td><td class="right">typedef int odp_schedule_sync_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODP_SCHED_SYNC_PARALLEL 0</td><td> </td><td class="right">#define ODP_SCHED_SYNC_PARALLEL 0</td></tr>
      <tr><td class="left">#define ODP_SCHED_SYNC_ATOMIC   1</td><td> </td><td class="right">#define ODP_SCHED_SYNC_ATOMIC   1</td></tr>
      <tr><td class="left">#define ODP_SCHED_SYNC_ORDERED  2</td><td> </td><td class="right">#define ODP_SCHED_SYNC_ORDERED  2</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">typedef int odp_schedule_group_t;</td><td> </td><td class="right">typedef int odp_schedule_group_t;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;traffic_mngr_types.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;traffic_mngr_types.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 169</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 169</em></th></tr>
      <tr><td class="left">/** The ODP_TM_INVALID constant can be used with any ODP TM handle type and</td><td> </td><td class="right">/** The ODP_TM_INVALID constant can be used with any ODP TM handle type and</td></tr>
      <tr><td class="left"> * indicates that this value does NOT represent a valid TM object.</td><td> </td><td class="right"> * indicates that this value does NOT represent a valid TM object.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_TM_INVALID  0</td><td> </td><td class="right">#define ODP_TM_INVALID  0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_TM_ROOT</td><td> </td><td class="right"> * @def ODP_TM_ROOT</td></tr>
      <tr><td class="left"> * Constant that is used to refer to the egress/root node of the TM subsyst
em's</td><td> </td><td class="right"> * Constant that is used to refer to the egress/root node of the TM subsyst
em's</td></tr>
      <tr><td class="left"> * tree/hierarchy of nodes.</td><td> </td><td class="right"> * tree/hierarchy of nodes.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">#define ODP_TM_ROOT <span class="delete">0</span></td><td> </td><td class="rblock">#define ODP_TM_ROOT <span class="insert"> ((odp_tm_handle_t)-1)</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Get printable format of odp_queue_t */</td><td> </td><td class="right">/** Get printable format of odp_queue_t */</td></tr>
      <tr><td class="left">static inline uint64_t odp_tm_handle_to_u64(odp_tm_handle_t hdl)</td><td> </td><td class="right">static inline uint64_t odp_tm_handle_to_u64(odp_tm_handle_t hdl)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       return hdl;</td><td> </td><td class="right">       return hdl;</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;atomic.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;atomic.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 118</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 118</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param atom    Pointer to atomic variable</td><td> </td><td class="right"> * @param atom    Pointer to atomic variable</td></tr>
      <tr><td class="left"> * @param val     Value to be added to the variable</td><td> </td><td class="right"> * @param val     Value to be added to the variable</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_atomic_add_u32(odp_atomic_u32_t *atom, uint32_t val);</td><td> </td><td class="right">void odp_atomic_add_u32(odp_atomic_u32_t *atom, uint32_t val);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Fetch and subtract from atomic uint32 variable</td><td> </td><td class="right"> * Fetch and subtract from atomic uint32 variable</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param atom    Pointer to atomic variable</td><td> </td><td class="right"> * @param atom    Pointer to atomic variable</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * @param val     Value to be subracted from the variable</td><td> </td><td class="rblock"> * @param val     Value to be sub<span class="insert">t</span>racted from the variable</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Value of the variable before the subtraction</td><td> </td><td class="right"> * @return Value of the variable before the subtraction</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint32_t odp_atomic_fetch_sub_u32(odp_atomic_u32_t *atom, uint32_t val);</td><td> </td><td class="right">uint32_t odp_atomic_fetch_sub_u32(odp_atomic_u32_t *atom, uint32_t val);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Subtract from atomic uint32 variable</td><td> </td><td class="right"> * Subtract from atomic uint32 variable</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param atom    Pointer to atomic variable</td><td> </td><td class="right"> * @param atom    Pointer to atomic variable</td></tr>
      <tr><td class="left"> * @param val     Value to be subtracted from the variable</td><td> </td><td class="right"> * @param val     Value to be subtracted from the variable</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 611</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 611</em></th></tr>
      <tr><td class="left">} odp_atomic_op_t;</td><td> </td><td class="right">} odp_atomic_op_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Query which atomic uint64 operations are lock-free</td><td> </td><td class="right"> * Query which atomic uint64 operations are lock-free</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Lock-free implementations have higher performance and scale better than</td><td> </td><td class="right"> * Lock-free implementations have higher performance and scale better than</td></tr>
      <tr><td class="left"> * implementations using locks. User can decide to use e.g. uint32 atomic</td><td> </td><td class="right"> * implementations using locks. User can decide to use e.g. uint32 atomic</td></tr>
      <tr><td class="left"> * variables instead of uint64 to optimize performance on platforms that</td><td> </td><td class="right"> * variables instead of uint64 to optimize performance on platforms that</td></tr>
      <tr><td class="left"> * implement a performance critical operation using locks.</td><td> </td><td class="right"> * implement a performance critical operation using locks.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * Init operations (e.g. odp_atomic_init_<span class="delete">64()) are not atomic. This functio
</span>n</td><td> </td><td class="rblock"> * Init operations (e.g. odp_atomic_init_<span class="insert">u64()) are not atomic. This functi
o</span>n</td></tr>
      <tr><td class="left"> * clears the op.init bit but will never set it to one.</td><td> </td><td class="right"> * clears the op.init bit but will never set it to one.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param atomic_op  Pointer to atomic operation structure for storing</td><td> </td><td class="right"> * @param atomic_op  Pointer to atomic operation structure for storing</td></tr>
      <tr><td class="left"> *                   operation flags. All bits are initialized to zero duri
ng</td><td> </td><td class="right"> *                   operation flags. All bits are initialized to zero duri
ng</td></tr>
      <tr><td class="left"> *                   the operation. The parameter is ignored when NULL.</td><td> </td><td class="right"> *                   the operation. The parameter is ignored when NULL.</td></tr>
      <tr><td class="left"> * @retval 0 None of the operations are lock-free</td><td> </td><td class="right"> * @retval 0 None of the operations are lock-free</td></tr>
      <tr><td class="left"> * @retval 1 Some of the operations are lock-free</td><td> </td><td class="right"> * @retval 1 Some of the operations are lock-free</td></tr>
      <tr><td class="left"> * @retval 2 All operations are lock-free</td><td> </td><td class="right"> * @retval 2 All operations are lock-free</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_atomic_lock_free_u64(odp_atomic_op_t *atomic_op);</td><td> </td><td class="right">int odp_atomic_lock_free_u64(odp_atomic_op_t *atomic_op);</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;barrier.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;barrier.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 23</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 23</em></th></tr>
      <tr><td class="left">#ifndef ODP_API_BARRIER_H_</td><td> </td><td class="right">#ifndef ODP_API_BARRIER_H_</td></tr>
      <tr><td class="left">#define ODP_API_BARRIER_H_</td><td> </td><td class="right">#define ODP_API_BARRIER_H_</td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup odp_barrier ODP BARRIER</td><td> </td><td class="right"> * @defgroup odp_barrier ODP BARRIER</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * Thread excution and memory ordering barriers.</td><td> </td><td class="rblock"> * Thread ex<span class="insert">e</span>cution and memory ordering barriers.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @details</td><td> </td><td class="right"> * @details</td></tr>
      <tr><td class="left"> * &lt;b&gt; Thread execution barrier (odp_barrier_t) &lt;/b&gt;</td><td> </td><td class="right"> * &lt;b&gt; Thread execution barrier (odp_barrier_t) &lt;/b&gt;</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Thread execution barrier synchronizes a group of threads to wait on the</td><td> </td><td class="right"> * Thread execution barrier synchronizes a group of threads to wait on the</td></tr>
      <tr><td class="left"> * barrier until the entire group has reached the barrier.</td><td> </td><td class="right"> * barrier until the entire group has reached the barrier.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;buffer.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;buffer.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 98</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 98</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param buf       Buffer handle</td><td> </td><td class="right"> * @param buf       Buffer handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Handle of buffer pool buffer belongs to</td><td> </td><td class="right"> * @return Handle of buffer pool buffer belongs to</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pool_t odp_buffer_pool(odp_buffer_t buf);</td><td> </td><td class="right">odp_pool_t odp_buffer_pool(odp_buffer_t buf);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Buffer alloc</td><td> </td><td class="right"> * Buffer alloc</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * The validity of a buffer can be <span class="delete">cheked</span> at any time with <span class="delete">odp_buffer_is_va</span></td><td> </td><td class="rblock"> * The validity of a buffer can be <span class="insert">checked</span> at any time with</td></tr>
      <tr><td class="lblock"><span class="delete">lid()</span></td><td> </td><td class="rblock"> <span class="insert">* odp_buffer_is_valid().</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * @param pool      Pool handle</td><td> </td><td class="right"> * @param pool      Pool handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Handle of allocated buffer</td><td> </td><td class="right"> * @return Handle of allocated buffer</td></tr>
      <tr><td class="left"> * @retval ODP_BUFFER_INVALID  Buffer could not be allocated</td><td> </td><td class="right"> * @retval ODP_BUFFER_INVALID  Buffer could not be allocated</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_buffer_t odp_buffer_alloc(odp_pool_t pool);</td><td> </td><td class="right">odp_buffer_t odp_buffer_alloc(odp_pool_t pool);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Allocate multiple buffers</td><td> </td><td class="right"> * Allocate multiple buffers</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>3 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;classification.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;classification.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 56</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 56</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_PMR_INVAL</td><td> </td><td class="right"> * @def ODP_PMR_INVAL</td></tr>
      <tr><td class="left"> * Invalid odp_pmr_t value.</td><td> </td><td class="right"> * Invalid odp_pmr_t value.</td></tr>
      <tr><td class="left"> * This value is returned from odp_cls_pmr_create()</td><td> </td><td class="right"> * This value is returned from odp_cls_pmr_create()</td></tr>
      <tr><td class="left"> * function on failure.</td><td> </td><td class="right"> * function on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Supported PMR term values</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Supported Packet Matching Rule term values in a bit field structure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef union odp_cls_pmr_terms_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Packet Matching Rule term fields */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Total length of received packet */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        len:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Initial (outer) Ethertype only */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        ethtype_0:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Ethertype of most inner VLAN tag */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        ethtype_x:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** First VLAN ID (outer) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        vlan_id_0:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Last VLAN ID (inner) */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        vlan_id_x:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** destination MAC address */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        dmac:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** IP Protocol or IPv6 Next Header */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        ip_proto:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Destination UDP port, implies IPPROTO=17 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        udp_dport:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Destination TCP port implies IPPROTO=6 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        tcp_dport:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Source UDP Port */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        udp_sport:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Source TCP port */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        tcp_sport:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Source IP address */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        sip_addr:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Destination IP address */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        dip_addr:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Source IP address */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        sip6_addr:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Destination IP address */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        dip6_addr:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** IPsec session identifier */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        ipsec_spi:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** NVGRE/VXLAN network identifier */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        ld_vni:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Custom match rule, offset from start of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * frame. The match is defined by the offset, the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * expected value, and its size.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t        custom_frame:1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } bit;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All bits of the bit field structure */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint64_t all_bits;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_cls_pmr_terms_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Classification capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This capability structure defines system level classification capability</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_cls_capability_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** PMR terms supported by the classifier</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * A bit mask of one bit for each of odp_pmr_term_t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_cls_pmr_terms_t supported_terms;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of PMR terms */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_pmr_terms;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Number of PMR terms available for use now */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned available_pmr_terms;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of CoS supported */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_cos;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** A Boolean to denote support of PMR range */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t pmr_range_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_cls_capability_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * class of service packet drop policies</td><td> </td><td class="right"> * class of service packet drop policies</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum {</td><td> </td><td class="right">typedef enum {</td></tr>
      <tr><td class="left">       ODP_COS_DROP_POOL,    /**&lt; Follow buffer pool drop policy */</td><td> </td><td class="right">       ODP_COS_DROP_POOL,    /**&lt; Follow buffer pool drop policy */</td></tr>
      <tr><td class="left">       ODP_COS_DROP_NEVER,    /**&lt; Never drop, ignoring buffer pool policy 
*/</td><td> </td><td class="right">       ODP_COS_DROP_NEVER,    /**&lt; Never drop, ignoring buffer pool policy 
*/</td></tr>
      <tr><td class="left">} odp_cls_drop_t;</td><td> </td><td class="right">} odp_cls_drop_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet header field enumeration</td><td> </td><td class="right"> * Packet header field enumeration</td></tr>
      <tr><td class="left"> * for fields that may be used to calculate</td><td> </td><td class="right"> * for fields that may be used to calculate</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 104</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 180</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize class of service parameters</td><td> </td><td class="right"> * Initialize class of service parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Initialize an odp_cls_cos_param_t to its default value for all fields</td><td> </td><td class="right"> * Initialize an odp_cls_cos_param_t to its default value for all fields</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param param   Address of the odp_cls_cos_param_t to be initialized</td><td> </td><td class="right"> * @param param   Address of the odp_cls_cos_param_t to be initialized</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_cls_cos_param_init(odp_cls_cos_param_t *param);</td><td> </td><td class="right">void odp_cls_cos_param_init(odp_cls_cos_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Query classification capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Outputs classification capabilities on success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capability      Pointer to classification capability structu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">re.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval     0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval     &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_cls_capability(odp_cls_capability_t *capability);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Create a class-of-service</td><td> </td><td class="right"> * Create a class-of-service</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      name    String intended for debugging purposes.</td><td> </td><td class="right"> * @param      name    String intended for debugging purposes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      param   class of service parameters</td><td> </td><td class="right"> * @param      param   class of service parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval             class of service handle</td><td> </td><td class="right"> * @retval             class of service handle</td></tr>
      <tr><td class="left"> * @retval             ODP_COS_INVALID on failure.</td><td> </td><td class="right"> * @retval             ODP_COS_INVALID on failure.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note ODP_QUEUE_INVALID and ODP_POOL_INVALID are valid values for queue</td><td> </td><td class="right"> * @note ODP_QUEUE_INVALID and ODP_POOL_INVALID are valid values for queue</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 265</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 353</em></th></tr>
      <tr><td class="left">       ODP_PMR_LD_VNI,         /**&lt; NVGRE/VXLAN network identifier</td><td> </td><td class="right">       ODP_PMR_LD_VNI,         /**&lt; NVGRE/VXLAN network identifier</td></tr>
      <tr><td class="left">                               (*val=uint32_t)*/</td><td> </td><td class="right">                               (*val=uint32_t)*/</td></tr>
      <tr><td class="left">       ODP_PMR_CUSTOM_FRAME,   /**&lt; Custom match rule, offset from start of</td><td> </td><td class="right">       ODP_PMR_CUSTOM_FRAME,   /**&lt; Custom match rule, offset from start of</td></tr>
      <tr><td class="left">                               frame. The match is defined by the offset, t
he</td><td> </td><td class="right">                               frame. The match is defined by the offset, t
he</td></tr>
      <tr><td class="left">                               expected value, and its size. They must be</td><td> </td><td class="right">                               expected value, and its size. They must be</td></tr>
      <tr><td class="left">                               applied before any other PMR.</td><td> </td><td class="right">                               applied before any other PMR.</td></tr>
      <tr><td class="left">                               (*val=uint8_t[val_sz])*/</td><td> </td><td class="right">                               (*val=uint8_t[val_sz])*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Inner header may repeat above values with this offset */</td><td> </td><td class="right">       /** Inner header may repeat above values with this offset */</td></tr>
      <tr><td class="left">       ODP_PMR_INNER_HDR_OFF = 32</td><td> </td><td class="right">       ODP_PMR_INNER_HDR_OFF = 32</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">} odp_pmr_term_t;</td><td> </td><td class="rblock">} odp_<span class="insert">cls_</span>pmr_term_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Following structure is used to define a packet matching rul</span>e</td><td> </td><td class="rblock"> * <span class="insert">Packet Matching Rule parameter structur</span>e</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">typedef struct <span class="delete">odp_pmr_match_t</span> {</td><td> </td><td class="rblock">typedef struct <span class="insert">odp_pmr_param_t</span> {</td></tr>
      <tr><td class="lblock">       <span class="delete">odp_pmr_term_t</span>  term;   /**&lt; <span class="delete">PMR</span> term value <span class="delete">to be matched</span> */</td><td> </td><td class="rblock">       <span class="insert">odp_cls_pmr_term_t</span>  term;       /**&lt; <span class="insert">Packet Matching Rule</span> term <span class="insert">*/</span></td></tr>
      <tr><td class="lblock">       <span class="delete">const void      *val;   /**&lt;</span> Value to be matched */</td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock">       const void      <span class="delete">*mask;  /**&lt;</span> Masked set of bits to be matched */</td><td> </td><td class="rblock"><span class="insert">       /** True if the</span> value <span class="insert">is range and false if match</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">odp_bool_t range_term;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       union {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /**</span> Value to be matched */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                       const void      <span class="insert">*value;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /**</span> Masked set of bits to be matched */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                       <span class="insert">const void      *mask;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               } match;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /** Start and End values are included in the range *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /** start value of range */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const void      *val_start;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       /** End value of range */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       const void      *val_end;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               } range;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       };</span></td></tr>
      <tr><td class="left">       uint32_t        val_sz;  /**&lt; Size of the term value */</td><td> </td><td class="right">       uint32_t        val_sz;  /**&lt; Size of the term value */</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                                           </span></td></tr>
      <tr><td class="left">       uint32_t        offset;  /**&lt; User-defined offset in packet</td><td> </td><td class="right">       uint32_t        offset;  /**&lt; User-defined offset in packet</td></tr>
      <tr><td class="left">                                Used if term == ODP_PMR_CUSTOM_FRAME only,</td><td> </td><td class="right">                                Used if term == ODP_PMR_CUSTOM_FRAME only,</td></tr>
      <tr><td class="left">                                ignored otherwise */</td><td> </td><td class="right">                                ignored otherwise */</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock">} <span class="delete">odp_pmr_match_t;</span></td><td> </td><td class="rblock">} <span class="insert">odp_pmr_param_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Initialize packet matching rule parameters</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Initialize an odp_pmr_param_t to its default values for all fields</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param param Address of the odp_pmr_param_t to be initialized</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_cls_pmr_param_init(odp_pmr_param_t *param);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Create a packet match rule between source and destination class of servi
ce.</td><td> </td><td class="right"> * Create a packet match rule between source and destination class of servi
ce.</td></tr>
      <tr><td class="left"> * This packet matching rule is applied on all packets arriving at the sour
ce</td><td> </td><td class="right"> * This packet matching rule is applied on all packets arriving at the sour
ce</td></tr>
      <tr><td class="left"> * class of service and packets satisfying this PMR are sent to the destina
tion</td><td> </td><td class="right"> * class of service and packets satisfying this PMR are sent to the destina
tion</td></tr>
      <tr><td class="left"> * class of service.</td><td> </td><td class="right"> * class of service.</td></tr>
      <tr><td class="left"> * A composite PMR rule is created when the number of terms in the match ru
le</td><td> </td><td class="right"> * A composite PMR rule is created when the number of terms in the match ru
le</td></tr>
      <tr><td class="left"> * is more than one. The composite rule is considered as matching only if</td><td> </td><td class="right"> * is more than one. The composite rule is considered as matching only if</td></tr>
      <tr><td class="left"> * the packet satisfies all the terms in Packet Match Rule.</td><td> </td><td class="right"> * the packet satisfies all the terms in Packet Match Rule.</td></tr>
      <tr><td class="left"> * The underlying platform may not support all or any specific combination</td><td> </td><td class="right"> * The underlying platform may not support all or any specific combination</td></tr>
      <tr><td class="left"> * of value match rules, and the application should take care</td><td> </td><td class="right"> * of value match rules, and the application should take care</td></tr>
      <tr><td class="left"> * of inspecting the return value when installing such rules, and perform</td><td> </td><td class="right"> * of inspecting the return value when installing such rules, and perform</td></tr>
      <tr><td class="left"> * appropriate fallback action.</td><td> </td><td class="right"> * appropriate fallback action.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * @param[in]  terms           Array of odp_pmr_<span class="delete">match</span>_t entries, one entry 
per</td><td> </td><td class="rblock"> * @param[in]  terms           Array of odp_pmr_<span class="insert">param</span>_t entries, one entry 
per</td></tr>
      <tr><td class="left"> *                             term desired.</td><td> </td><td class="right"> *                             term desired.</td></tr>
      <tr><td class="left"> * @param[in]  num_terms       Number of terms in the match rule.</td><td> </td><td class="right"> * @param[in]  num_terms       Number of terms in the match rule.</td></tr>
      <tr><td class="left"> * @param[in]  src_cos         source CoS handle</td><td> </td><td class="right"> * @param[in]  src_cos         source CoS handle</td></tr>
      <tr><td class="left"> * @param[in]  dst_cos         destination CoS handle</td><td> </td><td class="right"> * @param[in]  dst_cos         destination CoS handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return                     Handle to the Packet Match Rule.</td><td> </td><td class="right"> * @return                     Handle to the Packet Match Rule.</td></tr>
      <tr><td class="left"> * @retval                     ODP_PMR_INVAL on failure</td><td> </td><td class="right"> * @retval                     ODP_PMR_INVAL on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock">odp_pmr_t odp_cls_pmr_create(const odp_pmr_<span class="delete">match</span>_t *terms, int num_terms,</td><td> </td><td class="rblock">odp_pmr_t odp_cls_pmr_create(const odp_pmr_<span class="insert">param</span>_t *terms, int num_terms,</td></tr>
      <tr><td class="left">                            odp_cos_t src_cos, odp_cos_t dst_cos);</td><td> </td><td class="right">                            odp_cos_t src_cos, odp_cos_t dst_cos);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Function to destroy a packet match rule</td><td> </td><td class="right"> * Function to destroy a packet match rule</td></tr>
      <tr><td class="left"> * Destroying a PMR removes the link between the source and destination</td><td> </td><td class="right"> * Destroying a PMR removes the link between the source and destination</td></tr>
      <tr><td class="left"> * class of service and this PMR will no longer be applied for packets arri
ving</td><td> </td><td class="right"> * class of service and this PMR will no longer be applied for packets arri
ving</td></tr>
      <tr><td class="left"> * at the source class of service. All the resource associated with the PMR</td><td> </td><td class="right"> * at the source class of service. All the resource associated with the PMR</td></tr>
      <tr><td class="left"> * be release but the class of service will remain intact.</td><td> </td><td class="right"> * be release but the class of service will remain intact.</td></tr>
      <tr><td class="left"> * Depending on the implementation details, destroying a composite rule</td><td> </td><td class="right"> * Depending on the implementation details, destroying a composite rule</td></tr>
      <tr><td class="left"> * may not guarantee the availability of hardware resources to create the</td><td> </td><td class="right"> * may not guarantee the availability of hardware resources to create the</td></tr>
      <tr><td class="left"> * same or essentially similar rule.</td><td> </td><td class="right"> * same or essentially similar rule.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  pmr_id  Identifier of the PMR to be destroyed</td><td> </td><td class="right"> * @param[in]  pmr_id  Identifier of the PMR to be destroyed</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval             0 on success</td><td> </td><td class="right"> * @retval             0 on success</td></tr>
      <tr><td class="left"> * @retval             &lt;0 on failure</td><td> </td><td class="right"> * @retval             &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_cls_pmr_destroy(odp_pmr_t pmr_id);</td><td> </td><td class="right">int odp_cls_pmr_destroy(odp_pmr_t pmr_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"> <span class="delete">* Inquire about matching terms supported by the classifier</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return A mask one bit per enumerated term, one for each of odp_pmr_term</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">_t</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">unsigned long long odp_pmr_terms_cap(void);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Return the number of packet matching terms available for use</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return A number of packet matcher resources available for use.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">unsigned odp_pmr_terms_avail(void);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">* Assigns a packet pool for a specific class of service.</td><td> </td><td class="right">* Assigns a packet pool for a specific class of service.</td></tr>
      <tr><td class="left">* All the packets belonging to the given class of service will</td><td> </td><td class="right">* All the packets belonging to the given class of service will</td></tr>
      <tr><td class="left">* be allocated from the assigned packet pool.</td><td> </td><td class="right">* be allocated from the assigned packet pool.</td></tr>
      <tr><td class="left">* The packet pool associated with class of service will supersede the</td><td> </td><td class="right">* The packet pool associated with class of service will supersede the</td></tr>
      <tr><td class="left">* packet pool associated with the pktio interface.</td><td> </td><td class="right">* packet pool associated with the pktio interface.</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td class="left">* @param       cos_id  class of service handle</td><td> </td><td class="right">* @param       cos_id  class of service handle</td></tr>
      <tr><td class="left">* @param       pool_id packet pool handle</td><td> </td><td class="right">* @param       pool_id packet pool handle</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td class="left">* @retval      0 on success</td><td> </td><td class="right">* @retval      0 on success</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 358</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 461</em></th></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">int odp_cls_cos_pool_set(odp_cos_t cos_id, odp_pool_t pool_id);</td><td> </td><td class="right">int odp_cls_cos_pool_set(odp_cos_t cos_id, odp_pool_t pool_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left">* Get the pool associated with the given class of service</td><td> </td><td class="right">* Get the pool associated with the given class of service</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td class="left">* @param       cos_id  class of service handle</td><td> </td><td class="right">* @param       cos_id  class of service handle</td></tr>
      <tr><td class="left">*</td><td> </td><td class="right">*</td></tr>
      <tr><td class="left">* @retval      pool handle of the associated pool</td><td> </td><td class="right">* @retval      pool handle of the associated pool</td></tr>
      <tr><td class="left">* @retval      ODP_POOL_INVALID if no associated pool found or</td><td> </td><td class="right">* @retval      ODP_POOL_INVALID if no associated pool found or</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">*              incase of an error</td><td> </td><td class="rblock">*              in<span class="insert"> </span>case of an error</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">odp_pool_t odp_cls_cos_pool(odp_cos_t cos_id);</td><td> </td><td class="right">odp_pool_t odp_cls_cos_pool(odp_cos_t cos_id);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get printable value for an odp_cos_t</td><td> </td><td class="right"> * Get printable value for an odp_cos_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param hdl  odp_cos_t handle to be printed</td><td> </td><td class="right"> * @param hdl  odp_cos_t handle to be printed</td></tr>
      <tr><td class="left"> * @return     uint64_t value that can be used to print/display this</td><td> </td><td class="right"> * @return     uint64_t value that can be used to print/display this</td></tr>
      <tr><td class="left"> *             handle</td><td> </td><td class="right"> *             handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 11 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>25 lines changed or deleted</i></th><th><i> </i></th><th><i>129 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;cpumask.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;cpumask.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_CPUMASK_H_</td><td> </td><td class="right">#ifndef ODP_API_CPUMASK_H_</td></tr>
      <tr><td class="left">#define ODP_API_CPUMASK_H_</td><td> </td><td class="right">#define ODP_API_CPUMASK_H_</td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"><span class="delete">#include &lt;odp/api/config.h&gt;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/** @defgroup odp_cpumask ODP CPUMASK</td><td> </td><td class="right">/** @defgroup odp_cpumask ODP CPUMASK</td></tr>
      <tr><td class="left"> *  CPU mask operations.</td><td> </td><td class="right"> *  CPU mask operations.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_CPUMASK_SIZE</td><td> </td><td class="right"> * @def ODP_CPUMASK_SIZE</td></tr>
      <tr><td class="left"> * Maximum cpumask size, this definition limits the number of individual CP
Us</td><td> </td><td class="right"> * Maximum cpumask size, this definition limits the number of individual CP
Us</td></tr>
      <tr><td class="left"> * that can be accessed in this system.</td><td> </td><td class="right"> * that can be accessed in this system.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>0 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;crypto.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;crypto.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 92</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 92</em></th></tr>
      <tr><td class="left">       ODP_AUTH_ALG_NULL,</td><td> </td><td class="right">       ODP_AUTH_ALG_NULL,</td></tr>
      <tr><td class="left">       /** HMAC-MD5 with 96 bit key */</td><td> </td><td class="right">       /** HMAC-MD5 with 96 bit key */</td></tr>
      <tr><td class="left">       ODP_AUTH_ALG_MD5_96,</td><td> </td><td class="right">       ODP_AUTH_ALG_MD5_96,</td></tr>
      <tr><td class="left">       /** SHA256 with 128 bit key */</td><td> </td><td class="right">       /** SHA256 with 128 bit key */</td></tr>
      <tr><td class="left">       ODP_AUTH_ALG_SHA256_128,</td><td> </td><td class="right">       ODP_AUTH_ALG_SHA256_128,</td></tr>
      <tr><td class="left">       /** AES128 in Galois/Counter Mode */</td><td> </td><td class="right">       /** AES128 in Galois/Counter Mode */</td></tr>
      <tr><td class="left">       ODP_AUTH_ALG_AES128_GCM,</td><td> </td><td class="right">       ODP_AUTH_ALG_AES128_GCM,</td></tr>
      <tr><td class="left">} odp_auth_alg_t;</td><td> </td><td class="right">} odp_auth_alg_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Cipher algorithms in a bit field structure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef union odp_crypto_cipher_algos_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Cipher algorithms */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_CIPHER_ALG_NULL */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t null       : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_CIPHER_ALG_DES */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t des        : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_CIPHER_ALG_3DES_CBC */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t trides_cbc : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_CIPHER_ALG_AES128_CBC */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t aes128_cbc : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_CIPHER_ALG_AES128_GCM */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t aes128_gcm : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } bit;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All bits of the bit field structure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * This field can be used to set/clear all flags, or bitwise</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * operations over the entire structure. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t all_bits;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_crypto_cipher_algos_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Authentication algorithms in a bit field structure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef union odp_crypto_auth_algos_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Authentication algorithms */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_AUTH_ALG_NULL */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t null       : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_AUTH_ALG_MD5_96 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t md5_96     : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_AUTH_ALG_SHA256_128 */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t sha256_128 : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** ODP_AUTH_ALG_AES128_GCM */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t aes128_gcm : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } bit;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All bits of the bit field structure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * This field can be used to set/clear all flags, or bitwise</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * operations over the entire structure. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t all_bits;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_crypto_auth_algos_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Crypto API key structure</td><td> </td><td class="right"> * Crypto API key structure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_crypto_key {</td><td> </td><td class="right">typedef struct odp_crypto_key {</td></tr>
      <tr><td class="left">       uint8_t *data;       /**&lt; Key data */</td><td> </td><td class="right">       uint8_t *data;       /**&lt; Key data */</td></tr>
      <tr><td class="left">       uint32_t length;     /**&lt; Key length in bytes */</td><td> </td><td class="right">       uint32_t length;     /**&lt; Key length in bytes */</td></tr>
      <tr><td class="left">} odp_crypto_key_t;</td><td> </td><td class="right">} odp_crypto_key_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Crypto API IV structure</td><td> </td><td class="right"> * Crypto API IV structure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 257</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 312</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_crypto_op_result {</td><td> </td><td class="right">typedef struct odp_crypto_op_result {</td></tr>
      <tr><td class="left">       odp_bool_t  ok;                  /**&lt; Request completed successfully
 */</td><td> </td><td class="right">       odp_bool_t  ok;                  /**&lt; Request completed successfully
 */</td></tr>
      <tr><td class="left">       void *ctx;                       /**&lt; User context from request */</td><td> </td><td class="right">       void *ctx;                       /**&lt; User context from request */</td></tr>
      <tr><td class="left">       odp_packet_t pkt;                /**&lt; Output packet */</td><td> </td><td class="right">       odp_packet_t pkt;                /**&lt; Output packet */</td></tr>
      <tr><td class="left">       odp_crypto_compl_status_t cipher_status; /**&lt; Cipher status */</td><td> </td><td class="right">       odp_crypto_compl_status_t cipher_status; /**&lt; Cipher status */</td></tr>
      <tr><td class="left">       odp_crypto_compl_status_t auth_status;   /**&lt; Authentication status 
*/</td><td> </td><td class="right">       odp_crypto_compl_status_t auth_status;   /**&lt; Authentication status 
*/</td></tr>
      <tr><td class="left">} odp_crypto_op_result_t;</td><td> </td><td class="right">} odp_crypto_op_result_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Crypto capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_crypto_capability_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of crypto sessions */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t max_sessions;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Supported cipher algorithms */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_cipher_algos_t ciphers;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Cipher algorithms implemented with HW offload */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_cipher_algos_t hw_ciphers;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Supported authentication algorithms */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_auth_algos_t   auths;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Authentication algorithms implemented with HW offload */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_crypto_auth_algos_t   hw_auths;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_crypto_capability_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Query crypto capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Outputs crypto capabilities on success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capa   Pointer to capability structure for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_crypto_capability(odp_crypto_capability_t *capa);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Crypto session creation (synchronous)</td><td> </td><td class="right"> * Crypto session creation (synchronous)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param params            Session parameters</td><td> </td><td class="right"> * @param params            Session parameters</td></tr>
      <tr><td class="left"> * @param session           Created session else ODP_CRYPTO_SESSION_INVALID</td><td> </td><td class="right"> * @param session           Created session else ODP_CRYPTO_SESSION_INVALID</td></tr>
      <tr><td class="left"> * @param status            Failure code if unsuccessful</td><td> </td><td class="right"> * @param status            Failure code if unsuccessful</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_crypto_session_create(odp_crypto_session_params_t *params,</td><td> </td><td class="right">int odp_crypto_session_create(odp_crypto_session_params_t *params,</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>88 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;debug.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;debug.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 20</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 20</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_DEBUG_H_</td><td> </td><td class="right">#ifndef ODP_API_DEBUG_H_</td></tr>
      <tr><td class="left">#define ODP_API_DEBUG_H_</td><td> </td><td class="right">#define ODP_API_DEBUG_H_</td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"><span class="delete">#if defined(__GNUC__) &amp;&amp; !defined(__clang__)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#if __GNUC__ &lt; 4 || (__GNUC__ == 4 &amp;&amp; (__GNUC_MINOR__ &lt; 6))</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @internal _Static_assert was only added in GCC 4.6. Provide a weak repla</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">cement</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * for previous versions.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#define _Static_assert(e, s) (extern int (*static_assert_checker(void)) \</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       [sizeof(struct { unsigned int error_if_negative:(e) ? 1 : -1; })])</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#endif</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@internal</span> Compile time <span class="delete">assertion-macro - fail</span> compilation if <span class="delete">cond</span> is <span class="delete">fal</span></td><td> </td><td class="rblock"> * <span class="insert">@def ODP_STATIC_ASSERT</span></td></tr>
      <tr><td class="lblock"><span class="delete">se.</span></td><td> </td><td class="rblock"><span class="insert"> *</span> Compile time <span class="insert">assertion macro. Fails</span> compilation <span class="insert">and outputs message 'msg</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">This macro has zero runtime overhead</span></td><td> </td><td class="rblock"><span class="insert">'</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> if <span class="insert">condition 'cond' is false. Macro definition</span> is <span class="insert">empty when the compile</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not supported or the compiler does not support static assertion.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param cond Conditional expression to be evaluated at compile time</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* @param msg  Compile time error message to be displayed if cond is false</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"><span class="delete">#define _ODP_STATIC_ASSERT(cond, msg)  _Static_assert(cond, msg)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_end.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 3 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>20 lines changed or deleted</i></th><th><i> </i></th><th><i>10 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;hints.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;hints.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 28</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 28</em></th></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @addtogroup odp_compiler_optim</td><td> </td><td class="right">/** @addtogroup odp_compiler_optim</td></tr>
      <tr><td class="left"> *  Macros that will give hints to the compiler.</td><td> </td><td class="right"> *  Macros that will give hints to the compiler.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __GNUC__</td><td> </td><td class="right">#ifdef __GNUC__</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">/** Define a fn that does not return</td><td> </td><td class="rblock">/** Define a f<span class="insert">unctio</span>n that does not return</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_NORETURN __attribute__((__noreturn__))</td><td> </td><td class="right">#define ODP_NORETURN __attribute__((__noreturn__))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Define a weak symbol</td><td> </td><td class="right">/** Define a weak symbol</td></tr>
      <tr><td class="left"> * This is primarily useful in defining library functions that can be</td><td> </td><td class="right"> * This is primarily useful in defining library functions that can be</td></tr>
      <tr><td class="left"> * overridden in user code.</td><td> </td><td class="right"> * overridden in user code.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_WEAK_SYMBOL __attribute__((__weak__))</td><td> </td><td class="right">#define ODP_WEAK_SYMBOL __attribute__((__weak__))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 59</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 59</em></th></tr>
      <tr><td class="left"> * Printf format attribute</td><td> </td><td class="right"> * Printf format attribute</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_PRINTF_FORMAT(x, y) __attribute__((format(printf, (x), (y))))</td><td> </td><td class="right">#define ODP_PRINTF_FORMAT(x, y) __attribute__((format(printf, (x), (y))))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Indicate deprecated variables, functions or types</td><td> </td><td class="right"> * Indicate deprecated variables, functions or types</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_DEPRECATED __attribute__((__deprecated__))</td><td> </td><td class="right">#define ODP_DEPRECATED __attribute__((__deprecated__))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * Intentionally unused variables o<span class="delete">t</span> functions</td><td> </td><td class="rblock"> * Intentionally unused variables o<span class="insert">f</span> functions</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_UNUSED     __attribute__((__unused__))</td><td> </td><td class="right">#define ODP_UNUSED     __attribute__((__unused__))</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Branch likely taken</td><td> </td><td class="right"> * Branch likely taken</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define odp_likely(x)   __builtin_expect((x), 1)</td><td> </td><td class="right">#define odp_likely(x)   __builtin_expect((x), 1)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Branch unlikely taken</td><td> </td><td class="right"> * Branch unlikely taken</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;packet.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_PACKET_H_</td><td> </td><td class="right">#ifndef ODP_API_PACKET_H_</td></tr>
      <tr><td class="left">#define ODP_API_PACKET_H_</td><td> </td><td class="right">#define ODP_API_PACKET_H_</td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/time.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** @defgroup odp_packet ODP PACKET</td><td> </td><td class="right">/** @defgroup odp_packet ODP PACKET</td></tr>
      <tr><td class="left"> *  Operations on a packet.</td><td> </td><td class="right"> *  Operations on a packet.</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_packet_t</td><td> </td><td class="right"> * @typedef odp_packet_t</td></tr>
      <tr><td class="left"> * ODP packet</td><td> </td><td class="right"> * ODP packet</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 79</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 81</em></th></tr>
      <tr><td class="left">  */</td><td> </td><td class="right">  */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Alloc and free</td><td> </td><td class="right"> * Alloc and free</td></tr>
      <tr><td class="left"> * ********************************************************</td><td> </td><td class="right"> * ********************************************************</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * Allocate a packet from a <span class="delete">buffer</span> pool</td><td> </td><td class="rblock"> * Allocate a packet from a <span class="insert">packet</span> pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"> * Allocates a packet of the requested length from the specified <span class="delete">buffer</span> poo
l.</td><td> </td><td class="rblock"> * Allocates a packet of the requested length from the specified <span class="insert">packet</span> poo
l.</td></tr>
      <tr><td class="left"> * Pool must have been created with ODP_POOL_PACKET type. The</td><td> </td><td class="right"> * Pool must have been created with ODP_POOL_PACKET type. The</td></tr>
      <tr><td class="left"> * packet is initialized with data pointers and lengths set according to th
e</td><td> </td><td class="right"> * packet is initialized with data pointers and lengths set according to th
e</td></tr>
      <tr><td class="left"> * specified len, and the default headroom and tailroom length settings. Al
l</td><td> </td><td class="right"> * specified len, and the default headroom and tailroom length settings. Al
l</td></tr>
      <tr><td class="left"> * other packet metadata are set to their default values.</td><td> </td><td class="right"> * other packet metadata are set to their default values.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pool          Pool handle</td><td> </td><td class="right"> * @param pool          Pool handle</td></tr>
      <tr><td class="left"> * @param len           Packet data length</td><td> </td><td class="right"> * @param len           Packet data length</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Handle of allocated packet</td><td> </td><td class="right"> * @return Handle of allocated packet</td></tr>
      <tr><td class="left"> * @retval ODP_PACKET_INVALID  Packet could not be allocated</td><td> </td><td class="right"> * @retval ODP_PACKET_INVALID  Packet could not be allocated</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * @note The <span class="delete">default</span> headroom and tailroom used for packets is specified by</td><td> </td><td class="rblock"> * @note The <span class="insert">minimum</span> headroom and tailroom used for packets is specified by</td></tr>
      <tr><td class="lblock"> * <span class="delete">the ODP_CONFIG_PACKET_HEADROOM</span> and <span class="delete">ODP_CONFIG_PACKET_TAILROOM defines in</span></td><td> </td><td class="rblock"> * <span class="insert">pool capabilities min_headroom</span> and <span class="insert">min_tailroom.</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * odp_config.h.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_packet_t odp_packet_alloc(odp_pool_t pool, uint32_t len);</td><td> </td><td class="right">odp_packet_t odp_packet_alloc(odp_pool_t pool, uint32_t len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"> * Allocate multiple packets from a <span class="delete">buffer</span> pool</td><td> </td><td class="rblock"> * Allocate multiple packets from a <span class="insert">packet</span> pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Otherwise like odp_packet_alloc(), but allocates multiple</td><td> </td><td class="right"> * Otherwise like odp_packet_alloc(), but allocates multiple</td></tr>
      <tr><td class="left"> * packets from a pool.</td><td> </td><td class="right"> * packets from a pool.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pool          Pool handle</td><td> </td><td class="right"> * @param pool          Pool handle</td></tr>
      <tr><td class="left"> * @param len           Packet data length</td><td> </td><td class="right"> * @param len           Packet data length</td></tr>
      <tr><td class="left"> * @param[out] pkt      Array of packet handles for output</td><td> </td><td class="right"> * @param[out] pkt      Array of packet handles for output</td></tr>
      <tr><td class="left"> * @param num           Maximum number of packets to allocate</td><td> </td><td class="right"> * @param num           Maximum number of packets to allocate</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Number of packets actually allocated (0 ... num)</td><td> </td><td class="right"> * @return Number of packets actually allocated (0 ... num)</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_alloc_multi(odp_pool_t pool, uint32_t len,</td><td> </td><td class="right">int odp_packet_alloc_multi(odp_pool_t pool, uint32_t len,</td></tr>
      <tr><td class="left">                          odp_packet_t pkt[], int num);</td><td> </td><td class="right">                          odp_packet_t pkt[], int num);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Free packet</td><td> </td><td class="right"> * Free packet</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * Frees the packet into the <span class="delete">buffer</span> pool it was allocated from.</td><td> </td><td class="rblock"> * Frees the packet into the <span class="insert">packet</span> pool it was allocated from.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt           Packet handle</td><td> </td><td class="right"> * @param pkt           Packet handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_packet_free(odp_packet_t pkt);</td><td> </td><td class="right">void odp_packet_free(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Free multiple packets</td><td> </td><td class="right"> * Free multiple packets</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Otherwise like odp_packet_free(), but frees multiple packets</td><td> </td><td class="right"> * Otherwise like odp_packet_free(), but frees multiple packets</td></tr>
      <tr><td class="left"> * to their originating pools.</td><td> </td><td class="right"> * to their originating pools.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 294</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 295</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return  Tailroom pointer</td><td> </td><td class="right"> * @return  Tailroom pointer</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_packet_tailroom()</td><td> </td><td class="right"> * @see odp_packet_tailroom()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_packet_tail(odp_packet_t pkt);</td><td> </td><td class="right">void *odp_packet_tail(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Packet offset pointer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns pointer to data in the packet offset. The packet level byte offs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">et is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * calculated from the current odp_packet_data() position. Optionally outpu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle to the segment and number of data bytes in the segment following </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * pointer.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pkt      Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      offset   Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] len      Number of data bytes remaining in the segment (outp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ut).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] seg      Handle to the segment containing the address (outpu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Pointer to the offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval NULL  Requested offset exceeds packet length</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void *odp_packet_offset(odp_packet_t pkt, uint32_t offset, uint32_t *len,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       odp_packet_seg_t *seg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet data prefetch</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Prefetch 'len' bytes of packet data starting from 'offset' into various</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * caches close to the calling thread.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pkt      Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      offset   Byte offset into packet data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      len      Number of bytes to prefetch starting from 'offset'</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_prefetch(odp_packet_t pkt, uint32_t offset, uint32_t len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Push out packet head</td><td> </td><td class="right"> * Push out packet head</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Increase packet data length by moving packet head into packet headroom.</td><td> </td><td class="right"> * Increase packet data length by moving packet head into packet headroom.</td></tr>
      <tr><td class="left"> * Packet headroom is decreased with the same amount. The packet head may b
e</td><td> </td><td class="right"> * Packet headroom is decreased with the same amount. The packet head may b
e</td></tr>
      <tr><td class="left"> * pushed out up to 'headroom' bytes. Packet is not modified if there's not</td><td> </td><td class="right"> * pushed out up to 'headroom' bytes. Packet is not modified if there's not</td></tr>
      <tr><td class="left"> * enough headroom space.</td><td> </td><td class="right"> * enough headroom space.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * odp_packet_xxx:</td><td> </td><td class="right"> * odp_packet_xxx:</td></tr>
      <tr><td class="left"> * seg_len  += len</td><td> </td><td class="right"> * seg_len  += len</td></tr>
      <tr><td class="left"> * len      += len</td><td> </td><td class="right"> * len      += len</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 407</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 441</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> * @param len  Number of bytes to pull the tail (0 ... last_seg:data_len - 
1)</td><td> </td><td class="right"> * @param len  Number of bytes to pull the tail (0 ... last_seg:data_len - 
1)</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return The new tail pointer</td><td> </td><td class="right"> * @return The new tail pointer</td></tr>
      <tr><td class="left"> * @retval NULL  The specified offset exceeds allowable data length</td><td> </td><td class="right"> * @retval NULL  The specified offset exceeds allowable data length</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_packet_pull_tail(odp_packet_t pkt, uint32_t len);</td><td> </td><td class="right">void *odp_packet_pull_tail(odp_packet_t pkt, uint32_t len);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Packet offset pointer</span></td><td> </td><td class="rblock"> * <span class="insert">Extend packet head</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Returns pointer to data in the</span> packet <span class="delete">offset. The</span> packet <span class="delete">level byte offs</span></td><td> </td><td class="rblock"> * <span class="insert">Increase</span> packet <span class="insert">data length at</span> packet <span class="insert">head. Functionality</span> is <span class="insert">analogous t</span></td></tr>
      <tr><td class="lblock"><span class="delete">et</span> is</td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">calculated from the current odp_packet_data() position. Optionally outpu</span></td><td> </td><td class="rblock"> * <span class="insert">odp_packet_push_head() when data length is extended up</span> to <span class="insert">headroom size.</span></td></tr>
      <tr><td class="lblock"><span class="delete">ts</span></td><td> </td><td class="rblock"><span class="insert"> * When</span> data <span class="insert">length is increased more than that, new segments are added int</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * handle</span> to <span class="delete">the segment and number of</span> data <span class="delete">bytes in</span> the segment <span class="delete">following </span></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"><span class="delete">the</span></td><td> </td><td class="rblock"><span class="insert"> *</span> the <span class="insert">packet head and old</span> segment <span class="insert">handles become invalid.</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * pointer.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param      pkt      Packet</span> handle</td><td> </td><td class="rblock"> * <span class="insert">A successful operation overwrites the packet</span> handle <span class="insert">with a new handle, w</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param      offset   Byte offset into</span> the packet</td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[out]</span> len      Number of <span class="delete">data</span> bytes <span class="delete">remaining in</span> the <span class="delete">segment (outp</span></td><td> </td><td class="rblock"> * <span class="insert">application must use as the reference to</span> the packet <span class="insert">instead of the old</span></td></tr>
      <tr><td class="lblock"><span class="delete">ut).</span></td><td> </td><td class="rblock"> * <span class="insert">handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * User is responsible to update packet metadata offsets when needed. Packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param</span> len           Number of bytes <span class="insert">to extend</span> the <span class="insert">head</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] data_ptr Pointer to output the new data pointer.</span></td></tr>
      <tr><td class="left"> *                      Ignored when NULL.</td><td> </td><td class="right"> *                      Ignored when NULL.</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock"> * @param[out] seg<span class="delete">      Handle to the segment containing the address (outpu
t)</span>.</td><td> </td><td class="rblock"> * @param[out] seg<span class="insert">_len  Pointer to output segment length at 'data_ptr' abov
e</span>.</td></tr>
      <tr><td class="left"> *                      Ignored when NULL.</td><td> </td><td class="right"> *                      Ignored when NULL.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@return Pointer</span> to <span class="delete">the offset</span></td><td> </td><td class="rblock"> * <span class="insert">@retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"> * @retval <span class="delete">NULL  Requested offset exceeds packet length</span></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need</span> to <span class="insert">be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @retval <span class="insert">&lt;0  Operation failed (e.g. due to an allocation failure)</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock">void <span class="delete">*odp_packet_offset(odp_packet_t pkt,</span> uint32_t offset, uint32_t <span class="delete">*len,</span></td><td> </td><td class="rblock"><span class="insert">int odp_packet_extend_head(odp_packet_t *pkt, uint32_t len,</span> void <span class="insert">**data_ptr</span></td></tr>
      <tr><td class="lblock">                       odp_packet_seg_t <span class="delete">*seg);</span></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          uint32_t *seg_len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Truncate packet head</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Decrease packet data length at packet head. Functionality is analogous t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_packet_pull_head() when data length is truncated less than the first</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * segment data length. When data length is decreased more than that, some </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">head</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * segments are removed from the packet and old segment handles become inva</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites the packet handle with a new handle, w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * application must use as the reference to the packet instead of the old</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * User is responsible to update packet metadata offsets when needed. Packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len           Number of bytes to truncate the head (0 ... packet_</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] data_ptr Pointer to output the new data pointer.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] seg_len  Pointer to output segment length at 'data_ptr' abov</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_trunc_head(odp_packet_t *pkt, uint32_t len, void **data_ptr,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         uint32_t *seg_len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Extend packet tail</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Increase packet data length at packet tail. Functionality is analogous t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_packet_push_tail() when data length is extended up to tailroom size.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When data length is increased more than that, new segments are added int</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the packet tail and old segment handles become invalid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites the packet handle with a new handle, w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * application must use as the reference to the packet instead of the old</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * User is responsible to update packet metadata offsets when needed. Packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len           Number of bytes to extend the tail</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] data_ptr Pointer to output pointer to the last 'len' bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      of the resulting packet (the previous tail).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] seg_len  Pointer to output segment length at 'data_ptr' abov</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed (e.g. due to an allocation failure)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_extend_tail(odp_packet_t *pkt, uint32_t len, void **data_ptr</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          uint32_t *seg_len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Truncate packet tail</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Decrease packet data length at packet tail. Functionality is analogous t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_packet_pull_tail() when data length is truncated less the last segme</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data length. When data length is decreased more than that, some tail seg</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * are removed from the packet and old segment handles become invalid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites the packet handle with a new handle, w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * application must use as the reference to the packet instead of the old</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * User is responsible to update packet metadata offsets when needed. Packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len           Number of bytes to truncate the tail (0 ... packet_</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">len)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] tail_ptr Pointer to output the new tail pointer.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Ignored when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] tailroom Pointer to output the new tailroom. Ignored when NU</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">LL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_trunc_tail(odp_packet_t *pkt, uint32_t len, void **tail_ptr,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         uint32_t *tailroom);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Add data into an offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Increase packet data length by adding new data area into the specified</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * offset. The operation may modify packet segmentation and move data.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites the packet handle with a new handle, w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * application must use as the reference to the packet instead of the old</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * User is responsible to update packet metadata offsets when needed. Packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset        Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len           Number of bytes to add into the offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_add_data(odp_packet_t *pkt, uint32_t offset, uint32_t len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Remove data from an offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Decrease packet data length by removing data area from the specified</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * offset. The operation may modify packet segmentation and move data.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites the packet handle with a new handle, w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * application must use as the reference to the packet instead of the old</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * User is responsible to update packet metadata offsets when needed. Packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset        Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len           Number of bytes to remove from the offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_rem_data(odp_packet_t *pkt, uint32_t offset, uint32_t len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Align packet data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Modify packet data alignment so that 'len' bytes between 'offset' and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * 'offset' plus 'len' are contiguous in memory and have a minimum alignmen</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * of 'align' bytes.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites the packet handle with a new handle, w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the application must use as the reference to the packet instead of the o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ld</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle. Depending on the implementation, the old and new handles may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data outside of the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * requested area or metadata (e.g. user_area) were moved in memory during</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the operation. If some other memory areas were moved, application must u</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">se</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * new packet/segment handles to update data pointers. Otherwise, old</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet is not modified if operation fails.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt  Pointer to packet handle. A successful operation ou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tputs</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset        Byte offset of the contiguous area</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len           Byte length of the contiguous area (0 ... packet_le</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param align         Minimum byte alignment of the contiguous area.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      Valid values are powers of 2. Use 0 to indicate no</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      special alignment requirement. All implementations</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      support alignments of up to at least 32 bytes. Requ</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">est</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      will fail if requested alignment exceeds implementa</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">tion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      limits.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_align(odp_packet_t *pkt,</span> uint32_t offset, uint32_t <span class="insert">len,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                    uint32_t align);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Segmentation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ********************************************************</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Tests if packet is segmented</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt  Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 Packet is not segmented</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 1 Packet is segmented</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_is_segmented(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Number of segments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns number of segments in the packet. A packet has always at least o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ne</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * segment.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt  Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of segments (&gt;0)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_num_segs(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * First segment in packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A packet has always the first segment (has at least one segment).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt  Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Handle to the first segment</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_seg_t odp_packet_first_seg(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Last segment in packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A packet has always the last segment (has at least one segment).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt  Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Handle to the last segment</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_seg_t odp_packet_last_seg(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Next segment in packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns handle to the next segment after the current segment, or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_PACKET_SEG_INVALID if there are no more segments. Use</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_packet_first_seg() to get handle to the first segment.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt   Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param seg   Current segment handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Handle to the next segment</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval ODP_PACKET_SEG_INVALID if there are no more segments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_seg_t odp_packet_next_seg(odp_packet_t pkt, odp_packet_seg_t seg</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Segment data pointer</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns pointer to the first byte of data in the segment.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt  Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param seg  Segment handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return  Pointer to the segment data</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval NULL on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see odp_packet_seg_data_len()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void *odp_packet_seg_data(odp_packet_t pkt, odp_packet_seg_t seg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Segment data length</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns segment data length in bytes.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt  Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param seg  Segment handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return  Segment data length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see odp_packet_seg_data()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint32_t odp_packet_seg_data_len(odp_packet_t pkt,</span> odp_packet_seg_t <span class="insert">seg);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Concatenate two packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Concatenate all packet data from 'src' packet into tail of 'dst' packet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Operation preserves 'dst' packet metadata in the resulting packet,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * while 'src' packet handle, metadata and old segment handles for both pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">kets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * become invalid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * A successful operation overwrites 'dst' packet handle with a new handle,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * which application must use as the reference to the resulting packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * instead of the old handle. Depending on the implementation, the old and </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">new</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handles may be equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The resulting packet is always allocated from the same pool as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the destination packet. The source packet may have been allocate from</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * any pool.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * On failure, both handles remain valid and packets are not modified.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] dst   Pointer to destination packet handle. A successful</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                       operation outputs the new packet handle.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param src            Source packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_concat(odp_packet_t *dst, odp_packet_t src);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Split packet into two packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Split the packet after 'len' bytes. The first 'len' bytes of data and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * metadata remain in the head packet. A successful operation outputs a han</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">dle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * for the tail packet and overwrites 'pkt' packet handle with a new</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle, which application must use as the reference to the resulting hea</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet. Depending on the implementation, the old and new 'pkt' handles</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * may be equal.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The operation return value indicates if any packet data or metadata (e.g</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * user_area) were moved in memory during the operation. If some memory are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * were moved, application must use new packet/segment handles to update</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * data pointers. Otherwise, all old pointers remain valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The tail packet holds the rest of the data (odp_packet_len() - 'len' byt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">es).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The packet is allocated from the same pool as the original packet and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * metadata is initialized with default values.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * For performance reasons (zero copy), the head packet may have zero tailr</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">oom</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and the tail packet may have zero headroom length after the operation.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Both packets may be extended normally.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The original packet is not modified on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in, out] pkt   Pointer to packet handle. A successful operation</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                       outputs a new packet handle for the head packet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len            Data length remaining in the head packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param tail           Pointer to output the tail packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0   Operation successful, old pointers remain valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &gt;0  Operation successful, old pointers need to be updated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Operation failed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_split(odp_packet_t *pkt, uint32_t len, odp_packet_t *tail);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ********************************************************</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Full copy of a packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Create a new copy of the packet. The new packet is exact copy of the sou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rce</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packet (incl. data and metadata). The pool must have been created with</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_POOL_PACKET type.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt   Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pool  Packet pool for allocation of the new packet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Handle to the copy of the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval ODP_PACKET_INVALID on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_t odp_packet_copy(odp_packet_t pkt, odp_pool_t pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Partial copy of a packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy 'len' bytes of data starting from 'offset' into a new packet.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Metadata in the new packet is initialized with default values. Maximum n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">umber</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * of bytes to copy is packet data length minus the offset. The pool must b</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * a packet pool.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt    Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len    Number of bytes to copy</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pool   Packet pool for allocation of the new packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Handle for the new packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval ODP_PACKET_INVALID on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_packet_t odp_packet_copy_part(odp_packet_t pkt, uint32_t offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                 uint32_t len, odp_pool_t pool);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy data from packet to memory</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy 'len' bytes of data starting from 'offset' to the destination</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * address. Maximum number of bytes to copy is packet data length minus the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * offset.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt    Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len    Number of bytes to copy</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param dst    Destination address</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_copy_to_mem(odp_packet_t pkt, uint32_t offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          uint32_t len, void *dst);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy data from memory to packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy 'len' bytes of data from the source address into the packet level</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * offset. Maximum number of bytes to copy is packet data length minus the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * offset. Packet is not modified on an error.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt    Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param offset Byte offset into the packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len    Number of bytes to copy</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param src    Source address</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_copy_from_mem(odp_packet_t pkt, uint32_t offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                            uint32_t len, const void *src);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy data from another packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy 'len' bytes of data from 'src' packet to 'dst' packet. Copy starts </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">from</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the specified source and destination packet offsets. Copied areas</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (offset ... offset + len) must not exceed their packet data lengths.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet is not modified on an error.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param dst        Destination packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param dst_offset Byte offset into destination packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param src        Source packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param src_offset Byte offset into source packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len        Number of bytes to copy</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_copy_from_pkt(odp_packet_t dst, uint32_t dst_offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                            odp_packet_t src, uint32_t src_offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                            uint32_t len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy data within packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy 'len' bytes of data from 'src_offset' to 'dst_offset'. Copied areas</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (offset ... offset + len) must not overlap or exceed packet data length.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet is not modified on an error.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt        Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param dst_offset Destination byte offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param src_offset Source byte offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len        Number of bytes to copy</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_copy_data(odp_packet_t pkt, uint32_t dst_offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                        uint32_t src_offset, uint32_t len);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Move data within packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Copy 'len' bytes of data from 'src_offset' to 'dst_offset'. Copied areas</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (offset ... offset + len) may overlap by any number of bytes, but must n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ot</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * exceed packet data length. When areas overlap, copying takes place as if</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * source bytes are first copied into a temporary buffer, and then from the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">re</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to the destination. Packet is not modified on an error.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt        Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param dst_offset Destination byte offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param src_offset Source byte offset</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len        Number of bytes to move</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_move_data(odp_packet_t pkt, uint32_t dst_offset,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                        uint32_t src_offset, uint32_t len);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Meta-data</td><td> </td><td class="right"> * Meta-data</td></tr>
      <tr><td class="left"> * ********************************************************</td><td> </td><td class="right"> * ********************************************************</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet pool</td><td> </td><td class="right"> * Packet pool</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock"> * Returns handle to the <span class="delete">buffer</span> pool where the packet was allocated from.</td><td> </td><td class="rblock"> * Returns handle to the <span class="insert">packet</span> pool where the packet was allocated from.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt   Packet handle</td><td> </td><td class="right"> * @param pkt   Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"> * @return <span class="delete">Buffer</span> pool handle</td><td> </td><td class="rblock"> * @return <span class="insert">Packet</span> pool handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pool_t odp_packet_pool(odp_packet_t pkt);</td><td> </td><td class="right">odp_pool_t odp_packet_pool(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet input interface</td><td> </td><td class="right"> * Packet input interface</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Returns handle to the packet IO interface which received the packet or</td><td> </td><td class="right"> * Returns handle to the packet IO interface which received the packet or</td></tr>
      <tr><td class="left"> * ODP_PKTIO_INVALID when the packet was allocated/reset by the application
.</td><td> </td><td class="right"> * ODP_PKTIO_INVALID when the packet was allocated/reset by the application
.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt   Packet handle</td><td> </td><td class="right"> * @param pkt   Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Packet interface handle</td><td> </td><td class="right"> * @return Packet interface handle</td></tr>
      <tr><td class="left"> * @retval ODP_PKTIO_INVALID  Packet was not received on any interface</td><td> </td><td class="right"> * @retval ODP_PKTIO_INVALID  Packet was not received on any interface</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pktio_t odp_packet_input(odp_packet_t pkt);</td><td> </td><td class="right">odp_pktio_t odp_packet_input(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Packet input interface index</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Returns the index of the packet I/O interface that received the packet, </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * &lt;0 when the packet was allocated/reset by the application.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt   Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Packet interface index (0..odp_pktio_max_index())</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0  Packet was not received on any interface</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_input_index(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * User context pointer</td><td> </td><td class="right"> * User context pointer</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Return previously stored user context pointer.</td><td> </td><td class="right"> * Return previously stored user context pointer.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return User context pointer</td><td> </td><td class="right"> * @return User context pointer</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_packet_user_ptr(odp_packet_t pkt);</td><td> </td><td class="right">void *odp_packet_user_ptr(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 694</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 1262</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note If the platform needs to keep the original hash value, it has to</td><td> </td><td class="right"> * @note If the platform needs to keep the original hash value, it has to</td></tr>
      <tr><td class="left"> * maintain it internally. Overwriting the platform provided value doesn't</td><td> </td><td class="right"> * maintain it internally. Overwriting the platform provided value doesn't</td></tr>
      <tr><td class="left"> * change how the platform handles this packet after it.</td><td> </td><td class="right"> * change how the platform handles this packet after it.</td></tr>
      <tr><td class="left"> * @note The application is not required to keep this hash valid for new or</td><td> </td><td class="right"> * @note The application is not required to keep this hash valid for new or</td></tr>
      <tr><td class="left"> * modified packets.</td><td> </td><td class="right"> * modified packets.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_packet_flow_hash_set(odp_packet_t pkt, uint32_t flow_hash);</td><td> </td><td class="right">void odp_packet_flow_hash_set(odp_packet_t pkt, uint32_t flow_hash);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Tests if packet is segmented</span></td><td> </td><td class="rblock"> * Packet <span class="insert">timestamp</span></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt</span>  Packet <span class="delete">handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval 0 Packet is not segmented</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval 1 Packet is segmented</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">int odp_packet_is_segmented(odp_packet_t pkt);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Number of segments</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Returns number of segments in the packet. A packet has always at least o</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">ne</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * segment.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt  Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return Number of segments (&gt;0)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">int odp_packet_num_segs(odp_packet_t pkt);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * First segment in packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">A</span> packet has <span class="delete">always the first segment (has at least one segment).</span></td><td> </td><td class="rblock"> * <span class="insert">Returns packet timestamp value as odp_time_t type. Use time API for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * additional operations on packet timestamp values or conversion into</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * nanoseconds. Use odp_packet_has_ts() to check if</span> packet has <span class="insert">a valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * timestamp. Packet input interface timestamp resolution can be checked wi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_pktin_ts_res().</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  Packet handle</td><td> </td><td class="right"> * @param pkt  Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"> * @return <span class="delete">Handle to the first segment</span></td><td> </td><td class="rblock"> * @return <span class="insert">Timestamp value</span></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">odp_packet_seg_t odp_packet_first_seg(odp_packet_t pkt);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Last segment in packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * A packet has always the last segment (has at least one segment).</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt  Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * @<span class="delete">return Handle to the last segment</span></td><td> </td><td class="rblock"> * @<span class="insert">see odp_pktin_ts_res(), odp_packet_has_ts(), odp_time_to_ns()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock">odp_<span class="delete">packet_seg_t odp_packet_last_seg</span>(odp_packet_t pkt);</td><td> </td><td class="rblock">odp_<span class="insert">time_t odp_packet_ts</span>(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Next segment in packet</span></td><td> </td><td class="rblock"> * <span class="insert">Set packet timestamp</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">Returns handle to</span> the <span class="delete">next segment after the current segment, or</span></td><td> </td><td class="rblock"> * <span class="insert">Stores timestamp value and sets timestamp flag for</span> the <span class="insert">packet.</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * ODP_PACKET_SEG_INVALID if there are no more segments. Use</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * odp_packet_first_seg() to get handle to the first segment.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"> * @param pkt   Packet handle</td><td> </td><td class="rblock"> * @param pkt        Packet handle</td></tr>
      <tr><td class="lblock"> * @param <span class="delete">seg   Current segment handle</span></td><td> </td><td class="rblock"> * @param <span class="insert">timestamp  Timestamp value</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@return Handle to the next segment</span></td><td> </td><td class="rblock"> * <span class="insert">@see odp_packet_ts(), odp_packet_has_ts(),</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">@retval ODP_PACKET_SEG_INVALID if there are no more segments</span></td><td> </td><td class="rblock"> * <span class="insert">odp_pktin_ts_from_ns()</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock"><span class="delete">odp_packet_seg_t odp_packet_next_seg(odp_packet_t pkt, odp_packet_seg_t seg
</span>);</td><td> </td><td class="rblock"><span class="insert">void odp_packet_ts_set(odp_packet_t pkt, odp_time_t timestamp</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get packet color</td><td> </td><td class="right"> * Get packet color</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt Packet handle</td><td> </td><td class="right"> * @param pkt Packet handle</td></tr>
      <tr><td class="left"> * @return packet color</td><td> </td><td class="right"> * @return packet color</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_packet_color_t odp_packet_color(odp_packet_t pkt);</td><td> </td><td class="right">odp_packet_color_t odp_packet_color(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l6" /><small>skipping to change at</small><em> line 804</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 1343</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set shaper length adjustment</td><td> </td><td class="right"> * Set shaper length adjustment</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt Packet handle</td><td> </td><td class="right"> * @param pkt Packet handle</td></tr>
      <tr><td class="left"> * @param adj Signed adjustment value</td><td> </td><td class="right"> * @param adj Signed adjustment value</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_packet_shaper_len_adjust_set(odp_packet_t pkt, int8_t adj);</td><td> </td><td class="right">void odp_packet_shaper_len_adjust_set(odp_packet_t pkt, int8_t adj);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/*</td><td> </td><td class="right">/*</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock"> <span class="delete">* Segment level</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * ********************************************************</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Segment buffer address</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Returns start address of the segment.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt  Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param seg  Segment handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return  Start address of the segment</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval NULL on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @see odp_packet_seg_buf_len()</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">void *odp_packet_seg_buf_addr(odp_packet_t pkt, odp_packet_seg_t seg);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Segment buffer length</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Returns segment buffer length in bytes.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt  Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param seg  Segment handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return  Segment buffer length in bytes</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @see odp_packet_seg_buf_addr()</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">uint32_t odp_packet_seg_buf_len(odp_packet_t pkt, odp_packet_seg_t seg);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Segment data pointer</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Returns pointer to the first byte of data in the segment.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt  Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param seg  Segment handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return  Pointer to the segment data</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval NULL on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @see odp_packet_seg_data_len()</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">void *odp_packet_seg_data(odp_packet_t pkt, odp_packet_seg_t seg);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Segment data length</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Returns segment data length in bytes.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt  Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param seg  Segment handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return  Segment data length in bytes</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @see odp_packet_seg_data()</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">uint32_t odp_packet_seg_data_len(odp_packet_t pkt, odp_packet_seg_t seg);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/*</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Manipulation</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * ********************************************************</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Add data into an offset</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Increases packet data length by adding new data area into the specified</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * offset. The operation returns a new packet handle on success. It may mod</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">ify</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * packet segmentation and move data. Handles and pointers must be updated</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * after the operation. User is responsible to update packet metadata offse</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">ts</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * when needed. The packet is not modified on an error.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt     Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param offset  Byte offset into the packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param len     Number of bytes to add into the offset</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return New packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval ODP_PACKET_INVALID on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">odp_packet_t odp_packet_add_data(odp_packet_t pkt, uint32_t offset,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                                uint32_t len);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Remove data from an offset</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Decreases packet data length by removing data from the specified offset.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * The operation returns a new packet handle on success, and may modify</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * packet segmentation and move data. Handles and pointers must be updated</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * after the operation. User is responsible to update packet metadata offse</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">ts</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * when needed. The packet is not modified on an error.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt     Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param offset  Byte offset into the packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param len     Number of bytes to remove from the offset</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return New packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval ODP_PACKET_INVALID on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">odp_packet_t odp_packet_rem_data(odp_packet_t pkt, uint32_t offset,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                                uint32_t len);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/*</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Copy</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * ********************************************************</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Copy packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Create a new copy of the packet. The new packet is exact copy of the sou</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">rce</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * packet (incl. data and metadata). The pool must have been created with</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * ODP_POOL_PACKET type.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt   Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pool  Buffer pool for allocation of the new packet.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @return Handle to the copy of the packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval ODP_PACKET_INVALID on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">odp_packet_t odp_packet_copy(odp_packet_t pkt, odp_pool_t pool);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Copy data from packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Copy 'len' bytes of data from the packet level offset to the destination</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * address.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt    Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param offset Byte offset into the packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param len    Number of bytes to copy</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param dst    Destination address</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval 0 on success</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval &lt;0 on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">int odp_packet_copydata_out(odp_packet_t pkt, uint32_t offset,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                           uint32_t len, void *dst);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Copy data into packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * Copy    'len' bytes of data from the source address into the packet leve</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">l</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * offset. Maximum number of bytes to copy is packet data length minus the</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * offset. Packet is not modified on an error.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param pkt    Packet handle</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param offset Byte offset into the packet</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param len    Number of bytes to copy</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @param src    Source address</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval 0 on success</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * @retval &lt;0 on failure</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">int odp_packet_copydata_in(odp_packet_t pkt, uint32_t offset,</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                          uint32_t len, const void *src);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/*</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> * Debugging</td><td> </td><td class="right"> * Debugging</td></tr>
      <tr><td class="left"> * ********************************************************</td><td> </td><td class="right"> * ********************************************************</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Print packet to the console</td><td> </td><td class="right"> * Print packet to the console</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Print all packet debug information to the console.</td><td> </td><td class="right"> * Print all packet debug information to the console.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 27 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>244 lines changed or deleted</i></th><th><i> </i></th><th><i>686 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_flags.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_flags.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 288</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 288</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check for packet flow hash</td><td> </td><td class="right"> * Check for packet flow hash</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt Packet handle</td><td> </td><td class="right"> * @param pkt Packet handle</td></tr>
      <tr><td class="left"> * @retval non-zero if packet contains a hash value</td><td> </td><td class="right"> * @retval non-zero if packet contains a hash value</td></tr>
      <tr><td class="left"> * @retval 0 if packet does not contain a hash value</td><td> </td><td class="right"> * @retval 0 if packet does not contain a hash value</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_packet_has_flow_hash(odp_packet_t pkt);</td><td> </td><td class="right">int odp_packet_has_flow_hash(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Check for packet timestamp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval non-zero if packet contains a timestamp value</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 if packet does not contain a timestamp value</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see odp_packet_has_ts_clr()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_packet_has_ts(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Set flag for L2 header, e.g. ethernet</td><td> </td><td class="right"> * Set flag for L2 header, e.g. ethernet</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt Packet handle</td><td> </td><td class="right"> * @param pkt Packet handle</td></tr>
      <tr><td class="left"> * @param val Value</td><td> </td><td class="right"> * @param val Value</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_packet_has_l2_set(odp_packet_t pkt, int val);</td><td> </td><td class="right">void odp_packet_has_l2_set(odp_packet_t pkt, int val);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Set flag for L3 header, e.g. IPv4, IPv6</td><td> </td><td class="right"> * Set flag for L3 header, e.g. IPv4, IPv6</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 465</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 477</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Clear flag for packet flow hash</td><td> </td><td class="right"> * Clear flag for packet flow hash</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt Packet handle</td><td> </td><td class="right"> * @param pkt Packet handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Set this flag is only possible through odp_packet_flow_hash_set()</td><td> </td><td class="right"> * @note Set this flag is only possible through odp_packet_flow_hash_set()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_packet_has_flow_hash_clr(odp_packet_t pkt);</td><td> </td><td class="right">void odp_packet_has_flow_hash_clr(odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Clear flag for packet timestamp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This call clears the timestamp flag. A odp_packet_ts_set() call sets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the flag in addition to the timestamp value.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pkt Packet handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @see odp_packet_has_ts(), odp_packet_ts_set()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_packet_has_ts_clr(odp_packet_t pkt);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_end.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>24 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_io.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_io.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_PACKET_IO_H_</td><td> </td><td class="right">#ifndef ODP_API_PACKET_IO_H_</td></tr>
      <tr><td class="left">#define ODP_API_PACKET_IO_H_</td><td> </td><td class="right">#define ODP_API_PACKET_IO_H_</td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_begin.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_begin.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">#include <span class="delete">&lt;odp/api/spec/packet_io_stats.h&gt;</span></td><td> </td><td class="rblock">#include <span class="insert">&lt;odp/api/packet_io_stats.h&gt;</span></td></tr>
      <tr><td class="lblock">#include <span class="delete">&lt;odp/api/spec/queue.h&gt;</span></td><td> </td><td class="rblock">#include <span class="insert">&lt;odp/api/queue.h&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/api/time.h&gt;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @defgroup odp_packet_io ODP PACKET IO</td><td> </td><td class="right">/** @defgroup odp_packet_io ODP PACKET IO</td></tr>
      <tr><td class="left"> *  Operations on a packet Input/Output interface.</td><td> </td><td class="right"> *  Operations on a packet Input/Output interface.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet IO is the Ingress and Egress interface to ODP processing. It</td><td> </td><td class="right"> * Packet IO is the Ingress and Egress interface to ODP processing. It</td></tr>
      <tr><td class="left"> * allows manipulation of the interface for setting such attributes as</td><td> </td><td class="right"> * allows manipulation of the interface for setting such attributes as</td></tr>
      <tr><td class="left"> * the mtu, mac etc.</td><td> </td><td class="right"> * the mtu, mac etc.</td></tr>
      <tr><td class="left"> * Pktio is usually followed by the classifier and a default class COS</td><td> </td><td class="right"> * Pktio is usually followed by the classifier and a default class COS</td></tr>
      <tr><td class="left"> * can be set so that the scheduler may distribute flows. The interface</td><td> </td><td class="right"> * can be set so that the scheduler may distribute flows. The interface</td></tr>
      <tr><td class="left"> * may be used directly in polled mode with odp_pktin_recv() and</td><td> </td><td class="right"> * may be used directly in polled mode with odp_pktin_recv() and</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 67</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 68</em></th></tr>
      <tr><td class="left"> * Invalid packet IO handle</td><td> </td><td class="right"> * Invalid packet IO handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_PKTIO_MACADDR_MAXSIZE</td><td> </td><td class="right"> * @def ODP_PKTIO_MACADDR_MAXSIZE</td></tr>
      <tr><td class="left"> * Minimum size of output buffer for odp_pktio_mac_addr()</td><td> </td><td class="right"> * Minimum size of output buffer for odp_pktio_mac_addr()</td></tr>
      <tr><td class="left"> * Actual MAC address sizes may be different.</td><td> </td><td class="right"> * Actual MAC address sizes may be different.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* @def ODP_PKTIN_NO_WAIT</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Do not wait on packet input</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @def ODP_PKTIN_WAIT</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Wait infinitely on packet input</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Packet input mode</td><td> </td><td class="right"> * Packet input mode</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum odp_pktin_mode_t {</td><td> </td><td class="right">typedef enum odp_pktin_mode_t {</td></tr>
      <tr><td class="left">       /** Direct packet input from the interface */</td><td> </td><td class="right">       /** Direct packet input from the interface */</td></tr>
      <tr><td class="left">       ODP_PKTIN_MODE_DIRECT = 0,</td><td> </td><td class="right">       ODP_PKTIN_MODE_DIRECT = 0,</td></tr>
      <tr><td class="left">       /** Packet input through scheduler and scheduled event queues */</td><td> </td><td class="right">       /** Packet input through scheduler and scheduled event queues */</td></tr>
      <tr><td class="left">       ODP_PKTIN_MODE_SCHED,</td><td> </td><td class="right">       ODP_PKTIN_MODE_SCHED,</td></tr>
      <tr><td class="left">       /** Packet input through plain event queues */</td><td> </td><td class="right">       /** Packet input through plain event queues */</td></tr>
      <tr><td class="left">       ODP_PKTIN_MODE_QUEUE,</td><td> </td><td class="right">       ODP_PKTIN_MODE_QUEUE,</td></tr>
      <tr><td class="left">       /** Application will never receive from this interface */</td><td> </td><td class="right">       /** Application will never receive from this interface */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 125</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 136</em></th></tr>
      <tr><td class="left">       } proto;</td><td> </td><td class="right">       } proto;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** All bits of the bit field structure */</td><td> </td><td class="right">       /** All bits of the bit field structure */</td></tr>
      <tr><td class="left">       uint32_t all_bits;</td><td> </td><td class="right">       uint32_t all_bits;</td></tr>
      <tr><td class="left">} odp_pktin_hash_proto_t;</td><td> </td><td class="right">} odp_pktin_hash_proto_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO operation mode</td><td> </td><td class="right"> * Packet IO operation mode</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum odp_pktio_op_mode_t {</td><td> </td><td class="right">typedef enum odp_pktio_op_mode_t {</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">       /** Multi<span class="delete">-</span>thread safe operation</td><td> </td><td class="rblock">       /** Multithread safe operation</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">         * Direct packet IO operation (recv or send) is multi<span class="delete">-thread safe. 
A</span>ny</td><td> </td><td class="rblock">         * Direct packet IO operation (recv or send) is multi<span class="insert">thread safe. A
</span>ny</td></tr>
      <tr><td class="left">         * number of application threads may perform the operation</td><td> </td><td class="right">         * number of application threads may perform the operation</td></tr>
      <tr><td class="left">         * concurrently. */</td><td> </td><td class="right">         * concurrently. */</td></tr>
      <tr><td class="left">       ODP_PKTIO_OP_MT = 0,</td><td> </td><td class="right">       ODP_PKTIO_OP_MT = 0,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">       /** Not multi<span class="delete">-</span>thread safe operation</td><td> </td><td class="rblock">       /** Not multithread safe operation</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock">         * Direct packet IO operation (recv or send) may not be multi<span class="delete">-threa
</span>d</td><td> </td><td class="rblock">         * Direct packet IO operation (recv or send) may not be multi<span class="insert">threa</span>d</td></tr>
      <tr><td class="left">         * safe. Application ensures synchronization between threads so tha
t</td><td> </td><td class="right">         * safe. Application ensures synchronization between threads so tha
t</td></tr>
      <tr><td class="left">         * simultaneously only single thread attempts the operation on</td><td> </td><td class="right">         * simultaneously only single thread attempts the operation on</td></tr>
      <tr><td class="left">         * the same (pktin or pktout) queue. */</td><td> </td><td class="right">         * the same (pktin or pktout) queue. */</td></tr>
      <tr><td class="left">       ODP_PKTIO_OP_MT_UNSAFE</td><td> </td><td class="right">       ODP_PKTIO_OP_MT_UNSAFE</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_pktio_op_mode_t;</td><td> </td><td class="right">} odp_pktio_op_mode_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet input queue parameters</td><td> </td><td class="right"> * Packet input queue parameters</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pktin_queue_param_t {</td><td> </td><td class="right">typedef struct odp_pktin_queue_param_t {</td></tr>
      <tr><td class="left">       /** Operation mode</td><td> </td><td class="right">       /** Operation mode</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * The default value is ODP_PKTIO_OP_MT. Application may enable</td><td> </td><td class="right">         * The default value is ODP_PKTIO_OP_MT. Application may enable</td></tr>
      <tr><td class="left">         * performance optimization by defining ODP_PKTIO_OP_MT_UNSAFE when</td><td> </td><td class="right">         * performance optimization by defining ODP_PKTIO_OP_MT_UNSAFE when</td></tr>
      <tr><td class="left">         * applicable. */</td><td> </td><td class="right">         * applicable. */</td></tr>
      <tr><td class="left">       odp_pktio_op_mode_t op_mode;</td><td> </td><td class="right">       odp_pktio_op_mode_t op_mode;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Enable classifier</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * * 0: Classifier is disabled (default)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * * 1: Classifier is enabled. Use classifier to direct incoming</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      packets into pktin event queues. Classifier can be enabled</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      only in ODP_PKTIN_MODE_SCHED and ODP_PKTIN_MODE_QUEUE modes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      Both classifier and hashing cannot be enabled simultaneousl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      ('hash_enable' must be 0). */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t classifier_enable;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** Enable flow hashing</td><td> </td><td class="right">       /** Enable flow hashing</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock">         * 0: Do not hash flows</td><td> </td><td class="rblock">         *</td></tr>
      <tr><td class="lblock">         * 1: <span class="delete">Hash flows</span> to input <span class="delete">queues</span> */</td><td> </td><td class="rblock">         <span class="insert">* *</span> 0: Do not hash flows <span class="insert">(default)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span> * 1: <span class="insert">Enable flow hashing. Use flow hashing</span> to <span class="insert">spread incoming</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      packets into</span> input <span class="insert">queues. Hashing can be enabled in all</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      modes. Both classifier and hashing cannot be enabled</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *      simultaneously ('classifier_enable' must be 0).</span> */</td></tr>
      <tr><td class="left">       odp_bool_t hash_enable;</td><td> </td><td class="right">       odp_bool_t hash_enable;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock">       /** Protocol field selection for <span class="delete">hashing.</span> Multiple protocols can be</td><td> </td><td class="rblock">       /** Protocol field selection for <span class="insert">hashing</span></td></tr>
      <tr><td class="lblock">         <span class="delete">*</span> selected. */</td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span> Multiple protocols can be selected. <span class="insert">Ignored when 'hash_enable' i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * zero. The default value is all bits zero.</span> */</td></tr>
      <tr><td class="left">       odp_pktin_hash_proto_t hash_proto;</td><td> </td><td class="right">       odp_pktin_hash_proto_t hash_proto;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock">       /** Number of input queues to be <span class="delete">created.</span> More than one input <span class="delete">queue</span></td><td> </td><td class="rblock">       /** Number of input queues to be <span class="insert">created</span></td></tr>
      <tr><td class="lblock"><span class="delete">         *</span> require <span class="delete">input</span> hashing or classifier <span class="delete">setup. Hash_proto is ignored</span></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"><span class="delete">         * when hash_enable is zero or num_queues is one. This</span> value <span class="delete">must b</span></td><td> </td><td class="rblock"><span class="insert">         * When classifier is enabled the number of queues may be zero</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">         * (in odp_pktin_queue_config() step), otherwise at least one</span></td></tr>
      <tr><td class="lblock">         * <span class="delete">between 1 and interface capability.</span> Queue type is defined by <span class="delete">the</span></td><td> </td><td class="rblock"><span class="insert">         * queue is required.</span> More than one input <span class="insert">queues</span> require <span class="insert">either flo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">w</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span> hashing or classifier <span class="insert">enabled. The maximum</span> value <span class="insert">is defined by</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">         * <span class="insert">pktio capability 'max_input_queues'.</span> Queue type is defined by <span class="insert">th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="left">         * input mode. The default value is 1. */</td><td> </td><td class="right">         * input mode. The default value is 1. */</td></tr>
      <tr><td class="left">       unsigned num_queues;</td><td> </td><td class="right">       unsigned num_queues;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">       /** Queue parameters for <span class="delete">creating</span> input <span class="delete">queues</span> in <span class="delete">ODP_PKTIN_MODE_QUE</span></td><td> </td><td class="rblock">       /** Queue parameters</td></tr>
      <tr><td class="lblock"><span class="delete">UE</span></td><td> </td><td class="rblock">         <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * These are used</span> for input <span class="insert">queue creation</span> in <span class="insert">ODP_PKTIN_MODE_QUEUE</span></td></tr>
      <tr><td class="left">         * or ODP_PKTIN_MODE_SCHED modes. Scheduler parameters are consider
ed</td><td> </td><td class="right">         * or ODP_PKTIN_MODE_SCHED modes. Scheduler parameters are consider
ed</td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock">         * only in ODP_PKTIN_MODE_SCHED mode. */</td><td> </td><td class="rblock">         * only in ODP_PKTIN_MODE_SCHED mode. <span class="insert">Default values are defined in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * odp_queue_param_t documentation.</span> */</td></tr>
      <tr><td class="left">       odp_queue_param_t queue_param;</td><td> </td><td class="right">       odp_queue_param_t queue_param;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_pktin_queue_param_t;</td><td> </td><td class="right">} odp_pktin_queue_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet output queue parameters</td><td> </td><td class="right"> * Packet output queue parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * These parameters are used in ODP_PKTOUT_MODE_DIRECT and</td><td> </td><td class="right"> * These parameters are used in ODP_PKTOUT_MODE_DIRECT and</td></tr>
      <tr><td class="left"> * ODP_PKTOUT_MODE_QUEUE modes.</td><td> </td><td class="right"> * ODP_PKTOUT_MODE_QUEUE modes.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 199</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 232</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Number of output queues to be created. The value must be between</td><td> </td><td class="right">       /** Number of output queues to be created. The value must be between</td></tr>
      <tr><td class="left">         * 1 and interface capability. The default value is 1. */</td><td> </td><td class="right">         * 1 and interface capability. The default value is 1. */</td></tr>
      <tr><td class="left">       unsigned num_queues;</td><td> </td><td class="right">       unsigned num_queues;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_pktout_queue_param_t;</td><td> </td><td class="right">} odp_pktout_queue_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO parameters</td><td> </td><td class="right"> * Packet IO parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">In minimum, user must select input and output modes.</span> Use <span class="delete">0 for defaults.</span></td><td> </td><td class="rblock"> * <span class="insert">Packet IO interface level parameters.</span> Use <span class="insert">odp_pktio_param_init() to</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">Initialize entire struct</span> with <span class="delete">zero to maintain API compatibility.</span></td><td> </td><td class="rblock"> * <span class="insert">initialize the structure</span> with <span class="insert">default values.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pktio_param_t {</td><td> </td><td class="right">typedef struct odp_pktio_param_t {</td></tr>
      <tr><td class="left">       /** Packet input mode</td><td> </td><td class="right">       /** Packet input mode</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * The default value is ODP_PKTIN_MODE_DIRECT. */</td><td> </td><td class="right">         * The default value is ODP_PKTIN_MODE_DIRECT. */</td></tr>
      <tr><td class="left">       odp_pktin_mode_t in_mode;</td><td> </td><td class="right">       odp_pktin_mode_t in_mode;</td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                                           </span></td></tr>
      <tr><td class="left">       /** Packet output mode</td><td> </td><td class="right">       /** Packet output mode</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * The default value is ODP_PKTOUT_MODE_DIRECT. */</td><td> </td><td class="right">         * The default value is ODP_PKTOUT_MODE_DIRECT. */</td></tr>
      <tr><td class="left">       odp_pktout_mode_t out_mode;</td><td> </td><td class="right">       odp_pktout_mode_t out_mode;</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                                           </span></td></tr>
      <tr><td class="left">} odp_pktio_param_t;</td><td> </td><td class="right">} odp_pktio_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Packet input configuration options bit field</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet input configuration options listed in a bit field structure. Pack</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">et</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * input timestamping may be enabled for all packets or at least for those </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * belong to time synchronization protocol (PTP).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet input checksum checking may be enabled or disabled. When it is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * enabled, implementation will verify checksum correctness on incoming pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">kets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and depending on drop configuration either deliver erroneous packets wit</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">h</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * appropriate flags set (e.g. odp_packet_has_l3_error()) or drop those.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When packet dropping is enabled, application will never receive a packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * with the specified error and may avoid to check the error flag.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef union odp_pktin_config_opt_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Option flags */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Timestamp all packets on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t ts_all        : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Timestamp (at least) IEEE1588 / PTP packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                 * on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t ts_ptp        : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Check IPv4 header checksum on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t ipv4_chksum   : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Check UDP checksum on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t udp_chksum    : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Check TCP checksum on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t tcp_chksum    : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Check SCTP checksum on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t sctp_chksum   : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Drop packets with an IPv4 error on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t drop_ipv4_err : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Drop packets with an IPv6 error on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t drop_ipv6_err : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Drop packets with a UDP error on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t drop_udp_err  : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Drop packets with a TCP error on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t drop_tcp_err  : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Drop packets with a SCTP error on packet input */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t drop_sctp_err : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } bit;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All bits of the bit field structure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * This field can be used to set/clear all flags, or bitwise</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * operations over the entire structure. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint64_t all_bits;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_pktin_config_opt_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet output configuration options bit field</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet output configuration options listed in a bit field structure. Pac</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ket</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * output checksum insertion may be enabled or disabled. When it is enabled</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * implementation will calculate and insert checksum into every outgoing pa</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cket</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * by default. Application may use a packet metadata flag to disable checks</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">um</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * insertion per packet bases. For correct operation, packet metadata must</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * provide valid offsets for the appropriate protocols. For example, UDP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * checksum calculation needs both L3 and L4 offsets (to access IP and UDP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * headers). When application (e.g. a switch) does not modify L3/L4 data an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * thus checksum does not need to be updated, output checksum insertion sho</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uld</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * be disabled for optimal performance.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef union odp_pktout_config_opt_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Option flags */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert IPv4 header checksum on packet output */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t ipv4_chksum  : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert UDP checksum on packet output */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t udp_chksum   : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert TCP checksum on packet output */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t tcp_chksum   : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Insert SCTP checksum on packet output */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint64_t sctp_chksum  : 1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } bit;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** All bits of the bit field structure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * This field can be used to set/clear all flags, or bitwise</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * operations over the entire structure. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint64_t all_bits;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_pktout_config_opt_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet IO configuration options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet IO interface level configuration options. Use odp_pktio_capabilit</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to see which options are supported by the implementation.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Use odp_pktio_config_init() to initialize the structure with default val</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ues.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_pktio_config_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Packet input configuration options bit field</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Default value for all bits is zero. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_pktin_config_opt_t pktin;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Packet output configuration options bit field</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *  Default value for all bits is zero. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_pktout_config_opt_t pktout;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Interface loopback mode</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * In this mode the packets sent out through the interface is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * looped back to input of the same interface. Supporting loopback m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ode</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * is an optional feature per interface and should be queried in the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * interface capability before enabling the same. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t enable_loop;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_pktio_config_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Packet IO set operations</td><td> </td><td class="right"> * Packet IO set operations</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Supported packet IO interface set operations listed in a bit field struc
ture.</td><td> </td><td class="right"> * Supported packet IO interface set operations listed in a bit field struc
ture.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef union odp_pktio_set_op_t {</td><td> </td><td class="right">typedef union odp_pktio_set_op_t {</td></tr>
      <tr><td class="left">       /** Operation flags */</td><td> </td><td class="right">       /** Operation flags */</td></tr>
      <tr><td class="left">       struct {</td><td> </td><td class="right">       struct {</td></tr>
      <tr><td class="left">               /** Promiscuous mode */</td><td> </td><td class="right">               /** Promiscuous mode */</td></tr>
      <tr><td class="left">               uint32_t promisc_mode : 1;</td><td> </td><td class="right">               uint32_t promisc_mode : 1;</td></tr>
      <tr><td class="left">       } op;</td><td> </td><td class="right">       } op;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 236</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 397</em></th></tr>
      <tr><td class="left">         * operations over the entire structure. */</td><td> </td><td class="right">         * operations over the entire structure. */</td></tr>
      <tr><td class="left">       uint32_t all_bits;</td><td> </td><td class="right">       uint32_t all_bits;</td></tr>
      <tr><td class="left">} odp_pktio_set_op_t;</td><td> </td><td class="right">} odp_pktio_set_op_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO capabilities</td><td> </td><td class="right"> * Packet IO capabilities</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pktio_capability_t {</td><td> </td><td class="right">typedef struct odp_pktio_capability_t {</td></tr>
      <tr><td class="left">       /** Maximum number of input queues */</td><td> </td><td class="right">       /** Maximum number of input queues */</td></tr>
      <tr><td class="left">       unsigned max_input_queues;</td><td> </td><td class="right">       unsigned max_input_queues;</td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                                                                           </span></td></tr>
      <tr><td class="left">       /** Maximum number of output queues */</td><td> </td><td class="right">       /** Maximum number of output queues */</td></tr>
      <tr><td class="left">       unsigned max_output_queues;</td><td> </td><td class="right">       unsigned max_output_queues;</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Supported pktio configuration options */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_pktio_config_t config;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">       /** Supported set operations</td><td> </td><td class="right">       /** Supported set operations</td></tr>
      <tr><td class="left">        *</td><td> </td><td class="right">        *</td></tr>
      <tr><td class="left">        * A bit set to one indicates a supported operation. All other bits 
are</td><td> </td><td class="right">        * A bit set to one indicates a supported operation. All other bits 
are</td></tr>
      <tr><td class="left">        * set to zero. */</td><td> </td><td class="right">        * set to zero. */</td></tr>
      <tr><td class="left">       odp_pktio_set_op_t set_op;</td><td> </td><td class="right">       odp_pktio_set_op_t set_op;</td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Support of Loopback mode</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * A boolean to denote whether loop back mode is supported on this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * specific interface. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t loop_supported;</span></td></tr>
      <tr><td class="left">} odp_pktio_capability_t;</td><td> </td><td class="right">} odp_pktio_capability_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Open a packet IO interface</td><td> </td><td class="right"> * Open a packet IO interface</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * An ODP program can open a single packet IO interface per device, attempt
s</td><td> </td><td class="right"> * An ODP program can open a single packet IO interface per device, attempt
s</td></tr>
      <tr><td class="left"> * to open an already open device will fail, returning ODP_PKTIO_INVALID wi
th</td><td> </td><td class="right"> * to open an already open device will fail, returning ODP_PKTIO_INVALID wi
th</td></tr>
      <tr><td class="left"> * errno set. Use odp_pktio_lookup() to obtain a handle to an already open</td><td> </td><td class="right"> * errno set. Use odp_pktio_lookup() to obtain a handle to an already open</td></tr>
      <tr><td class="left"> * device. Packet IO parameters provide interface level configuration optio
ns.</td><td> </td><td class="right"> * device. Packet IO parameters provide interface level configuration optio
ns.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Use odp_pktio_param_init() to initialize packet IO parameters into their</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * default values. Default values are also used when 'param' pointer is NUL</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">L.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="left"> * Packet input queue configuration must be setup with</td><td> </td><td class="right"> * Packet input queue configuration must be setup with</td></tr>
      <tr><td class="left"> * odp_pktin_queue_config() before odp_pktio_start() is called. When packet</td><td> </td><td class="right"> * odp_pktin_queue_config() before odp_pktio_start() is called. When packet</td></tr>
      <tr><td class="left"> * input mode is ODP_PKTIN_MODE_DISABLED, odp_pktin_queue_config() call is</td><td> </td><td class="right"> * input mode is ODP_PKTIN_MODE_DISABLED, odp_pktin_queue_config() call is</td></tr>
      <tr><td class="left"> * optional and will ignore all parameters.</td><td> </td><td class="right"> * optional and will ignore all parameters.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Packet output queue configuration must be setup with</td><td> </td><td class="right"> * Packet output queue configuration must be setup with</td></tr>
      <tr><td class="left"> * odp_pktout_queue_config() before odp_pktio_start() is called. When packe
t</td><td> </td><td class="right"> * odp_pktout_queue_config() before odp_pktio_start() is called. When packe
t</td></tr>
      <tr><td class="left"> * output mode is ODP_PKTOUT_MODE_DISABLED or ODP_PKTOUT_MODE_TM,</td><td> </td><td class="right"> * output mode is ODP_PKTOUT_MODE_DISABLED or ODP_PKTOUT_MODE_TM,</td></tr>
      <tr><td class="left"> * odp_pktout_queue_config() call is optional and will ignore all parameter
s.</td><td> </td><td class="right"> * odp_pktout_queue_config() call is optional and will ignore all parameter
s.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l6" /><small>skipping to change at</small><em> line 281</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 456</em></th></tr>
      <tr><td class="left"> *   * odp_pktout_queue_config()</td><td> </td><td class="right"> *   * odp_pktout_queue_config()</td></tr>
      <tr><td class="left"> *   * odp_pktio_start()</td><td> </td><td class="right"> *   * odp_pktio_start()</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * ... and tear down sequence is:</td><td> </td><td class="right"> * ... and tear down sequence is:</td></tr>
      <tr><td class="left"> *   * odp_pktio_stop()</td><td> </td><td class="right"> *   * odp_pktio_stop()</td></tr>
      <tr><td class="left"> *   * odp_pktio_close()</td><td> </td><td class="right"> *   * odp_pktio_close()</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param name   Packet IO device name</td><td> </td><td class="right"> * @param name   Packet IO device name</td></tr>
      <tr><td class="left"> * @param pool   Default pool from which to allocate storage for packets</td><td> </td><td class="right"> * @param pool   Default pool from which to allocate storage for packets</td></tr>
      <tr><td class="left"> *               received over this interface, must be of type ODP_POOL_PAC
KET</td><td> </td><td class="right"> *               received over this interface, must be of type ODP_POOL_PAC
KET</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock"> * @param param  Packet IO parameters</td><td> </td><td class="rblock"> * @param param  Packet IO parameters<span class="insert">. Uses defaults when NULL.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Packet IO handle</td><td> </td><td class="right"> * @return Packet IO handle</td></tr>
      <tr><td class="left"> * @retval ODP_PKTIO_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_PKTIO_INVALID on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note The device name "loop" is a reserved name for a loopback device us
ed</td><td> </td><td class="right"> * @note The device name "loop" is a reserved name for a loopback device us
ed</td></tr>
      <tr><td class="left"> *      for testing purposes.</td><td> </td><td class="right"> *      for testing purposes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Packets arriving via this interface assigned to a CoS by the</td><td> </td><td class="right"> * @note Packets arriving via this interface assigned to a CoS by the</td></tr>
      <tr><td class="left"> *      classifier are received into the pool associated with that CoS. Thi
s</td><td> </td><td class="right"> *      classifier are received into the pool associated with that CoS. Thi
s</td></tr>
      <tr><td class="left"> *      will occur either because this pktio is assigned a default CoS via</td><td> </td><td class="right"> *      will occur either because this pktio is assigned a default CoS via</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l7" /><small>skipping to change at</small><em> line 316</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 491</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pktio  Packet IO handle</td><td> </td><td class="right"> * @param      pktio  Packet IO handle</td></tr>
      <tr><td class="left"> * @param[out] capa   Pointer to capability structure for output</td><td> </td><td class="right"> * @param[out] capa   Pointer to capability structure for output</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_capability(odp_pktio_t pktio, odp_pktio_capability_t *capa);</td><td> </td><td class="right">int odp_pktio_capability(odp_pktio_t pktio, odp_pktio_capability_t *capa);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Maximum packet IO interface index</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Return the maximum packet IO interface index. Interface indexes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (e.g. returned by odp_pktio_index()) range from zero to this maximum val</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Maximum packet IO interface index</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">unsigned odp_pktio_max_index(void);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Configure packet IO interface options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Select interface level configuration options before the interface is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * activated (before odp_pktio_start() call). This step is optional in pkti</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * interface setup sequence. Use odp_pktio_capability() to query configurat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ion</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * capabilities. Use odp_pktio_config_init() to initialize</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * configuration options into their default values. Default values are used</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * when 'config' pointer is NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pktio    Packet IO handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param config   Packet IO interface configuration. Uses defaults</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                 when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_pktio_config(odp_pktio_t pktio, const odp_pktio_config_t *config);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Configure packet input queues</td><td> </td><td class="right"> * Configure packet input queues</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Setup a number of packet input queues and configure those. The maximum n
umber</td><td> </td><td class="right"> * Setup a number of packet input queues and configure those. The maximum n
umber</td></tr>
      <tr><td class="left"> * of queues is platform dependent and can be queried with</td><td> </td><td class="right"> * of queues is platform dependent and can be queried with</td></tr>
      <tr><td class="left"> * odp_pktio_capability(). Use odp_pktin_queue_param_init() to initialize</td><td> </td><td class="right"> * odp_pktio_capability(). Use odp_pktin_queue_param_init() to initialize</td></tr>
      <tr><td class="left"> * parameters into their default values. Default values are also used when</td><td> </td><td class="right"> * parameters into their default values. Default values are also used when</td></tr>
      <tr><td class="left"> * 'param' pointer is NULL.</td><td> </td><td class="right"> * 'param' pointer is NULL.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Queue handles for input queues can be requested with odp_pktin_queue() o
r</td><td> </td><td class="right"> * Queue handles for input queues can be requested with odp_pktin_queue() o
r</td></tr>
      <tr><td class="left"> * odp_pktin_event_queue() after this call. All requested queues are setup 
on</td><td> </td><td class="right"> * odp_pktin_event_queue() after this call. All requested queues are setup 
on</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l8" /><small>skipping to change at</small><em> line 491</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 695</em></th></tr>
      <tr><td class="left"> * @see odp_pktio_start(), odp_pktio_close()</td><td> </td><td class="right"> * @see odp_pktio_start(), odp_pktio_close()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_stop(odp_pktio_t pktio);</td><td> </td><td class="right">int odp_pktio_stop(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Close a packet IO interface</td><td> </td><td class="right"> * Close a packet IO interface</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Close a stopped packet IO interface. This call frees all remaining packe
ts</td><td> </td><td class="right"> * Close a stopped packet IO interface. This call frees all remaining packe
ts</td></tr>
      <tr><td class="left"> * stored in pktio receive and transmit side buffers. The pktio is destroye
d</td><td> </td><td class="right"> * stored in pktio receive and transmit side buffers. The pktio is destroye
d</td></tr>
      <tr><td class="left"> * and the handle must not be used for other calls. After a successful call
,</td><td> </td><td class="right"> * and the handle must not be used for other calls. After a successful call
,</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * the same pktio device can be opened again with a odp_p<span class="delete">acket</span>_open() call.</td><td> </td><td class="rblock"> * the same pktio device can be opened again with a odp_p<span class="insert">ktio</span>_open() call.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pktio  Packet IO handle</td><td> </td><td class="right"> * @param pktio  Packet IO handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_pktio_stop(), odp_pktio_open()</td><td> </td><td class="right"> * @see odp_pktio_stop(), odp_pktio_open()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_close(odp_pktio_t pktio);</td><td> </td><td class="right">int odp_pktio_close(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l9" /><small>skipping to change at</small><em> line 515</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 719</em></th></tr>
      <tr><td class="left"> * @param name   Packet IO device name</td><td> </td><td class="right"> * @param name   Packet IO device name</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Packet IO handle</td><td> </td><td class="right"> * @return Packet IO handle</td></tr>
      <tr><td class="left"> * @retval ODP_PKTIO_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_PKTIO_INVALID on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_pktio_t odp_pktio_lookup(const char *name);</td><td> </td><td class="right">odp_pktio_t odp_pktio_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Receive packets directly from an interface input queue</td><td> </td><td class="right"> * Receive packets directly from an interface input queue</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"> * Receives up to 'num' packets from the pktio interface input queue. <span class="delete">When</span></td><td> </td><td class="rblock"> * Receives up to 'num' packets from the pktio interface input queue. <span class="insert">Retur</span></td></tr>
      <tr><td class="lblock"> * input queue parameter 'op_mode' has been set to <span class="delete">ODP_PKTIO_OP_MT_UNSAFE,</span></td><td> </td><td class="rblock"><span class="insert">ns</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the number of packets received.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* When</span> input queue parameter 'op_mode' has been set to <span class="insert">ODP_PKTIO_OP_MT_UNS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">AFE,</span></td></tr>
      <tr><td class="left"> * the operation is optimized for single thread operation per queue and the
 same</td><td> </td><td class="right"> * the operation is optimized for single thread operation per queue and the
 same</td></tr>
      <tr><td class="left"> * queue must not be accessed simultaneously from multiple threads.</td><td> </td><td class="right"> * queue must not be accessed simultaneously from multiple threads.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      queue      Packet input queue handle for receiving packets</td><td> </td><td class="right"> * @param      queue      Packet input queue handle for receiving packets</td></tr>
      <tr><td class="left"> * @param[out] packets[]  Packet handle array for output of received packet
s</td><td> </td><td class="right"> * @param[out] packets[]  Packet handle array for output of received packet
s</td></tr>
      <tr><td class="left"> * @param      num        Maximum number of packets to receive</td><td> </td><td class="right"> * @param      num        Maximum number of packets to receive</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Number of packets received</td><td> </td><td class="right"> * @return Number of packets received</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @see odp_pktin_queue()</td><td> </td><td class="right"> * @see odp_pktin_queue()</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktin_recv(odp_pktin_queue_t queue, odp_packet_t packets[], int num
);</td><td> </td><td class="right">int odp_pktin_recv(odp_pktin_queue_t queue, odp_packet_t packets[], int num
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Receive packets directly from an interface input queue with timeout</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Provides the same functionality as odp_pktin_recv(), except that waits i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">f</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * there are no packets available. Wait time is specified by the 'wait'</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * parameter.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      queue      Packet input queue handle for receiving packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] packets[]  Packet handle array for output of received packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num        Maximum number of packets to receive</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      wait       Wait time specified as as follows:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        * ODP_PKTIN_NO_WAIT: Do not wait</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        * ODP_PKTIN_WAIT:    Wait infinitely</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        * Other values specify the minimum time to wait.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          Use odp_pktin_wait_time() to convert nanosecond</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          to a valid parameter value. Wait time may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          rounded up a small, platform specific amount.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of packets received</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_pktin_recv_tmo(odp_pktin_queue_t queue, odp_packet_t packets[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                      int num, uint64_t wait);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Receive packets directly from multiple interface input queues with timeo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ut</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Receives up to 'num' packets from one of the specified pktio interface i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nput</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * queues. The index of the source queue is stored into 'from' output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * parameter. If there are no packets available on any of the queues, waits</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packets depending on 'wait' parameter value. Returns the number of packe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * received.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * When an input queue has been configured with 'op_mode' value</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODP_PKTIO_OP_MT_UNSAFE, the operation is optimized for single thread</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * operation and the same queue must not be accessed simultaneously from</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * multiple threads.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * It is implementation specific in which order the queues are checked for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * packets. Application may improve fairness of queue service levels by</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * circulating queue handles between consecutive calls (e.g. [q0, q1, q2, q</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">3] -&gt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * [q1, q2, q3, q0] -&gt; [q2, q3, ...).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      queues[]   Packet input queue handles for receiving packets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num_q      Number of input queues</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] from       Pointer for output of the source queue index. Ign</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ored</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        when NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] packets[]  Packet handle array for output of received packet</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      num        Maximum number of packets to receive</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      wait       Wait time specified as as follows:</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        * ODP_PKTIN_NO_WAIT: Do not wait</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        * ODP_PKTIN_WAIT:    Wait infinitely</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        * Other values specify the minimum time to wait.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          Use odp_pktin_wait_time() to convert nanosecond</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          to a valid parameter value. Wait time may be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          rounded up a small, platform specific amount.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Number of packets received</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_pktin_recv_mq_tmo(const odp_pktin_queue_t queues[], unsigned num_q,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         unsigned *from, odp_packet_t packets[], int num,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                         uint64_t wait);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet input wait time</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Converts nanoseconds to wait time values for packet input functions.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param nsec   Minimum number of nanoseconds to wait</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Wait parameter value for packet input functions</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint64_t odp_pktin_wait_time(uint64_t nsec);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Send packets directly to an interface output queue</td><td> </td><td class="right"> * Send packets directly to an interface output queue</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Sends out a number of packets to the interface output queue. When</td><td> </td><td class="right"> * Sends out a number of packets to the interface output queue. When</td></tr>
      <tr><td class="left"> * output queue parameter 'op_mode' has been set to ODP_PKTIO_OP_MT_UNSAFE,</td><td> </td><td class="right"> * output queue parameter 'op_mode' has been set to ODP_PKTIO_OP_MT_UNSAFE,</td></tr>
      <tr><td class="left"> * the operation is optimized for single thread operation per queue and the
 same</td><td> </td><td class="right"> * the operation is optimized for single thread operation per queue and the
 same</td></tr>
      <tr><td class="left"> * queue must not be accessed simultaneously from multiple threads.</td><td> </td><td class="right"> * queue must not be accessed simultaneously from multiple threads.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * A successful call returns the actual number of packets sent. If return v
alue</td><td> </td><td class="right"> * A successful call returns the actual number of packets sent. If return v
alue</td></tr>
      <tr><td class="left"> * is less than 'num', the remaining packets at the end of packets[] array</td><td> </td><td class="right"> * is less than 'num', the remaining packets at the end of packets[] array</td></tr>
      <tr><td class="left"> * are not consumed, and the caller has to take care of them.</td><td> </td><td class="right"> * are not consumed, and the caller has to take care of them.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param queue        Packet output queue handle for sending packets</td><td> </td><td class="right"> * @param queue        Packet output queue handle for sending packets</td></tr>
      <tr><td class="left"> * @param packets[]    Array of packets to send</td><td> </td><td class="right"> * @param packets[]    Array of packets to send</td></tr>
      <tr><td class="left"> * @param num          Number of packets to send</td><td> </td><td class="right"> * @param num          Number of packets to send</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Number of packets sent</td><td> </td><td class="right"> * @return Number of packets sent</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock">int odp_pktout_send(odp_pktout_queue_t queue, odp_packet_t packets[], int <span class="delete">n</span></td><td> </td><td class="rblock">int odp_pktout_send(odp_pktout_queue_t queue, <span class="insert">const</span> odp_packet_t packets[],</td></tr>
      <tr><td class="lblock"><span class="delete">um);</span></td><td> </td><td class="rblock">                   int <span class="insert">num);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Return the currently configured MTU value of a packet IO interface.</td><td> </td><td class="right"> * Return the currently configured MTU value of a packet IO interface.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] pktio  Packet IO handle.</td><td> </td><td class="right"> * @param[in] pktio  Packet IO handle.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return MTU value on success</td><td> </td><td class="right"> * @return MTU value on success</td></tr>
      <tr><td class="left"> * @retval 0 on failure</td><td> </td><td class="right"> * @retval 0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint32_t odp_pktio_mtu(odp_pktio_t pktio);</td><td> </td><td class="right">uint32_t odp_pktio_mtu(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l10" /><small>skipping to change at</small><em> line 654</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 936</em></th></tr>
      <tr><td class="left"> *                             defined ODP_PACKET_MAX_HEADROOM.</td><td> </td><td class="right"> *                             defined ODP_PACKET_MAX_HEADROOM.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval                     0 on success</td><td> </td><td class="right"> * @retval                     0 on success</td></tr>
      <tr><td class="left"> * @retval                     &lt;0 on failure</td><td> </td><td class="right"> * @retval                     &lt;0 on failure</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note Optional.</td><td> </td><td class="right"> * @note Optional.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_headroom_set(odp_pktio_t pktio, uint32_t headroom);</td><td> </td><td class="right">int odp_pktio_headroom_set(odp_pktio_t pktio, uint32_t headroom);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Get pktio interface index</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param pktio   Packet I/O handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return        Packet interface index (0..odp_pktio_max_index())</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0     On failure (e.g., handle not valid)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_pktio_index(odp_pktio_t pktio);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Get printable value for an odp_pktio_t</td><td> </td><td class="right"> * Get printable value for an odp_pktio_t</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pktio   odp_pktio_t handle to be printed</td><td> </td><td class="right"> * @param pktio   odp_pktio_t handle to be printed</td></tr>
      <tr><td class="left"> * @return     uint64_t value that can be used to print/display this</td><td> </td><td class="right"> * @return     uint64_t value that can be used to print/display this</td></tr>
      <tr><td class="left"> *             handle</td><td> </td><td class="right"> *             handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @note This routine is intended to be used for diagnostic purposes</td><td> </td><td class="right"> * @note This routine is intended to be used for diagnostic purposes</td></tr>
      <tr><td class="left"> * to enable applications to generate a printable value that represents</td><td> </td><td class="right"> * to enable applications to generate a printable value that represents</td></tr>
      <tr><td class="left"> * an odp_pktio_t handle.</td><td> </td><td class="right"> * an odp_pktio_t handle.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">uint64_t odp_pktio_to_u64(odp_pktio_t pktio);</td><td> </td><td class="right">uint64_t odp_pktio_to_u64(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lblock"> * In<span class="delete">tiai</span>lize pktio params</td><td> </td><td class="rblock"> * In<span class="insert">itia</span>lize pktio params</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Initialize an odp_pktio_param_t to its default values for all fields</td><td> </td><td class="right"> * Initialize an odp_pktio_param_t to its default values for all fields</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param param Address of the odp_pktio_param_t to be initialized</td><td> </td><td class="right"> * @param param Address of the odp_pktio_param_t to be initialized</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_pktio_param_init(odp_pktio_param_t *param);</td><td> </td><td class="right">void odp_pktio_param_init(odp_pktio_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize packet input queue parameters</td><td> </td><td class="right"> * Initialize packet input queue parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l11" /><small>skipping to change at</small><em> line 694</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 986</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Initialize packet output queue parameters</td><td> </td><td class="right"> * Initialize packet output queue parameters</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Initialize an odp_pktout_queue_param_t to its default values.</td><td> </td><td class="right"> * Initialize an odp_pktout_queue_param_t to its default values.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param param   Output queue parameter structure to be initialized</td><td> </td><td class="right"> * @param param   Output queue parameter structure to be initialized</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_pktout_queue_param_init(odp_pktout_queue_param_t *param);</td><td> </td><td class="right">void odp_pktout_queue_param_init(odp_pktout_queue_param_t *param);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Initialize packet IO configuration options</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Initialize an odp_pktio_config_t to its default values.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param config  Packet IO interface configuration</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void odp_pktio_config_init(odp_pktio_config_t *config);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Print pktio info to the console</td><td> </td><td class="right"> * Print pktio info to the console</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Print implementation-defined pktio debug information to the console.</td><td> </td><td class="right"> * Print implementation-defined pktio debug information to the console.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pktio                        Packet IO handle</td><td> </td><td class="right"> * @param pktio                        Packet IO handle</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_pktio_print(odp_pktio_t pktio);</td><td> </td><td class="right">void odp_pktio_print(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Determine pktio link is up or down for a packet IO interface.</td><td> </td><td class="right"> * Determine pktio link is up or down for a packet IO interface.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l12" /><small>skipping to change at</small><em> line 718</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 1019</em></th></tr>
      <tr><td class="left"> * @retval  0 link is down</td><td> </td><td class="right"> * @retval  0 link is down</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left">*/</td><td> </td><td class="right">*/</td></tr>
      <tr><td class="left">int odp_pktio_link_status(odp_pktio_t pktio);</td><td> </td><td class="right">int odp_pktio_link_status(odp_pktio_t pktio);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO information</td><td> </td><td class="right"> * Packet IO information</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pktio_info_t {</td><td> </td><td class="right">typedef struct odp_pktio_info_t {</td></tr>
      <tr><td class="left">       const char       *name;  /**&lt; Packet IO device name */</td><td> </td><td class="right">       const char       *name;  /**&lt; Packet IO device name */</td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const char       *drv_name; /**&lt; Packet IO driver name (implementati
on specific) */</span></td></tr>
      <tr><td class="left">       odp_pool_t        pool;  /**&lt; Packet pool */</td><td> </td><td class="right">       odp_pool_t        pool;  /**&lt; Packet pool */</td></tr>
      <tr><td class="left">       odp_pktio_param_t param; /**&lt; Packet IO parameters */</td><td> </td><td class="right">       odp_pktio_param_t param; /**&lt; Packet IO parameters */</td></tr>
      <tr><td class="left">} odp_pktio_info_t;</td><td> </td><td class="right">} odp_pktio_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Retrieve information about a pktio</td><td> </td><td class="right"> * Retrieve information about a pktio</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Fills in packet IO information structure with current parameter values.</td><td> </td><td class="right"> * Fills in packet IO information structure with current parameter values.</td></tr>
      <tr><td class="left"> * May be called any time with a valid pktio handle. The call is not</td><td> </td><td class="right"> * May be called any time with a valid pktio handle. The call is not</td></tr>
      <tr><td class="left"> * synchronized with configuration changing calls. The application should</td><td> </td><td class="right"> * synchronized with configuration changing calls. The application should</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l13" /><small>skipping to change at</small><em> line 741</em></th><th> </th><th><a name="part-r13" /><small>skipping to change at</small><em> line 1043</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param      pktio   Packet IO handle</td><td> </td><td class="right"> * @param      pktio   Packet IO handle</td></tr>
      <tr><td class="left"> * @param[out] info    Pointer to packet IO info struct for output</td><td> </td><td class="right"> * @param[out] info    Pointer to packet IO info struct for output</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval  0 on success</td><td> </td><td class="right"> * @retval  0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_pktio_info(odp_pktio_t pktio, odp_pktio_info_t *info);</td><td> </td><td class="right">int odp_pktio_info(odp_pktio_t pktio, odp_pktio_info_t *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Packet input timestamp resolution in hertz</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This is the resolution of packet input timestamps. Returns zero on a fai</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * or when timestamping is disabled.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pktio   Packet IO handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Packet input timestamp resolution in hertz</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">uint64_t odp_pktin_ts_res(odp_pktio_t pktio);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Convert nanoseconds to packet input time</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Packet input time source is used for timestamping incoming packets.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function is used convert nanosecond time to packet input timestamp </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">time.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      pktio   Packet IO handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      ns      Time in nanoseconds</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return Packet input timestamp</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">odp_time_t odp_pktin_ts_from_ns(odp_pktio_t pktio, uint64_t ns);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp/api/visibility_end.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/visibility_end.h&gt;</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 31 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>27 lines changed or deleted</i></th><th><i> </i></th><th><i>389 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;packet_io_stats.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;packet_io_stats.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 28</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 28</em></th></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @addtogroup odp_packet_io</td><td> </td><td class="right">/** @addtogroup odp_packet_io</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Packet IO statistics</td><td> </td><td class="right"> * Packet IO statistics</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * Packet IO stati<span class="delete">c</span>tics counters follow RFCs for Management Information Bas
e</td><td> </td><td class="rblock"> * Packet IO stati<span class="insert">s</span>tics counters follow RFCs for Management Information Bas
e</td></tr>
      <tr><td class="left"> * (MIB)for use with network management protocols in the Internet community
:</td><td> </td><td class="right"> * (MIB)for use with network management protocols in the Internet community
:</td></tr>
      <tr><td class="left"> * https://tools.ietf.org/html/rfc3635</td><td> </td><td class="right"> * https://tools.ietf.org/html/rfc3635</td></tr>
      <tr><td class="left"> * https://tools.ietf.org/html/rfc2863</td><td> </td><td class="right"> * https://tools.ietf.org/html/rfc2863</td></tr>
      <tr><td class="left"> * https://tools.ietf.org/html/rfc2819</td><td> </td><td class="right"> * https://tools.ietf.org/html/rfc2819</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pktio_stats_t {</td><td> </td><td class="right">typedef struct odp_pktio_stats_t {</td></tr>
      <tr><td class="left">       /**</td><td> </td><td class="right">       /**</td></tr>
      <tr><td class="left">        * The number of octets in valid MAC frames received on this interfa
ce,</td><td> </td><td class="right">        * The number of octets in valid MAC frames received on this interfa
ce,</td></tr>
      <tr><td class="left">        * including the MAC header and FCS. See ifHCInOctets counter</td><td> </td><td class="right">        * including the MAC header and FCS. See ifHCInOctets counter</td></tr>
      <tr><td class="left">        * description in RFC 3635 for details.</td><td> </td><td class="right">        * description in RFC 3635 for details.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 51</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 51</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /**</td><td> </td><td class="right">       /**</td></tr>
      <tr><td class="left">        * The number of packets, delivered by this sub-layer to a higher</td><td> </td><td class="right">        * The number of packets, delivered by this sub-layer to a higher</td></tr>
      <tr><td class="left">        * (sub-)layer, which were not addressed to a multicast or broadcast</td><td> </td><td class="right">        * (sub-)layer, which were not addressed to a multicast or broadcast</td></tr>
      <tr><td class="left">        * address at this sub-layer. See ifHCInUcastPkts in RFC 2863, RFC 3
635.</td><td> </td><td class="right">        * address at this sub-layer. See ifHCInUcastPkts in RFC 2863, RFC 3
635.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       uint64_t in_ucast_pkts;</td><td> </td><td class="right">       uint64_t in_ucast_pkts;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /**</td><td> </td><td class="right">       /**</td></tr>
      <tr><td class="left">        * The number of inbound packets which were chosen to be discarded</td><td> </td><td class="right">        * The number of inbound packets which were chosen to be discarded</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">        * even though no errors had been detected to preven their being</td><td> </td><td class="rblock">        * even though no errors had been detected to preven<span class="insert">t</span> their being</td></tr>
      <tr><td class="left">        * deliverable to a higher-layer protocol.  One possible reason for</td><td> </td><td class="right">        * deliverable to a higher-layer protocol.  One possible reason for</td></tr>
      <tr><td class="left">        * discarding such a packet could be to free up buffer space.</td><td> </td><td class="right">        * discarding such a packet could be to free up buffer space.</td></tr>
      <tr><td class="left">        * See ifInDiscards in RFC 2863.</td><td> </td><td class="right">        * See ifInDiscards in RFC 2863.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>
      <tr><td class="left">       uint64_t in_discards;</td><td> </td><td class="right">       uint64_t in_discards;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /**</td><td> </td><td class="right">       /**</td></tr>
      <tr><td class="left">        * The sum for this interface of AlignmentErrors, FCSErrors, FrameTo
oLongs,</td><td> </td><td class="right">        * The sum for this interface of AlignmentErrors, FCSErrors, FrameTo
oLongs,</td></tr>
      <tr><td class="left">        * InternalMacReceiveErrors. See ifInErrors in RFC 3635.</td><td> </td><td class="right">        * InternalMacReceiveErrors. See ifInErrors in RFC 3635.</td></tr>
      <tr><td class="left">        */</td><td> </td><td class="right">        */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;pool.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;pool.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 42</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 42</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_POOL_INVALID</td><td> </td><td class="right"> * @def ODP_POOL_INVALID</td></tr>
      <tr><td class="left"> * Invalid pool</td><td> </td><td class="right"> * Invalid pool</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Maximum queue name length in chars */</td><td> </td><td class="right">/** Maximum queue name length in chars */</td></tr>
      <tr><td class="left">#define ODP_POOL_NAME_LEN  32</td><td> </td><td class="right">#define ODP_POOL_NAME_LEN  32</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Pool capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_pool_capability_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of pools of any type */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_pools;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Buffer pool capabilities  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of buffer pools */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               unsigned max_pools;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum buffer data alignment in bytes */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_align;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum buffer data size in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that size is limited only by the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * available memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_size;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of buffers of any size</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_num;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } buf;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Packet pool capabilities  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of packet pools */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               unsigned max_pools;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum packet data length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * This defines the maximum packet data length that can be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * stored into a packet. Attempts to allocate or extend pack</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ets</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * to sizes larger than this limit will fail.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_len;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of packets of any length</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_num;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Minimum packet level headroom length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The minimum number of headroom bytes that newly created</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * packets have by default. The default apply to both ODP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * packet input and user allocated packets.*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t min_headroom;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Minimum packet level tailroom length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The minimum number of tailroom bytes that newly created</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * packets have by default. The default apply to both ODP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * packet input and user allocated packets.*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t min_tailroom;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of segments per packet */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_segs_per_pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Minimum packet segment data length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The user defined segment length (seg_len in</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * odp_pool_param_t) will be rounded up into this value. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t min_seg_len;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum packet segment data length in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The user defined segment length (seg_len in odp_pool_para</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">m_t)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * must not be larger than this.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_seg_len;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum user area size in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_uarea_size;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Timeout pool capabilities  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of timeout pools */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               unsigned max_pools;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               /** Maximum number of timeout events in a pool</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * The value of zero means that limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                * memory size for the pool. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               uint32_t max_num;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       } tmo;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_pool_capability_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Query pool capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Outputs pool capabilities on success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capa   Pointer to capability structure for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_pool_capability(odp_pool_capability_t *capa);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Pool parameters</td><td> </td><td class="right"> * Pool parameters</td></tr>
      <tr><td class="left"> * Used to communicate pool creation options.</td><td> </td><td class="right"> * Used to communicate pool creation options.</td></tr>
      <tr><td class="left"> * @note A single thread may not be able to allocate all 'num' elements</td><td> </td><td class="right"> * @note A single thread may not be able to allocate all 'num' elements</td></tr>
      <tr><td class="left"> * from the pool at any particular time, as other threads or hardware</td><td> </td><td class="right"> * from the pool at any particular time, as other threads or hardware</td></tr>
      <tr><td class="left"> * blocks are allowed to keep some for caching purposes.</td><td> </td><td class="right"> * blocks are allowed to keep some for caching purposes.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_pool_param_t {</td><td> </td><td class="right">typedef struct odp_pool_param_t {</td></tr>
      <tr><td class="left">       /** Pool type */</td><td> </td><td class="right">       /** Pool type */</td></tr>
      <tr><td class="left">       int type;</td><td> </td><td class="right">       int type;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 68</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 182</em></th></tr>
      <tr><td class="left">                           application will store in each buffer. */</td><td> </td><td class="right">                           application will store in each buffer. */</td></tr>
      <tr><td class="left">                       uint32_t size;</td><td> </td><td class="right">                       uint32_t size;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">                       /** Minimum buffer alignment in bytes. Valid values 
are</td><td> </td><td class="right">                       /** Minimum buffer alignment in bytes. Valid values 
are</td></tr>
      <tr><td class="left">                           powers of two. Use 0 for default alignment.</td><td> </td><td class="right">                           powers of two. Use 0 for default alignment.</td></tr>
      <tr><td class="left">                           Default will always be a multiple of 8. */</td><td> </td><td class="right">                           Default will always be a multiple of 8. */</td></tr>
      <tr><td class="left">                       uint32_t align;</td><td> </td><td class="right">                       uint32_t align;</td></tr>
      <tr><td class="left">               } buf;</td><td> </td><td class="right">               } buf;</td></tr>
      <tr><td class="left">               struct {</td><td> </td><td class="right">               struct {</td></tr>
      <tr><td class="left">                       /** The number of packets that the pool must provide</td><td> </td><td class="right">                       /** The number of packets that the pool must provide</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">                           that are packet length 'len' bytes or smaller. <span class="delete">*</span></td><td> </td><td class="rblock">                           that are packet length 'len' bytes or smaller.</td></tr>
      <tr><td class="lblock"><span class="delete">/</span></td><td> </td><td class="rblock">                           <span class="insert">The maximum value is defined by pool capability</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           pkt.max_num. */</span></td></tr>
      <tr><td class="left">                       uint32_t num;</td><td> </td><td class="right">                       uint32_t num;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">                       /** Minimum packet length that the pool must provide</td><td> </td><td class="right">                       /** Minimum packet length that the pool must provide</td></tr>
      <tr><td class="left">                           'num' packets. The number of packets may be less</td><td> </td><td class="right">                           'num' packets. The number of packets may be less</td></tr>
      <tr><td class="left">                           than 'num' when packets are larger than 'len'.</td><td> </td><td class="right">                           than 'num' when packets are larger than 'len'.</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">                           Use 0 for default. */</td><td> </td><td class="rblock">                           <span class="insert">The maximum value is defined by pool capability</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           pkt.max_len.</span> Use 0 for default. */</td></tr>
      <tr><td class="left">                       uint32_t len;</td><td> </td><td class="right">                       uint32_t len;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">                       /** Minimum number of packet data bytes that are sto
red</td><td> </td><td class="right">                       /** Minimum number of packet data bytes that are sto
red</td></tr>
      <tr><td class="left">                           in the first segment of a packet. The maximum va
lue</td><td> </td><td class="right">                           in the first segment of a packet. The maximum va
lue</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">                           is defined by <span class="delete">ODP_CONFIG_PACKET_SEG_LEN_MAX</span>.</td><td> </td><td class="rblock">                           is defined by <span class="insert">pool capability pkt.max_seg_len</span>.</td></tr>
      <tr><td class="left">                           Use 0 for default. */</td><td> </td><td class="right">                           Use 0 for default. */</td></tr>
      <tr><td class="left">                       uint32_t seg_len;</td><td> </td><td class="right">                       uint32_t seg_len;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">                       /** User area size in bytes. Specify as 0 if no user</td><td> </td><td class="rblock">                       /** User area size in bytes. <span class="insert">The maximum value is</span></td></tr>
      <tr><td class="lblock">                           area is needed. */</td><td> </td><td class="rblock"><span class="insert">                           defined by pool capability pkt.max_uarea_size.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                           Specify as 0 if no user area is needed. */</td></tr>
      <tr><td class="left">                       uint32_t uarea_size;</td><td> </td><td class="right">                       uint32_t uarea_size;</td></tr>
      <tr><td class="left">               } pkt;</td><td> </td><td class="right">               } pkt;</td></tr>
      <tr><td class="left">               struct {</td><td> </td><td class="right">               struct {</td></tr>
      <tr><td class="left">                       /** Number of timeouts in the pool */</td><td> </td><td class="right">                       /** Number of timeouts in the pool */</td></tr>
      <tr><td class="left">                       uint32_t num;</td><td> </td><td class="right">                       uint32_t num;</td></tr>
      <tr><td class="left">               } tmo;</td><td> </td><td class="right">               } tmo;</td></tr>
      <tr><td class="left">       };</td><td> </td><td class="right">       };</td></tr>
      <tr><td class="left">} odp_pool_param_t;</td><td> </td><td class="right">} odp_pool_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Packet pool*/</td><td> </td><td class="right">/** Packet pool*/</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 5 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>6 lines changed or deleted</i></th><th><i> </i></th><th><i>131 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;queue.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;queue.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 71</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 71</em></th></tr>
      <tr><td class="left">         * Scheduled queues are connected to the scheduler. Application mus
t</td><td> </td><td class="right">         * Scheduled queues are connected to the scheduler. Application mus
t</td></tr>
      <tr><td class="left">         * not dequeue events directly from these queues but use the schedu
ler</td><td> </td><td class="right">         * not dequeue events directly from these queues but use the schedu
ler</td></tr>
      <tr><td class="left">         * instead. */</td><td> </td><td class="right">         * instead. */</td></tr>
      <tr><td class="left">       ODP_QUEUE_TYPE_SCHED</td><td> </td><td class="right">       ODP_QUEUE_TYPE_SCHED</td></tr>
      <tr><td class="left">} odp_queue_type_t;</td><td> </td><td class="right">} odp_queue_type_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Queue operation mode</td><td> </td><td class="right"> * Queue operation mode</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum odp_queue_op_mode_t {</td><td> </td><td class="right">typedef enum odp_queue_op_mode_t {</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock">       /** Multi<span class="delete">-</span>thread safe operation</td><td> </td><td class="rblock">       /** Multithread safe operation</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">         * Queue operation (enqueue or dequeue) is multi<span class="delete">-</span>thread safe. Any</td><td> </td><td class="rblock">         * Queue operation (enqueue or dequeue) is multithread safe. Any</td></tr>
      <tr><td class="left">         * number of application threads may perform the operation</td><td> </td><td class="right">         * number of application threads may perform the operation</td></tr>
      <tr><td class="left">         * concurrently. */</td><td> </td><td class="right">         * concurrently. */</td></tr>
      <tr><td class="left">       ODP_QUEUE_OP_MT = 0,</td><td> </td><td class="right">       ODP_QUEUE_OP_MT = 0,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">       /** Not multi<span class="delete">-</span>thread safe operation</td><td> </td><td class="rblock">       /** Not multithread safe operation</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">         * Queue operation (enqueue or dequeue) may not be multi<span class="delete">-thread saf
e</span>.</td><td> </td><td class="rblock">         * Queue operation (enqueue or dequeue) may not be multi<span class="insert">thread safe
</span>.</td></tr>
      <tr><td class="left">         * Application ensures synchronization between threads so that</td><td> </td><td class="right">         * Application ensures synchronization between threads so that</td></tr>
      <tr><td class="left">         * simultaneously only single thread attempts the operation on</td><td> </td><td class="right">         * simultaneously only single thread attempts the operation on</td></tr>
      <tr><td class="left">         * the same queue. */</td><td> </td><td class="right">         * the same queue. */</td></tr>
      <tr><td class="left">       ODP_QUEUE_OP_MT_UNSAFE,</td><td> </td><td class="right">       ODP_QUEUE_OP_MT_UNSAFE,</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Disabled</td><td> </td><td class="right">       /** Disabled</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * Direct enqueue or dequeue operation from application is disabled
.</td><td> </td><td class="right">         * Direct enqueue or dequeue operation from application is disabled
.</td></tr>
      <tr><td class="left">         * An attempt to enqueue/dequeue directly will result undefined</td><td> </td><td class="right">         * An attempt to enqueue/dequeue directly will result undefined</td></tr>
      <tr><td class="left">         * behaviour. Various ODP functions (e.g. packet input, timer,</td><td> </td><td class="right">         * behaviour. Various ODP functions (e.g. packet input, timer,</td></tr>
      <tr><td class="left">         * crypto, scheduler, etc) are able to perform enqueue or</td><td> </td><td class="right">         * crypto, scheduler, etc) are able to perform enqueue or</td></tr>
      <tr><td class="left">         * dequeue operations normally on the queue.</td><td> </td><td class="right">         * dequeue operations normally on the queue.</td></tr>
      <tr><td class="left">         * */</td><td> </td><td class="right">         * */</td></tr>
      <tr><td class="left">       ODP_QUEUE_OP_DISABLED</td><td> </td><td class="right">       ODP_QUEUE_OP_DISABLED</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">} odp_queue_op_mode_t;</td><td> </td><td class="right">} odp_queue_op_mode_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Queue capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_queue_capability_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of event queues */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t max_queues;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of ordered locks per queue */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_ordered_locks;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of scheduling groups */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_sched_groups;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Number of scheduling priorities */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned sched_prios;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_queue_capability_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * ODP Queue parameters</td><td> </td><td class="right"> * ODP Queue parameters</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_queue_param_t {</td><td> </td><td class="right">typedef struct odp_queue_param_t {</td></tr>
      <tr><td class="left">       /** Queue type</td><td> </td><td class="right">       /** Queue type</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * Valid values for other parameters in this structure depend on</td><td> </td><td class="right">         * Valid values for other parameters in this structure depend on</td></tr>
      <tr><td class="left">         * the queue type. */</td><td> </td><td class="right">         * the queue type. */</td></tr>
      <tr><td class="left">       odp_queue_type_t type;</td><td> </td><td class="right">       odp_queue_type_t type;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Enqueue mode</td><td> </td><td class="right">       /** Enqueue mode</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * Default value for both queue types is ODP_QUEUE_OP_MT. Applicati
on</td><td> </td><td class="right">         * Default value for both queue types is ODP_QUEUE_OP_MT. Applicati
on</td></tr>
      <tr><td class="left">         * may enable performance optimizations by defining MT_UNSAFE or</td><td> </td><td class="right">         * may enable performance optimizations by defining MT_UNSAFE or</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock">         * DISABLED modes when applica<span class="delete">p</span>le. */</td><td> </td><td class="rblock">         * DISABLED modes when applica<span class="insert">b</span>le. */</td></tr>
      <tr><td class="left">       odp_queue_op_mode_t enq_mode;</td><td> </td><td class="right">       odp_queue_op_mode_t enq_mode;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Dequeue mode</td><td> </td><td class="right">       /** Dequeue mode</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * For PLAIN queues, the default value is ODP_QUEUE_OP_MT. Applicat
ion</td><td> </td><td class="right">         * For PLAIN queues, the default value is ODP_QUEUE_OP_MT. Applicat
ion</td></tr>
      <tr><td class="left">         * may enable performance optimizations by defining MT_UNSAFE or</td><td> </td><td class="right">         * may enable performance optimizations by defining MT_UNSAFE or</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock">         * DISABLED modes when applica<span class="delete">p</span>le. However, when a plain queue is i
nput</td><td> </td><td class="rblock">         * DISABLED modes when applica<span class="insert">b</span>le. However, when a plain queue is i
nput</td></tr>
      <tr><td class="left">         * to the implementation (e.g. a queue for packet output), the</td><td> </td><td class="right">         * to the implementation (e.g. a queue for packet output), the</td></tr>
      <tr><td class="left">         * parameter is ignored in queue creation and the value is</td><td> </td><td class="right">         * parameter is ignored in queue creation and the value is</td></tr>
      <tr><td class="left">         * ODP_QUEUE_OP_DISABLED.</td><td> </td><td class="right">         * ODP_QUEUE_OP_DISABLED.</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * For SCHED queues, the parameter is ignored in queue creation and</td><td> </td><td class="right">         * For SCHED queues, the parameter is ignored in queue creation and</td></tr>
      <tr><td class="left">         * the value is ODP_QUEUE_OP_DISABLED. */</td><td> </td><td class="right">         * the value is ODP_QUEUE_OP_DISABLED. */</td></tr>
      <tr><td class="left">       odp_queue_op_mode_t deq_mode;</td><td> </td><td class="right">       odp_queue_op_mode_t deq_mode;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Scheduler parameters</td><td> </td><td class="right">       /** Scheduler parameters</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 142</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 160</em></th></tr>
      <tr><td class="left">       odp_schedule_param_t sched;</td><td> </td><td class="right">       odp_schedule_param_t sched;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       /** Queue context pointer</td><td> </td><td class="right">       /** Queue context pointer</td></tr>
      <tr><td class="left">         *</td><td> </td><td class="right">         *</td></tr>
      <tr><td class="left">         * User defined context pointer associated with the queue. The same</td><td> </td><td class="right">         * User defined context pointer associated with the queue. The same</td></tr>
      <tr><td class="left">         * pointer can be accessed with odp_queue_context() and</td><td> </td><td class="right">         * pointer can be accessed with odp_queue_context() and</td></tr>
      <tr><td class="left">         * odp_queue_context_set() calls. The implementation may read the</td><td> </td><td class="right">         * odp_queue_context_set() calls. The implementation may read the</td></tr>
      <tr><td class="left">         * pointer for prefetching the context data. Default value of the</td><td> </td><td class="right">         * pointer for prefetching the context data. Default value of the</td></tr>
      <tr><td class="left">         * pointer is NULL. */</td><td> </td><td class="right">         * pointer is NULL. */</td></tr>
      <tr><td class="left">       void *context;</td><td> </td><td class="right">       void *context;</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">/** Queue context data length</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * User defined context data length in bytes for prefetching.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * The implementation may use this value as a hint for the number o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">f</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">         * context data bytes to prefetch. Default value is zero (no hint).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t context_len;</span></td></tr>
      <tr><td class="left">} odp_queue_param_t;</td><td> </td><td class="right">} odp_queue_param_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Queue create</td><td> </td><td class="right"> * Queue create</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Create a queue according to the queue parameters. Queue type is specifie
d by</td><td> </td><td class="right"> * Create a queue according to the queue parameters. Queue type is specifie
d by</td></tr>
      <tr><td class="left"> * queue parameter 'type'. Use odp_queue_param_init() to initialize paramet
ers</td><td> </td><td class="right"> * queue parameter 'type'. Use odp_queue_param_init() to initialize paramet
ers</td></tr>
      <tr><td class="left"> * into their default values. Default values are also used when 'param' poi
nter</td><td> </td><td class="right"> * into their default values. Default values are also used when 'param' poi
nter</td></tr>
      <tr><td class="left"> * is NULL. The default queue type is ODP_QUEUE_TYPE_PLAIN.</td><td> </td><td class="right"> * is NULL. The default queue type is ODP_QUEUE_TYPE_PLAIN.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 186</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 211</em></th></tr>
      <tr><td class="left"> * Find a queue by name</td><td> </td><td class="right"> * Find a queue by name</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param name    Queue name</td><td> </td><td class="right"> * @param name    Queue name</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Queue handle</td><td> </td><td class="right"> * @return Queue handle</td></tr>
      <tr><td class="left"> * @retval ODP_QUEUE_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_QUEUE_INVALID on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_queue_t odp_queue_lookup(const char *name);</td><td> </td><td class="right">odp_queue_t odp_queue_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Query queue capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Outputs queue capabilities on success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capa   Pointer to capability structure for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_queue_capability(odp_queue_capability_t *capa);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Set queue context</td><td> </td><td class="right"> * Set queue context</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * It is the responsibility of the user to ensure that the queue context</td><td> </td><td class="right"> * It is the responsibility of the user to ensure that the queue context</td></tr>
      <tr><td class="left"> * is stored in a location accessible by all threads that attempt to</td><td> </td><td class="right"> * is stored in a location accessible by all threads that attempt to</td></tr>
      <tr><td class="left"> * access it.</td><td> </td><td class="right"> * access it.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param queue    Queue handle</td><td> </td><td class="right"> * @param queue    Queue handle</td></tr>
      <tr><td class="left"> * @param context  Address to the queue context</td><td> </td><td class="right"> * @param context  Address to the queue context</td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param len      Queue context data length in bytes</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">int odp_queue_context_set(odp_queue_t queue, void *context);</td><td> </td><td class="rblock">int odp_queue_context_set(odp_queue_t queue, void *context<span class="insert">, uint32_t len</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Get queue context</td><td> </td><td class="right"> * Get queue context</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param queue    Queue handle</td><td> </td><td class="right"> * @param queue    Queue handle</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return pointer to the queue context</td><td> </td><td class="right"> * @return pointer to the queue context</td></tr>
      <tr><td class="left"> * @retval NULL on failure</td><td> </td><td class="right"> * @retval NULL on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void *odp_queue_context(odp_queue_t queue);</td><td> </td><td class="right">void *odp_queue_context(odp_queue_t queue);</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 11 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>7 lines changed or deleted</i></th><th><i> </i></th><th><i>47 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;rwlock.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;rwlock.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 28</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 28</em></th></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup odp_locks ODP LOCKS</td><td> </td><td class="right"> * @defgroup odp_locks ODP LOCKS</td></tr>
      <tr><td class="left"> * @details</td><td> </td><td class="right"> * @details</td></tr>
      <tr><td class="left"> * &lt;b&gt; Reader / writer lock (odp_rwlock_t) &lt;/b&gt;</td><td> </td><td class="right"> * &lt;b&gt; Reader / writer lock (odp_rwlock_t) &lt;/b&gt;</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * A reader/writer lock allows multiple simultaneous readers but only one</td><td> </td><td class="right"> * A reader/writer lock allows multiple simultaneous readers but only one</td></tr>
      <tr><td class="left"> * writer at a time. A thread that wants write access will have to wait unt
il</td><td> </td><td class="right"> * writer at a time. A thread that wants write access will have to wait unt
il</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * there are no threads that want read access. This ca<span class="delete">su</span>es a risk for</td><td> </td><td class="rblock"> * there are no threads that want read access. This ca<span class="insert">us</span>es a risk for</td></tr>
      <tr><td class="left"> * starvation. The trylock variants can be used to avoid blocking when</td><td> </td><td class="right"> * starvation. The trylock variants can be used to avoid blocking when</td></tr>
      <tr><td class="left"> * the lock is not immediately available.</td><td> </td><td class="right"> * the lock is not immediately available.</td></tr>
      <tr><td class="left"> * @{</td><td> </td><td class="right"> * @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_rwlock_t</td><td> </td><td class="right"> * @typedef odp_rwlock_t</td></tr>
      <tr><td class="left"> * ODP reader/writer lock</td><td> </td><td class="right"> * ODP reader/writer lock</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>1 lines changed or deleted</i></th><th><i> </i></th><th><i>1 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;schedule.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;schedule.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 129</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 129</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param from    Output parameter for the source queue (where the event wa
s</td><td> </td><td class="right"> * @param from    Output parameter for the source queue (where the event wa
s</td></tr>
      <tr><td class="left"> *                dequeued from). Ignored if NULL.</td><td> </td><td class="right"> *                dequeued from). Ignored if NULL.</td></tr>
      <tr><td class="left"> * @param wait    Minimum time to wait for an event. Waits infinitely, if s
et to</td><td> </td><td class="right"> * @param wait    Minimum time to wait for an event. Waits infinitely, if s
et to</td></tr>
      <tr><td class="left"> *                ODP_SCHED_WAIT. Does not wait, if set to ODP_SCHED_NO_WAI
T.</td><td> </td><td class="right"> *                ODP_SCHED_WAIT. Does not wait, if set to ODP_SCHED_NO_WAI
T.</td></tr>
      <tr><td class="left"> *                Use odp_schedule_wait_time() to convert time to other wai
t</td><td> </td><td class="right"> *                Use odp_schedule_wait_time() to convert time to other wai
t</td></tr>
      <tr><td class="left"> *                values.</td><td> </td><td class="right"> *                values.</td></tr>
      <tr><td class="left"> * @param events  Event array for output</td><td> </td><td class="right"> * @param events  Event array for output</td></tr>
      <tr><td class="left"> * @param num     Maximum number of events to output</td><td> </td><td class="right"> * @param num     Maximum number of events to output</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * @return Number of events outputed (0 ... num)</td><td> </td><td class="rblock"> * @return Number of events output<span class="insert">t</span>ed (0 ... num)</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_schedule_multi(odp_queue_t *from, uint64_t wait, odp_event_t events
[],</td><td> </td><td class="right">int odp_schedule_multi(odp_queue_t *from, uint64_t wait, odp_event_t events
[],</td></tr>
      <tr><td class="left">                      int num);</td><td> </td><td class="right">                      int num);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Pause scheduling</td><td> </td><td class="right"> * Pause scheduling</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Pause global scheduling for this thread. After this call, all schedule c
alls</td><td> </td><td class="right"> * Pause global scheduling for this thread. After this call, all schedule c
alls</td></tr>
      <tr><td class="left"> * will return only locally pre-scheduled events (if any). User can exit th
e</td><td> </td><td class="right"> * will return only locally pre-scheduled events (if any). User can exit th
e</td></tr>
      <tr><td class="left"> * schedule loop only after the schedule function indicates that there's no
 more</td><td> </td><td class="right"> * schedule loop only after the schedule function indicates that there's no
 more</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 261</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 261</em></th></tr>
      <tr><td class="left"> * @return Handle of schedule group for specified name</td><td> </td><td class="right"> * @return Handle of schedule group for specified name</td></tr>
      <tr><td class="left"> * @retval ODP_SCHEDULE_GROUP_INVALID No matching schedule group found</td><td> </td><td class="right"> * @retval ODP_SCHEDULE_GROUP_INVALID No matching schedule group found</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_schedule_group_t odp_schedule_group_lookup(const char *name);</td><td> </td><td class="right">odp_schedule_group_t odp_schedule_group_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Join a schedule group</td><td> </td><td class="right"> * Join a schedule group</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Join a threadmask to an existing schedule group</td><td> </td><td class="right"> * Join a threadmask to an existing schedule group</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * @param group  Schdule group handle</td><td> </td><td class="rblock"> * @param group  Sch<span class="insert">e</span>dule group handle</td></tr>
      <tr><td class="left"> * @param mask   Thread mask</td><td> </td><td class="right"> * @param mask   Thread mask</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0 on success</td><td> </td><td class="right"> * @retval 0 on success</td></tr>
      <tr><td class="left"> * @retval &lt;0 on failure</td><td> </td><td class="right"> * @retval &lt;0 on failure</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_schedule_group_join(odp_schedule_group_t group,</td><td> </td><td class="right">int odp_schedule_group_join(odp_schedule_group_t group,</td></tr>
      <tr><td class="left">                           const odp_thrmask_t *mask);</td><td> </td><td class="right">                           const odp_thrmask_t *mask);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Leave a schedule group</td><td> </td><td class="right"> * Leave a schedule group</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 302</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 302</em></th></tr>
      <tr><td class="left"> * @param      group   Schedule group handle</td><td> </td><td class="right"> * @param      group   Schedule group handle</td></tr>
      <tr><td class="left"> * @param[out] thrmask The current thrmask used for this schedule group</td><td> </td><td class="right"> * @param[out] thrmask The current thrmask used for this schedule group</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @retval 0  On success</td><td> </td><td class="right"> * @retval 0  On success</td></tr>
      <tr><td class="left"> * @retval &lt;0 Invalid group specified</td><td> </td><td class="right"> * @retval &lt;0 Invalid group specified</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_schedule_group_thrmask(odp_schedule_group_t group,</td><td> </td><td class="right">int odp_schedule_group_thrmask(odp_schedule_group_t group,</td></tr>
      <tr><td class="left">                              odp_thrmask_t *thrmask);</td><td> </td><td class="right">                              odp_thrmask_t *thrmask);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Schedule group information</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_schedule_group_info_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       const char    *name;   /**&lt; Schedule group name */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_thrmask_t thrmask; /**&lt; Thread mask of the schedule group */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_schedule_group_info_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Retrieve information about a schedule group</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Fills in schedule group information structure with current values.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The call is not synchronized with calls modifying the schedule group. So</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the application should ensure that it does not simultaneously modify and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * retrieve information about the same group with this call. The call is no</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * intended for fast path use. The info structure is written only on succes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param      group   Schedule group handle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] info    Pointer to schedule group info struct for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval  0 On success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 On failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_schedule_group_info(odp_schedule_group_t group,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                           odp_schedule_group_info_t *info);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Acquire ordered context lock</td><td> </td><td class="right"> * Acquire ordered context lock</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * This call is valid only when holding an ordered synchronization context.</td><td> </td><td class="right"> * This call is valid only when holding an ordered synchronization context.</td></tr>
      <tr><td class="left"> * Ordered locks are used to protect critical sections that are executed</td><td> </td><td class="right"> * Ordered locks are used to protect critical sections that are executed</td></tr>
      <tr><td class="left"> * within an ordered context. Threads enter the critical section in the ord
er</td><td> </td><td class="right"> * within an ordered context. Threads enter the critical section in the ord
er</td></tr>
      <tr><td class="left"> * determined by the context (source queue). Lock ordering is automatically</td><td> </td><td class="right"> * determined by the context (source queue). Lock ordering is automatically</td></tr>
      <tr><td class="left"> * skipped for threads that release the context instead of using the lock.</td><td> </td><td class="right"> * skipped for threads that release the context instead of using the lock.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The number of ordered locks available is set by the lock_count parameter
 of</td><td> </td><td class="right"> * The number of ordered locks available is set by the lock_count parameter
 of</td></tr>
      <tr><td class="left"> * the schedule parameters passed to odp_queue_create(), which must be less</td><td> </td><td class="right"> * the schedule parameters passed to odp_queue_create(), which must be less</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"> * than or equal to <span class="delete">the ODP_CONFIG_MAX_ORDERED_LOCKS_PER_QUEUE configuratio</span></td><td> </td><td class="rblock"> * than or equal to <span class="insert">queue capability 'max_ordered_locks'.</span> If this routine <span class="insert">i</span></td></tr>
      <tr><td class="lblock"><span class="delete">n</span></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * option.</span> If this routine <span class="delete">is</span> called outside of an ordered context or with </td><td> </td><td class="rblock"><span class="insert"> *</span> called outside of an ordered context or with a lock_index that exceeds <span class="insert">t</span></td></tr>
      <tr><td class="lblock">a</td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> lock_index that exceeds <span class="delete">the</span> number of available ordered locks in this</td><td> </td><td class="rblock"><span class="insert"> *</span> number of available ordered locks in this context results are undefined.</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span> context results are undefined. The number of ordered locks associated <span class="delete">wi</span></td><td> </td><td class="rblock"> <span class="insert">*</span> The number of ordered locks associated <span class="insert">with</span> a given ordered queue may be</td></tr>
      <tr><td class="lblock"><span class="delete">th</span></td><td> </td><td class="rblock"> <span class="insert">*</span> queried by the odp_queue_lock_count() API.</td></tr>
      <tr><td class="lblock"><span class="delete"> *</span> a given ordered queue may be queried by the odp_queue_lock_count() API.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Each ordered lock may be used only once per ordered context. If events</td><td> </td><td class="right"> * Each ordered lock may be used only once per ordered context. If events</td></tr>
      <tr><td class="left"> * are to be processed with multiple ordered critical sections, each should</td><td> </td><td class="right"> * are to be processed with multiple ordered critical sections, each should</td></tr>
      <tr><td class="left"> * be protected by its own ordered lock. This promotes maximum parallelism 
by</td><td> </td><td class="right"> * be protected by its own ordered lock. This promotes maximum parallelism 
by</td></tr>
      <tr><td class="left"> * allowing order to maintained on a more granular basis. If an ordered loc
k</td><td> </td><td class="right"> * allowing order to maintained on a more granular basis. If an ordered loc
k</td></tr>
      <tr><td class="left"> * is used multiple times in the same ordered context results are undefined
.</td><td> </td><td class="right"> * is used multiple times in the same ordered context results are undefined
.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param lock_index Index of the ordered lock in the current context to be</td><td> </td><td class="right"> * @param lock_index Index of the ordered lock in the current context to be</td></tr>
      <tr><td class="left"> *                   acquired. Must be in the range 0..odp_queue_lock_count
()</td><td> </td><td class="right"> *                   acquired. Must be in the range 0..odp_queue_lock_count
()</td></tr>
      <tr><td class="left"> *                   - 1</td><td> </td><td class="right"> *                   - 1</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 4 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>10 lines changed or deleted</i></th><th><i> </i></th><th><i>38 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;schedule_types.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;schedule_types.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 48</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 48</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_SCHED_PRIO_LOWEST</td><td> </td><td class="right"> * @def ODP_SCHED_PRIO_LOWEST</td></tr>
      <tr><td class="left"> * Lowest scheduling priority</td><td> </td><td class="right"> * Lowest scheduling priority</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_SCHED_PRIO_DEFAULT</td><td> </td><td class="right"> * @def ODP_SCHED_PRIO_DEFAULT</td></tr>
      <tr><td class="left"> * Default scheduling priority. User does not care about the selected prior
ity</td><td> </td><td class="right"> * Default scheduling priority. User does not care about the selected prior
ity</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * level - throughput, load balacing and synchronization features are more</td><td> </td><td class="rblock"> * level - throughput, load bala<span class="insert">n</span>cing and synchronization features are more</td></tr>
      <tr><td class="left"> * important than priority scheduling.</td><td> </td><td class="right"> * important than priority scheduling.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @typedef odp_schedule_sync_t</td><td> </td><td class="right"> * @typedef odp_schedule_sync_t</td></tr>
      <tr><td class="left"> * Scheduler synchronization method</td><td> </td><td class="right"> * Scheduler synchronization method</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_SCHED_SYNC_PARALLEL</td><td> </td><td class="right"> * @def ODP_SCHED_SYNC_PARALLEL</td></tr>
      <tr><td class="left"> * Parallel scheduled queues</td><td> </td><td class="right"> * Parallel scheduled queues</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * The scheduler performs priority scheduling, load balancing, pre<span class="delete">-fetching
,</span> etc</td><td> </td><td class="rblock"> * The scheduler performs priority scheduling, load balancing, pre<span class="insert">fetching,
</span> etc</td></tr>
      <tr><td class="left"> * functions but does not provide additional event synchronization or order
ing.</td><td> </td><td class="right"> * functions but does not provide additional event synchronization or order
ing.</td></tr>
      <tr><td class="left"> * It's free to schedule events from single parallel queue to multiple thre
ads</td><td> </td><td class="right"> * It's free to schedule events from single parallel queue to multiple thre
ads</td></tr>
      <tr><td class="left"> * for concurrent processing. Application is responsible for queue context</td><td> </td><td class="right"> * for concurrent processing. Application is responsible for queue context</td></tr>
      <tr><td class="left"> * synchronization and event ordering (SW synchronization).</td><td> </td><td class="right"> * synchronization and event ordering (SW synchronization).</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_SCHED_SYNC_ATOMIC</td><td> </td><td class="right"> * @def ODP_SCHED_SYNC_ATOMIC</td></tr>
      <tr><td class="left"> * Atomic queue synchronization</td><td> </td><td class="right"> * Atomic queue synchronization</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;shared_memory.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;shared_memory.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 64</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 64</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct odp_shm_info_t {</td><td> </td><td class="right">typedef struct odp_shm_info_t {</td></tr>
      <tr><td class="left">       const char *name;      /**&lt; Block name */</td><td> </td><td class="right">       const char *name;      /**&lt; Block name */</td></tr>
      <tr><td class="left">       void       *addr;      /**&lt; Block address */</td><td> </td><td class="right">       void       *addr;      /**&lt; Block address */</td></tr>
      <tr><td class="left">       uint64_t    size;      /**&lt; Block size in bytes */</td><td> </td><td class="right">       uint64_t    size;      /**&lt; Block size in bytes */</td></tr>
      <tr><td class="left">       uint64_t    page_size; /**&lt; Memory page size */</td><td> </td><td class="right">       uint64_t    page_size; /**&lt; Memory page size */</td></tr>
      <tr><td class="left">       uint32_t    flags;     /**&lt; ODP_SHM_* flags */</td><td> </td><td class="right">       uint32_t    flags;     /**&lt; ODP_SHM_* flags */</td></tr>
      <tr><td class="left">} odp_shm_info_t;</td><td> </td><td class="right">} odp_shm_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Shared memory capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct odp_shm_capability_t {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum number of shared memory blocks</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * This number of separate shared memory blocks can be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * reserved concurrently. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       unsigned max_blocks;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum memory block size in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * The value of zero means that size is limited only by the availabl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * memory size. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint64_t max_size;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Maximum memory block alignment in bytes</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * The value of zero means that alignment is limited only by the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * available memory size. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint64_t max_align;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_shm_capability_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Query shared memory capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Outputs shared memory capabilities on success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capa   Pointer to capability structure for output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval 0 on success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @retval &lt;0 on failure</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_shm_capability(odp_shm_capability_t *capa);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Reserve a contiguous block of shared memory</td><td> </td><td class="right"> * Reserve a contiguous block of shared memory</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] name   Name of the block (maximum ODP_SHM_NAME_LEN - 1 chars)</td><td> </td><td class="right"> * @param[in] name   Name of the block (maximum ODP_SHM_NAME_LEN - 1 chars)</td></tr>
      <tr><td class="left"> * @param[in] size   Block size in bytes</td><td> </td><td class="right"> * @param[in] size   Block size in bytes</td></tr>
      <tr><td class="left"> * @param[in] align  Block alignment in bytes</td><td> </td><td class="right"> * @param[in] align  Block alignment in bytes</td></tr>
      <tr><td class="left"> * @param[in] flags  Shared memory parameter flags (ODP_SHM_*).</td><td> </td><td class="right"> * @param[in] flags  Shared memory parameter flags (ODP_SHM_*).</td></tr>
      <tr><td class="left"> *                   Default value is 0.</td><td> </td><td class="right"> *                   Default value is 0.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return Handle of the reserved block</td><td> </td><td class="right"> * @return Handle of the reserved block</td></tr>
      <tr><td class="left"> * @retval ODP_SHM_INVALID on failure</td><td> </td><td class="right"> * @retval ODP_SHM_INVALID on failure</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>37 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;traffic_mngr.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;traffic_mngr.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 101</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 101</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_TM_MAX_TM_NODE_FANIN</td><td> </td><td class="right"> * @def ODP_TM_MAX_TM_NODE_FANIN</td></tr>
      <tr><td class="left"> * The largest number of fan-in "inputs" that can be simultaneously connect
ed</td><td> </td><td class="right"> * The largest number of fan-in "inputs" that can be simultaneously connect
ed</td></tr>
      <tr><td class="left"> * to a single tm_node.</td><td> </td><td class="right"> * to a single tm_node.</td></tr>
      <tr><td class="left"> * @todo Does this need to be as large as ODP_TM_MAX_TM_QUEUES?</td><td> </td><td class="right"> * @todo Does this need to be as large as ODP_TM_MAX_TM_QUEUES?</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_TM_MIN_SHAPER_BW</td><td> </td><td class="right"> * @def ODP_TM_MIN_SHAPER_BW</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * The largest amoun<span class="delete">d</span> of bandwidth that any shaper's peak or commit rate ca
n</td><td> </td><td class="rblock"> * The largest amoun<span class="insert">t</span> of bandwidth that any shaper's peak or commit rate ca
n</td></tr>
      <tr><td class="left"> * be set to. It is in units of 1000 bytes/second.</td><td> </td><td class="right"> * be set to. It is in units of 1000 bytes/second.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_TM_MAX_SHAPER_BW</td><td> </td><td class="right"> * @def ODP_TM_MAX_SHAPER_BW</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * The largest amoun<span class="delete">d</span> of bandwidth that any shaper's peak or commit rate ca
n</td><td> </td><td class="rblock"> * The largest amoun<span class="insert">t</span> of bandwidth that any shaper's peak or commit rate ca
n</td></tr>
      <tr><td class="left"> * be set to. It is in units of 1000 bytes/second.</td><td> </td><td class="right"> * be set to. It is in units of 1000 bytes/second.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_NUM_SHAPER_COLORS</td><td> </td><td class="right"> * @def ODP_NUM_SHAPER_COLORS</td></tr>
      <tr><td class="left"> * The number of enumeration values defined in the odp_tm_shaper_color_t ty
pe.</td><td> </td><td class="right"> * The number of enumeration values defined in the odp_tm_shaper_color_t ty
pe.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_TM_INVALID_PRIORITY</td><td> </td><td class="right"> * @def ODP_TM_INVALID_PRIORITY</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 193</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 193</em></th></tr>
      <tr><td class="left"> * Constant that can be used with any ODP TM handle type and indicates that</td><td> </td><td class="right"> * Constant that can be used with any ODP TM handle type and indicates that</td></tr>
      <tr><td class="left"> * this value does NOT represent a valid TM object.</td><td> </td><td class="right"> * this value does NOT represent a valid TM object.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @def ODP_TM_ROOT</td><td> </td><td class="right"> * @def ODP_TM_ROOT</td></tr>
      <tr><td class="left"> * Constant that is used to refer to the egress/root node of the TM subsyst
em's</td><td> </td><td class="right"> * Constant that is used to refer to the egress/root node of the TM subsyst
em's</td></tr>
      <tr><td class="left"> * tree/hierarchy of nodes.</td><td> </td><td class="right"> * tree/hierarchy of nodes.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">/** The <span class="delete">odp_tm_capability_t type</span> is used to describe the <span class="delete">feature set and li</span></td><td> </td><td class="rblock">/** <span class="insert">Per Level Capabilities</span></td></tr>
      <tr><td class="lblock"><span class="delete">mits</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">of a TM system.</span>  It is <span class="delete">passed to the odp_tm_create() function indirectly</span></td><td> </td><td class="rblock"><span class="insert"> *</span> The <span class="insert">odp_tm_level_capabilities_t record</span> is used to describe the <span class="insert">capabilit</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">by being</span> part of the <span class="delete">odp_tm_params_t</span> record.</td><td> </td><td class="rblock"><span class="insert">ies</span></td></tr>
      <tr><td class="lblock"> */</td><td> </td><td class="rblock"> * <span class="insert">that might vary based upon the tm_node level.</span>  It is <span class="insert">always used as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * part of the <span class="insert">odp_tm_capabilities</span> record. */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">max_tm_queues</span> specifies the maximum number of <span class="delete">tm_queues that can</span></td><td> </td><td class="rblock">       /** <span class="insert">max_num_tm_nodes</span> specifies the maximum number of <span class="insert">tm_nodes allowe</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">be in existence for</span> this <span class="delete">TM System.</span></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">        * <span class="insert">at</span> this <span class="insert">level.</span> */</td></tr>
      <tr><td class="lblock">       uint32_t <span class="delete">max_tm_queues;</span></td><td> </td><td class="rblock">       uint32_t <span class="insert">max_num_tm_nodes;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock">       /** max_fanin_per_level specifies the maximum number of fan_in <span class="delete">link</span></td><td> </td><td class="rblock">       /** max_fanin_per_level specifies the maximum number of fan_in <span class="insert">links</span></td></tr>
      <tr><td class="lblock">       * to any given scheduler (whether weighted or using fair queueing <span class="delete">or</span></td><td> </td><td class="rblock">        * to any given scheduler (whether weighted or using fair queueing <span class="insert">o</span></td></tr>
      <tr><td class="lblock">       * round robin) belonging to tm_nodes at <span class="delete">the given</span> level.</td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">        * round robin) belonging to tm_nodes at <span class="insert">this</span> level. */</td></tr>
      <tr><td class="lblock">       uint32_t <span class="delete">max_fanin_per_level[ODP_TM_MAX_LEVELS];</span></td><td> </td><td class="rblock">       uint32_t <span class="insert">max_fanin_per_node;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock">       /** max_priority specifies the maximum number of strict priority</td><td> </td><td class="rblock">       /** max_priority specifies the maximum number of strict priority</td></tr>
      <tr><td class="lblock">       * levels used by any <span class="delete">tm_queue or tm_node.  Note that any given</span></td><td> </td><td class="rblock">        * levels used by any tm_node <span class="insert">at this level.</span>  Note that <span class="insert">lower numeri</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * tm_queue or</span> tm_node <span class="delete">can use a subset of these levels.  max_priorit</span></td><td> </td><td class="rblock"><span class="insert">c</span></td></tr>
      <tr><td class="lblock"><span class="delete">y</span></td><td> </td><td class="rblock">        * values represent higher (more important or time critical)</td></tr>
      <tr><td class="lblock"><span class="delete">       * must be in the range 0..ODP_TM_MAX_PRIORITIES - 1.</span>  Note that <span class="delete">lowe</span></td><td> </td><td class="rblock">        * priorities. */</td></tr>
      <tr><td class="lblock"><span class="delete">r</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       * <span class="delete">numeric</span> values represent higher (more important or time critical)</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       * priorities.</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint8_t max_priority;</td><td> </td><td class="right">       uint8_t max_priority;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">max_levels specifies that maximum number of levels of hierarchic</span></td><td> </td><td class="rblock">       /** <span class="insert">min_weight only has significance when</span> the <span class="insert">weights_supported fiel</span></td></tr>
      <tr><td class="lblock"><span class="delete">al</span></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * scheduling allowed by this TM System.  This is a count of</span> the</td><td> </td><td class="rblock">        * <span class="insert">below is true,</span> in <span class="insert">which case it specifies</span> the <span class="insert">smallest value</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">tm_node stages and does not include tm_queues or tm_egress objects</span></td><td> </td><td class="rblock">        * <span class="insert">of the weights allowed</span> at <span class="insert">this level.</span> */</td></tr>
      <tr><td class="lblock"><span class="delete">.</span></td><td> </td><td class="rblock">       uint8_t <span class="insert">min_weight;</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * Hence any given tm_node will have associated tm_node_level</span> in the</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       * <span class="delete">range 0 to max_levels - 1, where tm_node's</span> at <span class="delete">level 0 output's onl</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">y</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       * go to egress objects and tm_nodes whose level is max_levels - 1</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       * have their fan_in only from tm_queues.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       uint8_t <span class="delete">max_levels;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">tm_queue_shaper_supported indicates that</span> the <span class="delete">tm_queues support</span></td><td> </td><td class="rblock">       /** <span class="insert">max_weight only has significance when</span> the <span class="insert">weights_supported fiel</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">proper TM shaping.  Note that TM Shaping</span> is <span class="delete">NOT</span> the <span class="delete">same thing as</span></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * Ingress Metering/Policing as specified by RFC 2697 (A Single Rate</span></td><td> </td><td class="rblock">        * <span class="insert">below</span> is <span class="insert">true, in which case it specifies</span> the <span class="insert">largest value</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * Three Color Marker) or RFC 2698 (A Two Rate Three Color Marker).</span></td><td> </td><td class="rblock">        * of <span class="insert">the weights allowed at this level.</span> */</td></tr>
      <tr><td class="lblock">       * <span class="delete">These RFC's can be used for a Diffserv traffic conditioner, or</span></td><td> </td><td class="rblock">       <span class="insert">uint8_t max_weight;</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * other ingress policing.  They make no mention</span> of <span class="delete">and have no</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       * algorithms for delaying packets - which is what TM shapers are</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       * expected to do.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       <span class="delete">odp_bool_t tm_queue_shaper_supported;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock">       /** tm_node_shaper_supported indicates that the tm_nodes <span class="delete">(at least f</span></td><td> </td><td class="rblock">       /** tm_node_shaper_supported indicates that the tm_nodes <span class="insert">at this lev</span></td></tr>
      <tr><td class="lblock"><span class="delete">or</span></td><td> </td><td class="rblock"><span class="insert">el</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">some hierarchical levels)</span> support <span class="delete">proper T &lt; M shaping.</span></td><td> </td><td class="rblock">        * <span class="insert">all</span> support <span class="insert">TM shaping,</span> */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_bool_t tm_node_shaper_supported;</td><td> </td><td class="right">       odp_bool_t tm_node_shaper_supported;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0010" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">red_supported</span> indicates that the <span class="delete">tm_queues</span> support some form of</td><td> </td><td class="rblock">       /** <span class="insert">tm_node_wred_supported</span> indicates that the <span class="insert">tm_nodes at this level</span></td></tr>
      <tr><td class="lblock">       <span class="delete">*</span> Random Early <span class="delete">Discard.</span></td><td> </td><td class="rblock"><span class="insert">        *</span> support some form of Random Early <span class="insert">Detection.</span> */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">       odp_bool_t <span class="insert">tm_node_wred_supported;</span></td></tr>
      <tr><td class="lblock">       odp_bool_t <span class="delete">red_supported;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0011" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">hierarchical_red_supported</span> indicates that <span class="delete">this TM system support</span></td><td> </td><td class="rblock">       /** <span class="insert">tm_node_dual_slope_supported</span> indicates that the tm_nodes <span class="insert">at this</span></td></tr>
      <tr><td class="lblock"><span class="delete">s</span></td><td> </td><td class="rblock">        * <span class="insert">level support</span> the <span class="insert">dual slope WRED capability.  This field is</span></td></tr>
      <tr><td class="lblock"><span class="delete">       * some form of RED where</span> the <span class="delete">queue fullness of</span> tm_nodes <span class="delete">contributes</span></td><td> </td><td class="rblock"><span class="insert">        * ignored if tm_node_wred_supported above is false.</span> */</td></tr>
      <tr><td class="lblock">       * <span class="delete">to</span> the <span class="delete">overall RED DROP/NO-DROP decision.</span></td><td> </td><td class="rblock">       odp_bool_t <span class="insert">tm_node_dual_slope_supported;</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       odp_bool_t <span class="delete">hierarchical_red_supported;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0012" /></td></tr>
      <tr><td class="lblock">       /** weights_supported indicates that the tm_node schedulers <span class="delete">(at leas</span></td><td> </td><td class="rblock">       /** <span class="insert">fair_queuing_supported indicates that the tm_node schedulers at</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"><span class="insert">        * this level can implement WFQ or FQ scheduling disciplines</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">for some hierarchical levels)</span> can have their different weights for</td><td> </td><td class="rblock"><span class="insert">        * (otherwise these schedulers can only implement WRR or RR</span></td></tr>
      <tr><td class="lblock">       <span class="delete">*</span> their <span class="delete">fan-ins.</span></td><td> </td><td class="rblock"><span class="insert">        * algorithms. */</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"><span class="insert">       odp_bool_t fair_queuing_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /**</span> weights_supported indicates that the tm_node schedulers <span class="insert">at this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * <span class="insert">level</span> can have their different weights for their <span class="insert">different fanins</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * When true the min_weight and max_weight fields above specify</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * the legal range of such weights.</span> */</td></tr>
      <tr><td class="left">       odp_bool_t weights_supported;</td><td> </td><td class="right">       odp_bool_t weights_supported;</td></tr>
      <tr><td><a name="diff0013" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_tm_level_capabilities_t;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0014" /></td></tr>
      <tr><td class="lblock">       /** <span class="delete">fair_queuing_supported indicates</span> the the tm_node <span class="delete">schedulers (at</span></td><td> </td><td class="rblock">/** <span class="insert">TM Capabilities Record.</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">least</span> for <span class="delete">some hierarchical levels)</span> can implement WFQ or FQ</td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock">       <span class="delete">*</span> scheduling <span class="delete">disciplines, otherwise these</span> schedulers <span class="delete">can only</span></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_capabilities_t record type is used to describe the feature se</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">implement WRR</span> or <span class="delete">RR algorithms,</span></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"><span class="insert"> * and limits of a TM system. */</span></td></tr>
      <tr><td class="lblock">       odp_bool_t <span class="delete">fair_queuing_supported;</span></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock">} <span class="delete">odp_tm_capability_t;</span></td><td> </td><td class="rblock"><span class="insert">       /** The name is an optional name associated with a capabilities</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * record.  This name, if present, can be used by odp_tm_find to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * return a TM system matching this set of capabilities. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       char *name;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_tm_queues specifies</span> the <span class="insert">maximum number of tm_queues that can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * be in existence for this TM System. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t max_tm_queues;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_levels specifies that maximum number of levels of hierarchic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">al</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * scheduling allowed by this TM System.  This is a count of</span> the</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        <span class="insert">*</span> tm_node <span class="insert">stages and does not include tm_queues or tm_egress object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * <span class="insert">Hence any given tm_node will have associated tm_node_level in the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * range 0 to max_levels - 1, where tm_node's at level 0 output's on</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ly</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * go to egress objects and tm_nodes whose level is max_levels - 1</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * have their fan_in only from tm_queues. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t max_levels;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_queue_shaper_supported indicates that the tm_queues support</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * proper TM shaping.  Note that TM Shaping is NOT the same thing as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Ingress Metering/Policing as specified by RFC 2697 (A Single Rate</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Three Color Marker) or RFC 2698 (A Two Rate Three Color Marker).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * These RFC's can be used</span> for <span class="insert">a Diffserv traffic conditioner, or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * other ingress policing.  They make no mention of and have no</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * algorithms for delaying packets - which is what TM shapers are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * expected to do. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_queue_shaper_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_queue_wred_supported indicates that the tm_queues support som</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * form of Random Early Detection. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_queue_wred_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_queue_dual_slope_supported indicates that the tm_queues suppo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * the dual slope WRED capability.  This field is ignored if</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * tm_queue_wred_supported above is false. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_queue_dual_slope_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** vlan_marking_supported indicates that this TM system supports SO</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ME</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * form of VLAN egress marking using the odp_tm_vlan_marking()</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * function.  This being true does not imply that all colors and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * subfield values and changes are supported.  Unsupported features</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * can be detected by the marking function returning an error code. </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t vlan_marking_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** ecn_marking_supported indicates that this TM system supports</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Explicit Congestion Notification egress marking by using the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * odp_tm_ip_ecn_marking() function.  Note that the ECN is the botto</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * two bits of the IPv4 TOS field or the analogous IPv6 Traffic Clas</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * (TC) field.  Note that the ecn_marking_supported boolean being</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * true does not imply that all colors are supported. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t ecn_marking_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** drop_prec_marking_supported indicates that this TM system suppor</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * SOME form of IPv4/IPv6 egress marking by using the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * odp_tm_drop_prec_marking() function.  Note that the actually fiel</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * modified for IPv4 pkts is called TOS, whereas the field modified</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * for IPv6 pkts is called Traffic Class (TC) - but they are analogo</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">us</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * fields.  Note that the drop_prec_marking_supported boolean being </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">true</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * does not imply that all colors and subfield values and changes ar</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * supported.  Unsupported features can be detected by the marking</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * function returning an error code.*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t drop_prec_marking_supported;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The marking_colors_supported array is used to indicate which col</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ors</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        *</span> can <span class="insert">be used for marking.  A value of FALSE means that this color</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * should not be enabled for either vlan marking, ecn marking or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * drop precedence marking.  A value of TRUE means that this color i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * supported for at least one of (and ideally all of) vlan marking,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * ecn marking or drop precedence marking. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t marking_colors_supported[ODP_NUM_PACKET_COLORS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The per_level array specifies the TM system capabilities that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * can vary based upon the tm_node level. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_level_capabilities_t per_level[ODP_TM_MAX_LEVELS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_tm_capabilities_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Per Level Requirements</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_level_requirements_t record is used to describe the requireme</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * that might vary based upon the tm_node level.  It is always used as</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * part of the odp_tm_requirements record. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_num_tm_nodes specifies the maximum number of tm_nodes requir</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * at this level. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t max_num_tm_nodes;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_fanin_per_level specifies the maximum number of fan_in links</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to any given scheduler (whether weighted or using fair queueing o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * round robin) required of tm_nodes at this level. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t max_fanin_per_node;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_priority specifies the maximum number of strict priority</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * levels that will be used by any tm_node at this level.  Note that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * lower numeric values represent higher (more important or time</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * critical) priorities. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t max_priority;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** min_weight only has significance when the weights_supported fiel</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * below is true, in which case it specifies the smallest value</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * of the weights that will be used at this level. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t min_weight;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_weight only has significance when the weights_supported fiel</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * below is true, in which case it specifies the largest value</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * of the weights that will be used at this level. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t max_weight;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_node_shaper_needed indicates that the tm_nodes at this level</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * are expected to do TM shaping, */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_node_shaper_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_node_wred_needed indicates that the tm_nodes at this level</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * are expected to participate in some form of Random Early</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * Detection. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_node_wred_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_node_dual_slope_needed indicates that the tm_nodes at this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * level are expected to use the dual slope WRED capability.  This</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * field is ignored if tm_node_wred_needed above is false. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_node_dual_slope_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** fair_queuing_needed indicates that the tm_node schedulers at</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * this level are expected to</span> implement WFQ or FQ scheduling</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        <span class="insert">* disciplines. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t fair_queuing_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** weights_needd indicates that the tm_node</span> schedulers <span class="insert">at this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * <span class="insert">level are expected have different weights for their different</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * fanins.  When true the min_weight and max_weight fields above</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * specify the used range of such weights. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t weights_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_tm_level_requirements_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** TM Requirements Record.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_requirements_t record type is used to describe the minimum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * set of features and limits to be actually used by the application. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** max_tm_queues specifies the maximum number of tm_queues that wil</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * be used for this TM System. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t max_tm_queues;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** num_levels specifies that number of levels of hierarchical</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * scheduling that will be used.  This is a count of the tm_node</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * stages and does not include tm_queues</span> or <span class="insert">tm_egress objects. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t num_levels;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_queue_shaper_needed indicates that the tm_queues are expected</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to do TM shaping. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_queue_shaper_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_queue_wred_needed indicates that the tm_queues are expected</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to participate in some form of Random Early Detection. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_queue_wred_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** tm_queue_dual_slope_needed indicates that the tm_queues are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * expected to use the dual slope WRED capability.  This field is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * ignored if tm_queue_wred_needed above is false. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t tm_queue_dual_slope_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** vlan_marking_needed indicates that the ODP application expects</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to use some form of VLAN egress marking using the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * odp_tm_vlan_marking() function.  See also comments for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * vlan_marking_supported.</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       odp_bool_t <span class="insert">vlan_marking_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** ecn_marking_needed indicates that the ODP application expects</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to use some form of IPv4 TOS or IPv6 TC field egress marking by</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * using the odp_tm_ecn_marking() function.  See also comments for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * ecn_marking_supported. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t ecn_marking_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** drop_prec_marking_needed indicates that the ODP application expe</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to use some form of IPv4 TOS or IPv6 TC field egress marking by</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * using the odp_tm_drop_prec_marking() function.  See also comments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * drop_prec_marking_supported. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t drop_prec_marking_needed;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The marking_colors_needed array is used to indicate which colors</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * are expected to be used for marking.  A value of FALSE means that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * the application will not enable this color for vlan marking,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * ecn marking nor drop precedence marking.  A value of TRUE means t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * the application expects to use this color in conjunction with one</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * more of the marking API's. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t marking_colors_needed[ODP_NUM_PACKET_COLORS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The per_level array specifies the TM system requirements that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * can vary based upon the tm_node level. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_level_requirements_t per_level[ODP_TM_MAX_LEVELS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">} <span class="insert">odp_tm_requirements_t;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_egress_fcn_t type defines the parameter profile of the egres
s</td><td> </td><td class="right">/** The odp_tm_egress_fcn_t type defines the parameter profile of the egres
s</td></tr>
      <tr><td class="left"> * function callback.  Using an egress function callback is just one of sev
eral</td><td> </td><td class="right"> * function callback.  Using an egress function callback is just one of sev
eral</td></tr>
      <tr><td class="left"> * ways of getting packets out from an egress spigot.</td><td> </td><td class="right"> * ways of getting packets out from an egress spigot.</td></tr>
      <tr><td><a name="diff0015" /></td></tr>
      <tr><td class="lblock"><span class="delete"> *</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef void (*odp_tm_egress_fcn_t) (odp_packet_t odp_pkt);</td><td> </td><td class="right">typedef void (*odp_tm_egress_fcn_t) (odp_packet_t odp_pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The tm_egress_kind_e enumeration type is used to indicate the kind of</td><td> </td><td class="right">/** The tm_egress_kind_e enumeration type is used to indicate the kind of</td></tr>
      <tr><td class="left"> * egress object ("spigot") associated with this TM system.  Most of these</td><td> </td><td class="right"> * egress object ("spigot") associated with this TM system.  Most of these</td></tr>
      <tr><td class="left"> * kinds are optional - with ODP_TM_EGRESS_PKT_IO being the only mandatory</td><td> </td><td class="right"> * kinds are optional - with ODP_TM_EGRESS_PKT_IO being the only mandatory</td></tr>
      <tr><td class="left"> * kind.  The TM_EGRESS_FN - if implemented - is useful for testing the TM</td><td> </td><td class="right"> * kind.  The TM_EGRESS_FN - if implemented - is useful for testing the TM</td></tr>
      <tr><td class="left"> * subsystem, and users are warned that its performance might be limited.</td><td> </td><td class="right"> * subsystem, and users are warned that its performance might be limited.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef enum {</td><td> </td><td class="right">typedef enum {</td></tr>
      <tr><td class="left">       ODP_TM_EGRESS_PKT_IO,</td><td> </td><td class="right">       ODP_TM_EGRESS_PKT_IO,</td></tr>
      <tr><td class="left">       ODP_TM_EGRESS_FN,</td><td> </td><td class="right">       ODP_TM_EGRESS_FN,</td></tr>
      <tr><td class="left">} odp_tm_egress_kind_t;</td><td> </td><td class="right">} odp_tm_egress_kind_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_egress_t type is used to describe that type of "egress spigo
t"</td><td> </td><td class="right">/** The odp_tm_egress_t type is used to describe that type of "egress spigo
t"</td></tr>
      <tr><td><a name="diff0016" /></td></tr>
      <tr><td class="lblock"> * associated with this TM system.  <span class="delete">It is passed to the odp_tm_create()</span></td><td> </td><td class="rblock"> * associated with this TM system.</td></tr>
      <tr><td class="lblock"><span class="delete"> * function indirectly by being part of the odp_tm_params_t record.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td class="left">       odp_tm_egress_kind_t egress_kind; /**&lt; Union discriminator */</td><td> </td><td class="right">       odp_tm_egress_kind_t egress_kind; /**&lt; Union discriminator */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       union {</td><td> </td><td class="right">       union {</td></tr>
      <tr><td class="left">               odp_pktout_queue_t pktout;</td><td> </td><td class="right">               odp_pktout_queue_t pktout;</td></tr>
      <tr><td class="left">               odp_tm_egress_fcn_t egress_fcn;</td><td> </td><td class="right">               odp_tm_egress_fcn_t egress_fcn;</td></tr>
      <tr><td class="left">       };</td><td> </td><td class="right">       };</td></tr>
      <tr><td class="left">} odp_tm_egress_t;</td><td> </td><td class="right">} odp_tm_egress_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0017" /></td></tr>
      <tr><td class="lblock">/** <span class="delete">The odp_tm_params_t</span> record <span class="delete">type</span> is used <span class="delete">to hold extra parameters when</span></td><td> </td><td class="rblock">/** <span class="insert">Initialize Requirements record.</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * calling the odp_tm_create() function.</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">Since it</span> is <span class="delete">expected that implementations might augment</span> this record <span class="delete">type</span></td><td> </td><td class="rblock"><span class="insert"> * odp_tm_requirements_init() must be called to initialize any</span></td></tr>
      <tr><td class="lblock"> * <span class="delete">with platform specific additional fields - it</span> is <span class="delete">required that</span></td><td> </td><td class="rblock"><span class="insert"> * odp_tm_requirements_t</span> record <span class="insert">before it</span> is <span class="insert">first</span> used <span class="insert">or assigned to.</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * odp_tm_params_init()</span> be <span class="delete">called on variables of this type before any of t</span></td><td> </td><td class="rblock"> * <span class="insert">This</span> is <span class="insert">done to allow for vendor specific additions to</span> this <span class="insert">record.</span></td></tr>
      <tr><td class="lblock"><span class="delete">he</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * fields are filled in.</span></td><td> </td><td class="rblock"><span class="insert"> * @param[in] requirements  A pointer to an odp_tm_requirements_t</span> record <span class="insert">wh</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ich</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                          is <span class="insert">to</span> be <span class="insert">initialized.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0018" /></td></tr>
      <tr><td class="lblock"><span class="delete">typedef struct {</span></td><td> </td><td class="rblock"><span class="insert">void odp_tm_requirements_init(odp_tm_requirements_t *requirements);</span></td></tr>
      <tr><td class="lblock"><span class="delete">       odp_tm_capability_t capability; /**&lt; capability record */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       odp_tm_egress_t egress; /**&lt; describes the egress "spigot" */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">} odp_tm_params_t;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0019" /></td></tr>
      <tr><td class="lblock">/** <span class="delete">odp_tm_capability_init() must be called to initialize any</span></td><td> </td><td class="rblock">/** <span class="insert">Initialize Egress record.</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * odp_tm_capability_t record before it is first used or assigned to.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0020" /></td></tr>
      <tr><td class="lblock"> * @param[in] <span class="delete">capability</span>  A pointer to an <span class="delete">odp_tm_capability_t</span> record which</td><td> </td><td class="rblock"> * <span class="insert">odp_tm_egress_init() must be called to initialize any odp_tm_egress_t</span></td></tr>
      <tr><td class="lblock"> *                        is to be initialized.</td><td> </td><td class="rblock"><span class="insert"> * record before it is first used or assigned to.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This is done to allow for vendor specific additions to this record.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @param[in] <span class="insert">egress</span>  A pointer to an <span class="insert">odp_tm_egress_t</span> record which</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                    is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0021" /></td></tr>
      <tr><td class="lblock">void odp_tm_<span class="delete">capability_init(odp_tm_capability_t *capability</span>);</td><td> </td><td class="rblock">void odp_tm_<span class="insert">egress_init(odp_tm_egress_t *egress</span>);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0022" /></td></tr>
      <tr><td class="lblock">/** <span class="delete">odp_tm_params_init() must be called to initialize any</span></td><td> </td><td class="rblock">/** <span class="insert">Query All TM Capabilities</span></td></tr>
      <tr><td class="lblock"><span class="delete"> * odp_tm_params_t record before it is first used or assigned to.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0023" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@param[in] params  A pointer</span> to an <span class="delete">odp_tm_params_t record which</span></td><td> </td><td class="rblock"> * <span class="insert">The odp_tm_capabilities() function can be used</span> to <span class="insert">obtain the complete se</span></td></tr>
      <tr><td class="lblock"> *                    is to be <span class="delete">initialized.</span></td><td> </td><td class="rblock"><span class="insert">t of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * TM limits supported by this implementation.  The reason that this return</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * a SET of capabilities and not just one, is because it is expected that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * many HW based implementations may have one set of limits for the HW and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * also support a SW TM implementation with a (presumably larger) different</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * set of limits.  There are also cases where there could be more than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * SW implementation (one supporting say tens of thousands of tm_queues and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * a variant supporting tens of millions of tm_queues).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The caller passes in</span> an <span class="insert">array of odp_tm_capabilities_t records and the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * number of such records.  Then the first N of these records will be fille</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * in by the implementation and the number N will be returned.  In the even</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * <span class="insert">that N</span> is <span class="insert">larger than the capabilities_size, N will still be returned,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * but only capabilities_size records will be filled in.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] capabilities      An array of odp_tm_capabilities_t records</span> </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">to</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*                               be filled in.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in]  capabilities_size The number of odp_tm_capabilities_t record</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                               in the capabilities array.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                       Returns &lt; 0 upon failure.  Returns N &gt; 0,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                               where N is the maximum number of different</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                               odp_tm_capabilities_t records that the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                               implementations supports. *NOTE* that this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                               number can</span> be <span class="insert">&gt; capabilities_size!</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0024" /></td></tr>
      <tr><td class="lblock"><span class="delete">void odp_tm_params_init(odp_tm_params_t *params);</span></td><td> </td><td class="rblock"><span class="insert">int odp_tm_capabilities(odp_tm_capabilities_t capabilities[],</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       uint32_t              capabilities_size);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Create/instantiate a TM Packet Scheduling system.</td><td> </td><td class="right">/** Create/instantiate a TM Packet Scheduling system.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0025" /></td></tr>
      <tr><td class="lblock"> * @param[in] name    The name to be assigned to this TM system.  <span class="delete">Cannot be</span></td><td> </td><td class="rblock"> * @param[in] name          The name to be assigned to this TM system.  <span class="insert">Can</span></td></tr>
      <tr><td class="lblock"> *                    NULL, and also must be unique amongst all <span class="delete">other TM sy</span></td><td> </td><td class="rblock"><span class="insert">not</span></td></tr>
      <tr><td class="lblock"><span class="delete">stem</span></td><td> </td><td class="rblock"> *                          <span class="insert">be</span> NULL, and also must be unique amongst all <span class="insert">ot</span></td></tr>
      <tr><td class="lblock"> *                    names.</td><td> </td><td class="rblock"><span class="insert">her</span></td></tr>
      <tr><td class="lblock"> * @param[in] <span class="delete">params</span>  The <span class="delete">params to be used when creating</span> this TM system.</td><td> </td><td class="rblock"> *                          <span class="insert">TM system</span> names.</td></tr>
      <tr><td class="lblock"> * @return            Returns ODP_TM_INVALID upon failure, otherwise the <span class="delete">ne</span></td><td> </td><td class="rblock"> * @param[in] <span class="insert">requirements</span>  The <span class="insert">minimum required feature set and limits nee</span></td></tr>
      <tr><td class="lblock"><span class="delete">wly</span></td><td> </td><td class="rblock"><span class="insert">ded</span></td></tr>
      <tr><td class="lblock"> *                    created TM system's odp_tm_t handle is returned.</td><td> </td><td class="rblock"><span class="insert"> *                          by the ODP application.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] egress        Describes the single egress "spigot" of</span> this</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span>                          TM system.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @return                  Returns ODP_TM_INVALID upon failure, otherwise </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">the</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                          <span class="insert">newly</span> created TM system's odp_tm_t handle is</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span>                          returned.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0026" /></td></tr>
      <tr><td class="lblock">odp_tm_t odp_tm_create(const char *name, <span class="delete">odp_tm_params_t *params);</span></td><td> </td><td class="rblock">odp_tm_t odp_tm_create(const char            *name,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                      <span class="insert">odp_tm_requirements_t *requirements,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                      odp_tm_egress_t       *egress);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0027" /></td></tr>
      <tr><td class="lblock">/** Find a pre-existing TM <span class="delete">Packet Scheduling</span> system.  <span class="delete">This</span> function can be</td><td> </td><td class="rblock">/** Find a pre-existing TM system.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The  odp_tm_find()</span> function can be</td></tr>
      <tr><td class="left"> * used either to find a TM system created previously with odp_tm_create OR</td><td> </td><td class="right"> * used either to find a TM system created previously with odp_tm_create OR</td></tr>
      <tr><td class="left"> * get the odp_tm_t of a built-in TM system - usually based on HW. In this</td><td> </td><td class="right"> * get the odp_tm_t of a built-in TM system - usually based on HW. In this</td></tr>
      <tr><td class="left"> * later case the format of the name used to refer to a specific built-in</td><td> </td><td class="right"> * later case the format of the name used to refer to a specific built-in</td></tr>
      <tr><td class="left"> * hardware TM system may be platform dependent, but in any case a name of</td><td> </td><td class="right"> * hardware TM system may be platform dependent, but in any case a name of</td></tr>
      <tr><td class="left"> * "HW_TM_%u" where the number starts at 1, can be used to find a built-in</td><td> </td><td class="right"> * "HW_TM_%u" where the number starts at 1, can be used to find a built-in</td></tr>
      <tr><td><a name="diff0028" /></td></tr>
      <tr><td class="lblock"> * system independently of the best <span class="delete">capability match.  If name is NULL th</span>en</td><td> </td><td class="rblock"> * system independently of the best <span class="insert">requirements match.  If name is NULL th
</span>en</td></tr>
      <tr><td class="left"> * the existing (built-in or created by odp_tm_create) TM system that best</td><td> </td><td class="right"> * the existing (built-in or created by odp_tm_create) TM system that best</td></tr>
      <tr><td><a name="diff0029" /></td></tr>
      <tr><td class="lblock"> * matches <span class="delete">capability</span> is returned.</td><td> </td><td class="rblock"> * matches <span class="insert">the requirements</span> is returned.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0030" /></td></tr>
      <tr><td class="lblock"> * @param[in] name        If NULL then only uses the <span class="delete">capability parameter t</span></td><td> </td><td class="rblock"> * @param[in] name          If NULL then only uses the <span class="insert">requirements paramet</span></td></tr>
      <tr><td class="lblock"><span class="delete">o</span></td><td> </td><td class="rblock"><span class="insert">er to</span></td></tr>
      <tr><td class="lblock"> *                        find a closest match, otherwise if the name is</td><td> </td><td class="rblock"> *                          find a closest match, otherwise if the name is</td></tr>
      <tr><td class="lblock"> *                        matched by an existing TM system it is <span class="delete">returned.</span></td><td> </td><td class="rblock"> *                          matched by an existing TM system it is <span class="insert">returned</span></td></tr>
      <tr><td class="lblock"> * @param[in] <span class="delete">capability</span>  Used when the name is NULL (in which</td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                        case the closest match is returned) or when the</td><td> </td><td class="rblock"> * @param[in] <span class="insert">requirements</span>  Used when the name is NULL (in which case the</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                        name is not-NULL, but doesn't match</td><td> </td><td class="rblock"> <span class="insert">*</span>                          closest match is returned) or when the name is</td></tr>
      <tr><td class="lblock"> <span class="delete">*</span>                        any existing TM <span class="delete">system</span> in which case the</td><td> </td><td class="rblock"> <span class="insert">*</span>                          not-NULL, but doesn't match any existing TM <span class="insert">sys</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*                        capability</span> is used to find the <span class="delete">FIRST</span></td><td> </td><td class="rblock"><span class="insert">tem</span></td></tr>
      <tr><td class="lblock"> *                        TM system matching exactly these limits.</td><td> </td><td class="rblock"><span class="insert"> *</span>                          in which case the <span class="insert">requirements</span> is used to find </td></tr>
      <tr><td class="lblock"> * @return                If an existing TM system (built-in or <span class="delete">previously</span></td><td> </td><td class="rblock">the</td></tr>
      <tr><td class="lblock"> *                        created via odp_tm_create) is found, its</td><td> </td><td class="rblock"> *                          <span class="insert">FIRST</span> TM system matching exactly these limits.</td></tr>
      <tr><td class="lblock"> *                        odp_tm_t value is returned, otherwise</td><td> </td><td class="rblock"> * <span class="insert">@param[in] egress        If a TM system is found, then this specifies th</span></td></tr>
      <tr><td class="lblock"> *                        ODP_TM_INVALID is returned.</td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          egress "spigot" to be associated with this TM</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          system.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @return                  If an existing TM system (built-in or <span class="insert">previousl</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                          created via odp_tm_create) is found, its</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                          odp_tm_t value is returned, otherwise</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                          ODP_TM_INVALID is returned.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0031" /></td></tr>
      <tr><td class="lblock">odp_tm_t odp_tm_find(const char *name, <span class="delete">odp_tm_capability_t *capability);</span></td><td> </td><td class="rblock">odp_tm_t odp_tm_find(const char            *name,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                    <span class="insert">odp_tm_requirements_t *requirements,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                    odp_tm_egress_t       *egress);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0032" /></td></tr>
      <tr><td class="lblock">/** <span class="delete">odp_tm_capability() can be used to query the actual limits of a given T</span></td><td> </td><td class="rblock">/** <span class="insert">Query Specific</span> TM <span class="insert">Capabilities</span></td></tr>
      <tr><td class="lblock"><span class="delete">M</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * system.  This function can be used for both built-in</span> TM <span class="delete">systems AND TM</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * system's created via odp_tm_create().</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0033" /></td></tr>
      <tr><td class="lblock"> * @param[in]  odp_tm      The odp_tm_t value of the TM system to be</td><td> </td><td class="rblock"> * <span class="insert">The odp_tm_capability() function can be used to obtain the actual limits</span></td></tr>
      <tr><td class="lblock"> *                         queried.</td><td> </td><td class="rblock"><span class="insert"> * of the given TM system - that was either previous "found" or "created".</span></td></tr>
      <tr><td class="lblock"> * @param[out] <span class="delete">capability</span>  A pointer to <span class="delete">a odp_tm_capability_t</span> record</td><td> </td><td class="rblock"><span class="insert"> * Note that it is IMPORTANT to understand that the capabilities filled in</span></td></tr>
      <tr><td class="lblock"> *                         where the actual limits used by the TM system <span class="delete">ar</span></td><td> </td><td class="rblock"><span class="insert"> * here probably will NOT match any of the "complete set" of capabilities a</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"> *                         copied into.  Note that these limits do NOT</td><td> </td><td class="rblock"><span class="insert"> * returned by odp_tm_capabilities.  This is because the capabilities here</span></td></tr>
      <tr><td class="lblock"> *                         have to match the capability passed in if</td><td> </td><td class="rblock"><span class="insert"> * reflect the given requirements passed in.  Hence these capabilities MAY</span></td></tr>
      <tr><td class="lblock"> *                         a TM system was created by odp_tm_create,</td><td> </td><td class="rblock"><span class="insert"> * (but are not always required to) contain reduced limits and features</span></td></tr>
      <tr><td class="lblock"> *                         but of course these limits in some cases could</td><td> </td><td class="rblock"><span class="insert"> * based upon the actual requirements as determined by the ODP application.</span></td></tr>
      <tr><td class="lblock"> *                         be larger.</td><td> </td><td class="rblock"><span class="insert"> * In addition, ODP TM implementations should fail API requests that "excee</span></td></tr>
      <tr><td class="lblock"> * @return                 Returns 0 upon success, &lt; 0 upon failure <span class="delete">(which</span></td><td> </td><td class="rblock"><span class="insert">d"</span></td></tr>
      <tr><td class="lblock"> *                         indicates that the odp_tm value did not</td><td> </td><td class="rblock"><span class="insert"> * the limits or features contracted for in the requirements.</span></td></tr>
      <tr><td class="lblock"> <span class="delete">*                         exist).</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> @param[in]  odp_tm        The odp_tm_t value of the TM system to be</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           queried.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @param[out] <span class="insert">capabilities</span>  A pointer to <span class="insert">an odp_tm_capabilities_t</span> record</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           where the actual limits used by the TM system </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">are</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           copied into.  Note that these limits do NOT</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           have to match the capability passed in if</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           a TM system was created by odp_tm_create,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           but of course these limits in some cases could</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           be larger.</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> * @return                   Returns 0 upon success, &lt; 0 upon failure <span class="insert">(whic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">h</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> *                           indicates that the odp_tm value did not <span class="insert">exist)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0034" /></td></tr>
      <tr><td class="lblock">int odp_tm_capability(odp_tm_t odp_tm, odp_tm_capabilit<span class="delete">y_t *capability)</span>;</td><td> </td><td class="rblock">int odp_tm_capability(odp_tm_t odp_tm, odp_tm_capabilit<span class="insert">ies_t *capabilities)
</span>;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0035" /></td></tr>
      <tr><td class="lblock">/** odp_tm_destroy() may be used to destroy TM systems created via</td><td> </td><td class="rblock">/** <span class="insert">Destroy a TM system.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> odp_tm_destroy() may be used to destroy TM systems created via</td></tr>
      <tr><td class="left"> * odp_tm_create().  It generally CANNOT be used to destroy built-in TM</td><td> </td><td class="right"> * odp_tm_create().  It generally CANNOT be used to destroy built-in TM</td></tr>
      <tr><td class="left"> * systems.  Also some platforms MAY not support destroying of TM systems</td><td> </td><td class="right"> * systems.  Also some platforms MAY not support destroying of TM systems</td></tr>
      <tr><td class="left"> * created via odp_tm_create() under certain conditions.  For example a giv
en</td><td> </td><td class="right"> * created via odp_tm_create() under certain conditions.  For example a giv
en</td></tr>
      <tr><td class="left"> * platform may require that the TM system be first "drained" of all of its</td><td> </td><td class="right"> * platform may require that the TM system be first "drained" of all of its</td></tr>
      <tr><td class="left"> * queued packets before it will accept a odp_tm_destroy() call.</td><td> </td><td class="right"> * queued packets before it will accept a odp_tm_destroy() call.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * In general calling odp_tm_destroy() on an active TM system does not</td><td> </td><td class="right"> * In general calling odp_tm_destroy() on an active TM system does not</td></tr>
      <tr><td class="left"> * guarantee anything about the disposition of any packets queued within th
e</td><td> </td><td class="right"> * guarantee anything about the disposition of any packets queued within th
e</td></tr>
      <tr><td class="left"> * TM system, other than EVENTUALLY these packets will be either sent (in A
NY</td><td> </td><td class="right"> * TM system, other than EVENTUALLY these packets will be either sent (in A
NY</td></tr>
      <tr><td class="left"> * order) or freed.</td><td> </td><td class="right"> * order) or freed.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] odp_tm  The odp_tm_t value of the TM system to be destroyed (
and</td><td> </td><td class="right"> * @param[in] odp_tm  The odp_tm_t value of the TM system to be destroyed (
and</td></tr>
      <tr><td class="left"> *                    hence destroyed (and hence freed).</td><td> </td><td class="right"> *                    hence destroyed (and hence freed).</td></tr>
      <tr><td class="left"> * @return            0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return            0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_destroy(odp_tm_t odp_tm);</td><td> </td><td class="right">int odp_tm_destroy(odp_tm_t odp_tm);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0036" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Marking APIs */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Vlan Marking.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_vlan_marking() function allows one to configure the TM egress</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * so as to have it set the one bit VLAN Drop Eligibility Indicator (DEI)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * field (but only for pkts that already carry a VLAN tag) of a pkt based u</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">pon</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the final pkt (or shaper?) color assigned to the pkt when it reaches the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * egress node.  When drop_eligible_enabled is false, then the given color </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">has</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * no effect on the VLAN fields.  See IEEE 802.1q for more details.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * calls to this function with drop_eligible_enabled == FALSE - i.e. must</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * always return 0 when disabling this feature.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] odp_tm                 Odp_tm is used to identify the TM syst</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">em</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                                   whose egress behavior is being changed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] color                  The packet color whose egress marking </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                                   being changed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] drop_eligible_enabled  If true then will set the DEI bit for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                                   egressed VLAN tagged pkts with this co</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">lor.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                           0 upon success, &lt; 0 upon failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_vlan_marking(odp_tm_t           odp_tm,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       odp_packet_color_t color,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       odp_bool_t         drop_eligible_enabled);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Explicit Congestion Notification Marking.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_ecn_marking() function allows one to configure the TM</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * egress so that the two bit ECN subfield of the eight bit TOS field of an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * IPv4 pkt OR the eight bit Traffic Class (TC) field of an IPv6 pkt can be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * selectively modified based upon the final color assigned to the pkt when</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> it</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * reaches the egress.  Note that the IPv4 header checksum will be updated </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">-</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * but only if the IPv4 TOS field actually changes as a result of this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * setting or the odp_tm_drop_prec_marking setting.  For IPv6, since there </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * no header checksum, nothing needs to be done.  Note that this marking AP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">I</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * will only ever cause both ECN bits to be set to 1 - but only for TCP pkt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * whose incoming ECN bits are not both 0.  See RFC 3168 for more details.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * calls to this function with ecn_ce_enabled == FALSE - i.e. must always</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * return 0 when disabling this feature.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] odp_tm          Odp_tm is used to identify the TM system whos</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            egress behavior is being changed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] color           The packet color whose egress marking is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            being changed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] ecn_ce_enabled  If true then egressed IPv4/IPv6 pkts whose</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            protocol field is TCP AND whose ECN subfield </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">has</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            either one of the two values 1 or 2, will set</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            subfield to the value ECN_CE - i.e. Congestio</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            Experienced (whose value is 3).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                    0 upon success, &lt; 0 upon failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_ecn_marking(odp_tm_t           odp_tm,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                      odp_packet_color_t color,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                      odp_bool_t         ecn_ce_enabled);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Drop Precedence Marking.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_drop_prec_marking() function allows one to configure the TM</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * egress so that the two RFC 2597 Drop Precedence bits can be modified</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * based upon the final color assigned to the pkt when it reaches the egres</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The Drop Precedence bits are contained within the six bit Differentiated</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Services Code Point subfield of the IPv4 TOS field or the IPv6 Traffic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Class (TC) field.  Specifically the Drop Precedence sub-subfield can be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * accessed with a DSCP bit mask of 0x06.  When enabled for a given color,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * these two bits will be set to Medium Drop Precedence (value 0x4) if the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * color is ODP_PACKET_YELLOW, set to High Drop Precedence (value 0x6) if</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the color is ODP_PACKET_RED, otherwise set to Low Drop Precedence for an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * other color.  Of course an implementation can restrict the set of colors</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * which can be enabled via the marking_colors_supported array in the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_tm_capabilities_t record.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that the IPv4 header checksum will be updated - but only if the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * IPv4 TOS field actually changes as a result of this setting or the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_tm_ecn_marking setting.  For IPv6, since there is no header checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * nothing else needs to be done.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that ALL ODP implementations are required to SUCCESSFULLY handle al</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * calls to this function with drop_prec_enabled == FALSE - i.e. must alway</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * return 0 when disabling this feature.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] odp_tm            Odp_tm is used to identify the TM system wh</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ose</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                              egress behavior is being changed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] color             The packet color whose egress marking is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                              being changed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] drop_prec_enabled If true then egressed IPv4/IPv6 pkts with t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">his</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                              color will have the pkt's Drop Precedence</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                              sub-subfield of the DSCP subfield set to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                              LOW, MEDIUM or HIGH drop precedence.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                      0 upon success, &lt; 0 upon failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_drop_prec_marking(odp_tm_t           odp_tm,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                            odp_packet_color_t color,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                            odp_bool_t         drop_prec_enabled);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Shaper profile types and functions */</td><td> </td><td class="right">/** Shaper profile types and functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Possible values of running the shaper algorithm.  ODP_TM_SHAPER_GREEN</td><td> </td><td class="right">/** Possible values of running the shaper algorithm.  ODP_TM_SHAPER_GREEN</td></tr>
      <tr><td class="left"> * means that the traffic is within the commit specification (rate and burs
t</td><td> </td><td class="right"> * means that the traffic is within the commit specification (rate and burs
t</td></tr>
      <tr><td class="left"> * size), ODP_TM_SHAPER_YELLOW means that the traffic is within the peak</td><td> </td><td class="right"> * size), ODP_TM_SHAPER_YELLOW means that the traffic is within the peak</td></tr>
      <tr><td class="left"> * specification (rate and burst size) and ODP_TM_SHAPER_RED means that the</td><td> </td><td class="right"> * specification (rate and burst size) and ODP_TM_SHAPER_RED means that the</td></tr>
      <tr><td class="left"> * traffic is exceeding both its commit and peak specifications.  Note that</td><td> </td><td class="right"> * traffic is exceeding both its commit and peak specifications.  Note that</td></tr>
      <tr><td class="left"> * packets can also have an assigned &lt;b&gt; packet color&lt;/b&gt; of ODP_PACKET_GRE
EN,</td><td> </td><td class="right"> * packets can also have an assigned &lt;b&gt; packet color&lt;/b&gt; of ODP_PACKET_GRE
EN,</td></tr>
      <tr><td class="left"> * ODP_PACKET_YELLOW or ODP_PACKET_RED which has a different meaning and</td><td> </td><td class="right"> * ODP_PACKET_YELLOW or ODP_PACKET_RED which has a different meaning and</td></tr>
      <tr><td class="left"> * purpose than the shaper colors.</td><td> </td><td class="right"> * purpose than the shaper colors.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 424</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 742</em></th></tr>
      <tr><td class="left">       ODP_TM_SHAPER_GREEN, ODP_TM_SHAPER_YELLOW, ODP_TM_SHAPER_RED</td><td> </td><td class="right">       ODP_TM_SHAPER_GREEN, ODP_TM_SHAPER_YELLOW, ODP_TM_SHAPER_RED</td></tr>
      <tr><td class="left">} odp_tm_shaper_color_t;</td><td> </td><td class="right">} odp_tm_shaper_color_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_shaper_params_t record type is used to supply the parameters</td><td> </td><td class="right">/** The odp_tm_shaper_params_t record type is used to supply the parameters</td></tr>
      <tr><td class="left"> * associated with a shaper profile.  Since it is expected that</td><td> </td><td class="right"> * associated with a shaper profile.  Since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_shaper_params_init() be</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_shaper_params_init() be</td></tr>
      <tr><td class="left"> * called on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * called on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0037" /></td></tr>
      <tr><td class="lblock">       /** The committed information rate for this shaper profile.  The uni</td><td> </td><td class="rblock">       /** The committed information rate for this shaper profile.  The uni</td></tr>
      <tr><td class="lblock">ts</td><td> </td><td class="rblock">ts</td></tr>
      <tr><td class="lblock">       * for this integer are always in bits per second.</td><td> </td><td class="rblock">        * for this integer are always in bits per second. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint64_t commit_bps;</td><td> </td><td class="right">       uint64_t commit_bps;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0038" /></td></tr>
      <tr><td class="lblock">       /** The peak information rate for this shaper profile.  The units fo</td><td> </td><td class="rblock">       /** The peak information rate for this shaper profile.  The units fo</td></tr>
      <tr><td class="lblock">r</td><td> </td><td class="rblock">r</td></tr>
      <tr><td class="lblock">       * this integer are always in bits per second.</td><td> </td><td class="rblock">        * this integer are always in bits per second. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint64_t peak_bps;</td><td> </td><td class="right">       uint64_t peak_bps;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0039" /></td></tr>
      <tr><td class="lblock">       /** The commit burst tolerance for this shaper profile.  The units f</td><td> </td><td class="rblock">       /** The commit burst tolerance for this shaper profile.  The units f</td></tr>
      <tr><td class="lblock">or</td><td> </td><td class="rblock">or</td></tr>
      <tr><td class="lblock">       * this field are always bits.  This value sets an upper limit for <span class="delete">th</span></td><td> </td><td class="rblock">        * this field are always bits.  This value sets an upper limit for <span class="insert">t</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock">       * size of the commitCnt.</td><td> </td><td class="rblock">        * size of the commitCnt. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint32_t commit_burst;</td><td> </td><td class="right">       uint32_t commit_burst;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0040" /></td></tr>
      <tr><td class="lblock">       /** The peak burst tolerance for this shaper profile.  The units for</td><td> </td><td class="rblock">       /** The peak burst tolerance for this shaper profile.  The units for</td></tr>
      <tr><td class="lblock">       * this field are always bits.  This value sets an upper limit for <span class="delete">th</span></td><td> </td><td class="rblock">        * this field are always bits.  This value sets an upper limit for <span class="insert">t</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock">       * size of the peakCnt.</td><td> </td><td class="rblock">        * size of the peakCnt. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint32_t peak_burst;</td><td> </td><td class="right">       uint32_t peak_burst;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0041" /></td></tr>
      <tr><td class="lblock">       /** The shaper_len_adjust is a value between -128 and 127 which is</td><td> </td><td class="rblock">       /** The shaper_len_adjust is a value between -128 and 127 which is</td></tr>
      <tr><td class="lblock">       * directly added to the frame_len of a packet associated with this</td><td> </td><td class="rblock">        * directly added to the frame_len of a packet associated with this</td></tr>
      <tr><td class="lblock">       * profile.  The frame_len would normally include the outermost</td><td> </td><td class="rblock">        * profile.  The frame_len would normally include the outermost</td></tr>
      <tr><td class="lblock">       * Ethernet header (DA, SA, ...) through to the outermost Ethernet <span class="delete">CR</span></td><td> </td><td class="rblock">        * Ethernet header (DA, SA, ...) through to the outermost Ethernet C</td></tr>
      <tr><td class="lblock">C</td><td> </td><td class="rblock"><span class="insert">RC</span></td></tr>
      <tr><td class="lblock">       * inclusive.  Hence this field - when non-zero - will usually be <span class="delete">set</span></td><td> </td><td class="rblock">        * inclusive.  Hence this field - when non-zero - will usually be <span class="insert">se</span></td></tr>
      <tr><td class="lblock">       * to a value approximating the "time" (in units of bytes) taken by</td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock">       * the Ethernet preamble and Inter Frame Gap.  Traditionally this</td><td> </td><td class="rblock">        * to a value approximating the "time" (in units of bytes) taken by</td></tr>
      <tr><td class="lblock">       * would be the value 20 (8 + 12), but in same cases can be as low <span class="delete">as</span></td><td> </td><td class="rblock">        * the Ethernet preamble and Inter Frame Gap.  Traditionally this</td></tr>
      <tr><td class="lblock">       * 9 (4 + 5).</td><td> </td><td class="rblock">        * would be the value 20 (8 + 12), but in same cases can be as low <span class="insert">a</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * 9 (4 + 5). */</td></tr>
      <tr><td class="left">       int8_t shaper_len_adjust;</td><td> </td><td class="right">       int8_t shaper_len_adjust;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0042" /></td></tr>
      <tr><td class="lblock">       /** If dual_rate is TRUE it indicates the desire for the</td><td> </td><td class="rblock">       /** If dual_rate is TRUE it indicates the desire for the</td></tr>
      <tr><td class="lblock">       * implementation to use dual rate shaping for packets associated <span class="delete">wit</span></td><td> </td><td class="rblock">        * implementation to use dual rate shaping for packets associated <span class="insert">wi</span></td></tr>
      <tr><td class="lblock"><span class="delete">h</span></td><td> </td><td class="rblock"><span class="insert">th</span></td></tr>
      <tr><td class="lblock">       * this profile.  The precise semantics of dual rate shaping are</td><td> </td><td class="rblock">        * this profile.  The precise semantics of dual rate shaping are</td></tr>
      <tr><td class="lblock">       * implementation specific, but in any case require a non-zero set <span class="delete">of</span></td><td> </td><td class="rblock">        * implementation specific, but in any case require a non-zero set <span class="insert">o</span></td></tr>
      <tr><td class="lblock">       * both commit and peak parameters.</td><td> </td><td class="rblock"><span class="insert">f</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">        * both commit and peak parameters. */</td></tr>
      <tr><td class="left">       odp_bool_t dual_rate;</td><td> </td><td class="right">       odp_bool_t dual_rate;</td></tr>
      <tr><td class="left">} odp_tm_shaper_params_t;</td><td> </td><td class="right">} odp_tm_shaper_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_shaper_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_shaper_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_shaper_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_shaper_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to an odp_tm_shaper_params_t record which</td><td> </td><td class="right"> * @param[in] params  A pointer to an odp_tm_shaper_params_t record which</td></tr>
      <tr><td class="left"> *                    is to be initialized.</td><td> </td><td class="right"> *                    is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_shaper_params_init(odp_tm_shaper_params_t *params);</td><td> </td><td class="right">void odp_tm_shaper_params_init(odp_tm_shaper_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l4" /><small>skipping to change at</small><em> line 491</em></th><th> </th><th><a name="part-r4" /><small>skipping to change at</small><em> line 803</em></th></tr>
      <tr><td class="left"> *                    all other shaper profiles.</td><td> </td><td class="right"> *                    all other shaper profiles.</td></tr>
      <tr><td class="left"> * @param[in] params  The profile parameters.  See comments associated with</td><td> </td><td class="right"> * @param[in] params  The profile parameters.  See comments associated with</td></tr>
      <tr><td class="left"> *                    the odp_tm_shaper_params_t for more details.</td><td> </td><td class="right"> *                    the odp_tm_shaper_params_t for more details.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="left"> *                    allocated odp_tm_shaper_t value representing this</td><td> </td><td class="right"> *                    allocated odp_tm_shaper_t value representing this</td></tr>
      <tr><td class="left"> *                    profile object.</td><td> </td><td class="right"> *                    profile object.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_shaper_t odp_tm_shaper_create(const char *name,</td><td> </td><td class="right">odp_tm_shaper_t odp_tm_shaper_create(const char *name,</td></tr>
      <tr><td class="left">                                    odp_tm_shaper_params_t *params);</td><td> </td><td class="right">                                    odp_tm_shaper_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0043" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Destroy shaper profile object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_shaper_destroy() function destroys/frees the given shaper</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * profile object.  It is an error if this shaper profile is still being</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * referenced by an active (connected) tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] shaper_profile   Specifies the shaper profile object which is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                             being destroyed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                     Returns &lt; 0 upon failure or 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_shaper_destroy(odp_tm_shaper_t shaper_profile);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** odp_tm_shaper_params_read() "gets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_shaper_params_read() "gets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified shaper profile object, and copies them into the suppl
ied</td><td> </td><td class="right"> * with the specified shaper profile object, and copies them into the suppl
ied</td></tr>
      <tr><td class="left"> * record.</td><td> </td><td class="right"> * record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  shaper_profile  Specifies the shaper profile object whose</td><td> </td><td class="right"> * @param[in]  shaper_profile  Specifies the shaper profile object whose</td></tr>
      <tr><td class="left"> *                             values are to be read.</td><td> </td><td class="right"> *                             values are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params          A pointer to an odp_tm_shaper_params_t recor
d</td><td> </td><td class="right"> * @param[out] params          A pointer to an odp_tm_shaper_params_t recor
d</td></tr>
      <tr><td class="left"> *                             where the current shaper profile object valu
es</td><td> </td><td class="right"> *                             where the current shaper profile object valu
es</td></tr>
      <tr><td class="left"> *                             are copied to.</td><td> </td><td class="right"> *                             are copied to.</td></tr>
      <tr><td class="left"> * @return                     Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="right"> * @return                     Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l5" /><small>skipping to change at</small><em> line 552</em></th><th> </th><th><a name="part-r5" /><small>skipping to change at</small><em> line 876</em></th></tr>
      <tr><td class="left">       ODP_TM_FRAME_BASED_WEIGHTS /**&lt; Ignore the packet length */</td><td> </td><td class="right">       ODP_TM_FRAME_BASED_WEIGHTS /**&lt; Ignore the packet length */</td></tr>
      <tr><td class="left">} odp_tm_sched_mode_t;</td><td> </td><td class="right">} odp_tm_sched_mode_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_sched_params_t record type is used to supply the parameters</td><td> </td><td class="right">/** The odp_tm_sched_params_t record type is used to supply the parameters</td></tr>
      <tr><td class="left"> * associated with a scheduler profile.  Since it is expected that</td><td> </td><td class="right"> * associated with a scheduler profile.  Since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_sched_params_init() be</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_sched_params_init() be</td></tr>
      <tr><td class="left"> * called on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * called on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0044" /></td></tr>
      <tr><td class="lblock">       /** sched_modes indicates whether weighted scheduling should be used</td><td> </td><td class="rblock">       /** sched_modes indicates whether weighted scheduling should be used</td></tr>
      <tr><td class="lblock">       * or not - on a priority basis.</td><td> </td><td class="rblock">        * or not - on a priority basis. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_tm_sched_mode_t sched_modes[ODP_TM_MAX_PRIORITIES];</td><td> </td><td class="right">       odp_tm_sched_mode_t sched_modes[ODP_TM_MAX_PRIORITIES];</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0045" /></td></tr>
      <tr><td class="lblock">       /** In the case that sched_modes for a given strict priority level</td><td> </td><td class="rblock">       /** In the case that sched_modes for a given strict priority level</td></tr>
      <tr><td class="lblock">       * indicates the use of weighted scheduling, this field supplies the</td><td> </td><td class="rblock">        * indicates the use of weighted scheduling, this field supplies the</td></tr>
      <tr><td class="lblock">       * weighting factors.  The weights - when defined - are used such <span class="delete">tha</span></td><td> </td><td class="rblock">        * weighting factors.  The weights - when defined - are used such <span class="insert">th</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"><span class="insert">at</span></td></tr>
      <tr><td class="lblock">       * the (adjusted) frame lengths are divided by these 8-bit weights</td><td> </td><td class="rblock">         * the (adjusted) frame lengths are divided by these 8-bit weights</td></tr>
      <tr><td class="lblock">       * (i.e. they are divisors and not multipliers).  Consequently a</td><td> </td><td class="rblock">        * (i.e. they are divisors and not multipliers).  Consequently a</td></tr>
      <tr><td class="lblock">       * weight of 0 (when sched_mode is ODP_TM_BYTE_BASED_WEIGHTS) is</td><td> </td><td class="rblock">        * weight of 0 (when sched_mode is ODP_TM_BYTE_BASED_WEIGHTS) is</td></tr>
      <tr><td class="lblock">       * illegal.</td><td> </td><td class="rblock">        * illegal. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint8_t sched_weights[ODP_TM_MAX_PRIORITIES];</td><td> </td><td class="right">       uint8_t sched_weights[ODP_TM_MAX_PRIORITIES];</td></tr>
      <tr><td class="left">} odp_tm_sched_params_t;</td><td> </td><td class="right">} odp_tm_sched_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_sched_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_sched_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_sched_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_sched_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to an odp_tm_sched_params_t record which</td><td> </td><td class="right"> * @param[in] params  A pointer to an odp_tm_sched_params_t record which</td></tr>
      <tr><td class="left"> *                    is to be initialized.</td><td> </td><td class="right"> *                    is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_sched_params_init(odp_tm_sched_params_t *params);</td><td> </td><td class="right">void odp_tm_sched_params_init(odp_tm_sched_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l6" /><small>skipping to change at</small><em> line 591</em></th><th> </th><th><a name="part-r6" /><small>skipping to change at</small><em> line 913</em></th></tr>
      <tr><td class="left"> *                    set of all other scheduler profiles.</td><td> </td><td class="right"> *                    set of all other scheduler profiles.</td></tr>
      <tr><td class="left"> * @param[in] params  The profile parameters.  See comments associated with</td><td> </td><td class="right"> * @param[in] params  The profile parameters.  See comments associated with</td></tr>
      <tr><td class="left"> *                    the odp_tm_sched_params_t for more details.</td><td> </td><td class="right"> *                    the odp_tm_sched_params_t for more details.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="left"> *                    allocated odp_tm_sched_t value representing this prof
ile</td><td> </td><td class="right"> *                    allocated odp_tm_sched_t value representing this prof
ile</td></tr>
      <tr><td class="left"> *                    object.</td><td> </td><td class="right"> *                    object.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_sched_t odp_tm_sched_create(const char *name,</td><td> </td><td class="right">odp_tm_sched_t odp_tm_sched_create(const char *name,</td></tr>
      <tr><td class="left">                                  odp_tm_sched_params_t *params);</td><td> </td><td class="right">                                  odp_tm_sched_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0046" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Destroy scheduler profile object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_sched_destroy() function destroys/frees the given scheduler</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * profile object.  It is an error if this scheduler profile is still being</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * referenced by an active (connected) tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] sched_profile  Specifies the shaper profile object which is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                           being destroyed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                   Returns &lt; 0 upon failure or 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_sched_destroy(odp_tm_sched_t sched_profile);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** odp_tm_sched_params_read() "gets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_sched_params_read() "gets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified scheduler profile object, and copies them into the</td><td> </td><td class="right"> * with the specified scheduler profile object, and copies them into the</td></tr>
      <tr><td class="left"> * supplied record.</td><td> </td><td class="right"> * supplied record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  sched_profile  Specifies the scheduler profile whose values</td><td> </td><td class="right"> * @param[in]  sched_profile  Specifies the scheduler profile whose values</td></tr>
      <tr><td class="left"> *                            are to be read.</td><td> </td><td class="right"> *                            are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params         A pointer to an odp_tm_sched_params_t record</td><td> </td><td class="right"> * @param[out] params         A pointer to an odp_tm_sched_params_t record</td></tr>
      <tr><td class="left"> *                            where the current scheduler profile object</td><td> </td><td class="right"> *                            where the current scheduler profile object</td></tr>
      <tr><td class="left"> *                            values are copied to.</td><td> </td><td class="right"> *                            values are copied to.</td></tr>
      <tr><td class="left"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="right"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l7" /><small>skipping to change at</small><em> line 669</em></th><th> </th><th><a name="part-r7" /><small>skipping to change at</small><em> line 1003</em></th></tr>
      <tr><td class="left"> *                    amongst the set of all other queue threshold profiles
.</td><td> </td><td class="right"> *                    amongst the set of all other queue threshold profiles
.</td></tr>
      <tr><td class="left"> * @param[in] params  The profile parameters.  See comments associated with</td><td> </td><td class="right"> * @param[in] params  The profile parameters.  See comments associated with</td></tr>
      <tr><td class="left"> *                    the odp_tm_threshold_params_t for more details.</td><td> </td><td class="right"> *                    the odp_tm_threshold_params_t for more details.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="left"> *                    allocated odp_tm_threshold_t value representing this</td><td> </td><td class="right"> *                    allocated odp_tm_threshold_t value representing this</td></tr>
      <tr><td class="left"> *                    profile object.</td><td> </td><td class="right"> *                    profile object.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_threshold_t odp_tm_threshold_create(const char *name,</td><td> </td><td class="right">odp_tm_threshold_t odp_tm_threshold_create(const char *name,</td></tr>
      <tr><td class="left">                                          odp_tm_threshold_params_t *params
);</td><td> </td><td class="right">                                          odp_tm_threshold_params_t *params
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0047" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Destroy a queue threshold profile object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_threshold_destroy() function destroys/frees the given thresho</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ld</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * profile object.  It is an error if this threshold profile is still being</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * referenced by an active (connected) tm_queue or tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] threshold_profile  Specifies the queue thresholds profile</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                               object which is being destroyed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                       Returns &lt; 0 upon failure or 0 upon success</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_threshold_destroy(odp_tm_threshold_t threshold_profile);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** odp_tm_thresholds_params_read() "gets" the current set of values associ
ated</td><td> </td><td class="right">/** odp_tm_thresholds_params_read() "gets" the current set of values associ
ated</td></tr>
      <tr><td class="left"> * with the specified queue thresholds profile object, and copies them into
 the</td><td> </td><td class="right"> * with the specified queue thresholds profile object, and copies them into
 the</td></tr>
      <tr><td class="left"> * supplied record.</td><td> </td><td class="right"> * supplied record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  threshold_profile  Specifies the queue thresholds profile</td><td> </td><td class="right"> * @param[in]  threshold_profile  Specifies the queue thresholds profile</td></tr>
      <tr><td class="left"> *                                object whose values are to be read.</td><td> </td><td class="right"> *                                object whose values are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params             A pointer to an odp_tm_threshold_params_t</td><td> </td><td class="right"> * @param[out] params             A pointer to an odp_tm_threshold_params_t</td></tr>
      <tr><td class="left"> *                                record where the current queue thresholds</td><td> </td><td class="right"> *                                record where the current queue thresholds</td></tr>
      <tr><td class="left"> *                                profile object values are copied to.</td><td> </td><td class="right"> *                                profile object values are copied to.</td></tr>
      <tr><td class="left"> * @return                        Returns &lt; 0 upon failure or 0 upon succes
s.</td><td> </td><td class="right"> * @return                        Returns &lt; 0 upon failure or 0 upon succes
s.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l8" /><small>skipping to change at</small><em> line 712</em></th><th> </th><th><a name="part-r8" /><small>skipping to change at</small><em> line 1058</em></th></tr>
      <tr><td class="left"> * @param[in] name  Name of a previously created queue thresholds profile.</td><td> </td><td class="right"> * @param[in] name  Name of a previously created queue thresholds profile.</td></tr>
      <tr><td class="left"> *                  Cannot be NULL.</td><td> </td><td class="right"> *                  Cannot be NULL.</td></tr>
      <tr><td class="left"> * @return          Returns ODP_TM_INVALID upon failure, or the queue</td><td> </td><td class="right"> * @return          Returns ODP_TM_INVALID upon failure, or the queue</td></tr>
      <tr><td class="left"> *                  thresholds profile handle created with this name.</td><td> </td><td class="right"> *                  thresholds profile handle created with this name.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_threshold_t odp_tm_thresholds_lookup(const char *name);</td><td> </td><td class="right">odp_tm_threshold_t odp_tm_thresholds_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** WRED Profiles - types and functions */</td><td> </td><td class="right">/** WRED Profiles - types and functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_wred_params_t record type is used to supply the parameters</td><td> </td><td class="right">/** The odp_tm_wred_params_t record type is used to supply the parameters</td></tr>
      <tr><td><a name="diff0048" /></td></tr>
      <tr><td class="lblock"> * associated with a Random Early D<span class="delete">iscard profile.  Since it is expected th
</span>at</td><td> </td><td class="rblock"> * associated with a Random Early D<span class="insert">etection profile.  Since it is expected 
th</span>at</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_wred_params_init() be cal
led</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_wred_params_init() be cal
led</td></tr>
      <tr><td class="left"> * on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0049" /></td></tr>
      <tr><td class="lblock">       /** When min_threshold is set to zero then single-slope WRED is</td><td> </td><td class="rblock">       /** When min_threshold is set to zero then single-slope WRED is</td></tr>
      <tr><td class="lblock">       * enabled, as described in the description of med_threshold.</td><td> </td><td class="rblock">        * enabled, as described in the description of med_threshold.</td></tr>
      <tr><td class="lblock">       * Otherwise dual-slope WRED is enabled whereby the behavior depends</td><td> </td><td class="rblock">        * Otherwise dual-slope WRED is enabled whereby the behavior depends</td></tr>
      <tr><td class="lblock">       * on which of the following three cases exists:</td><td> </td><td class="rblock">        * on which of the following three cases exists:</td></tr>
      <tr><td class="lblock">       * &lt;ol&gt; &lt;li&gt; queue</td><td> </td><td class="rblock">        * &lt;ol&gt; &lt;li&gt; queue</td></tr>
      <tr><td class="lblock">       * fullness &lt; min_threshold.  In this case the drop probability is</td><td> </td><td class="rblock">        * fullness &lt; min_threshold.  In this case the drop probability is</td></tr>
      <tr><td class="lblock">       * zero.</td><td> </td><td class="rblock">        * zero.</td></tr>
      <tr><td class="lblock">       * &lt;li&gt; min_threshold &lt;= queue fullness &lt; med_threshold.  In</td><td> </td><td class="rblock">        * &lt;li&gt; min_threshold &lt;= queue fullness &lt; med_threshold.  In</td></tr>
      <tr><td class="lblock">       * this case the drop probability increases linearly from zero until</td><td> </td><td class="rblock">        * this case the drop probability increases linearly from zero until</td></tr>
      <tr><td class="lblock">       * it reaches med_drop_prob at a queue fullness equal to</td><td> </td><td class="rblock">        * it reaches med_drop_prob at a queue fullness equal to</td></tr>
      <tr><td class="lblock">       * med_threshold.</td><td> </td><td class="rblock">        * med_threshold.</td></tr>
      <tr><td class="lblock">       * &lt;li&gt; med_threshold &lt;= queue fullness.  In this case</td><td> </td><td class="rblock">        * &lt;li&gt; med_threshold &lt;= queue fullness.  In this case</td></tr>
      <tr><td class="lblock">       * the drop probability increases linearly from med_drop_prob when <span class="delete">th</span></td><td> </td><td class="rblock">        * the drop probability increases linearly from med_drop_prob when <span class="insert">t</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock">       * queue fullness equals med_threshold until it reaches 100% with a</td><td> </td><td class="rblock">        * queue fullness equals med_threshold until it reaches 100% with a</td></tr>
      <tr><td class="lblock">       * drop probability of max_drop_prob.  &lt;/ol&gt;</td><td> </td><td class="rblock">        * drop probability of max_drop_prob.  &lt;/ol&gt; */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_tm_percent_t min_threshold;</td><td> </td><td class="right">       odp_tm_percent_t min_threshold;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0050" /></td></tr>
      <tr><td class="lblock">       /** The meaning of med_threshold depends upon whether single-slope o</td><td> </td><td class="rblock">       /** The meaning of med_threshold depends upon whether single-slope o</td></tr>
      <tr><td class="lblock">r</td><td> </td><td class="rblock">r</td></tr>
      <tr><td class="lblock">       * dual-slope WRED is being used or not.  When min_threshold is 0 <span class="delete">the</span></td><td> </td><td class="rblock">        * dual-slope WRED is being used or not.  When min_threshold is 0 <span class="insert">th</span></td></tr>
      <tr><td class="lblock"><span class="delete">n</span></td><td> </td><td class="rblock"><span class="insert">en</span></td></tr>
      <tr><td class="lblock">       * single-slope WRED is enabled in which case the med_threshold <span class="delete">value</span></td><td> </td><td class="rblock">        * single-slope WRED is enabled in which case the med_threshold <span class="insert">valu</span></td></tr>
      <tr><td class="lblock">       * represents (as a percentage of max queue fullness) the point at</td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock">       * which the drop probability starts increasing linearly from 0 <span class="delete">until</span></td><td> </td><td class="rblock">        * represents (as a percentage of max queue fullness) the point at</td></tr>
      <tr><td class="lblock">       * it becomes equal to max_drop_prob when the queue fullness reaches</td><td> </td><td class="rblock">        * which the drop probability starts increasing linearly from 0 <span class="insert">unti</span></td></tr>
      <tr><td class="lblock">       * 100%.  See min_threshold comments for the case of dual-slope <span class="delete">WRED.</span></td><td> </td><td class="rblock"><span class="insert">l</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">        * it becomes equal to max_drop_prob when the queue fullness reaches</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * 100%.  See min_threshold comments for the case of dual-slope <span class="insert">WRED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span> */</td></tr>
      <tr><td class="left">       odp_tm_percent_t med_threshold;</td><td> </td><td class="right">       odp_tm_percent_t med_threshold;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0051" /></td></tr>
      <tr><td class="lblock">       /** The med_drop_prob is only used when dual-slope WRED is being use</td><td> </td><td class="rblock">       /** The med_drop_prob is only used when dual-slope WRED is being use</td></tr>
      <tr><td class="lblock">d,</td><td> </td><td class="rblock">d,</td></tr>
      <tr><td class="lblock">       * in which case med_drop_prob MUST be &lt; max_drop_prob.  See</td><td> </td><td class="rblock">        * in which case med_drop_prob MUST be &lt; max_drop_prob.  See</td></tr>
      <tr><td class="lblock">       * min_threshold comments for more details.</td><td> </td><td class="rblock">        * min_threshold comments for more details. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_tm_percent_t med_drop_prob;</td><td> </td><td class="right">       odp_tm_percent_t med_drop_prob;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0052" /></td></tr>
      <tr><td class="lblock">       /** The max_drop_prob equals the drop probability when the queue</td><td> </td><td class="rblock">       /** The max_drop_prob equals the drop probability when the queue</td></tr>
      <tr><td class="lblock">       * fullness almost equals 100%.  Of course once the queue fullness <span class="delete">is</span></td><td> </td><td class="rblock">        * fullness almost equals 100%.  Of course once the queue fullness <span class="insert">i</span></td></tr>
      <tr><td class="lblock">       * &gt;= 100% of the max queue fullness, the drop probability</td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock">       * discontinuously becomes 100%.</td><td> </td><td class="rblock">        * &gt;= 100% of the max queue fullness, the drop probability</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">        * discontinuously becomes 100%. */</td></tr>
      <tr><td class="left">       odp_tm_percent_t max_drop_prob;</td><td> </td><td class="right">       odp_tm_percent_t max_drop_prob;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0053" /></td></tr>
      <tr><td class="lblock">       /** When enable_wred is false, all tm_queues and tm_nodes that are</td><td> </td><td class="rblock">       /** When enable_wred is false, all tm_queues and tm_nodes that are</td></tr>
      <tr><td class="lblock">       * attached to this profile will not take part in a Random Early</td><td> </td><td class="rblock">        * attached to this profile will not take part in a Random Early</td></tr>
      <tr><td class="lblock">       * <span class="delete">Discard</span> algorithm.</td><td> </td><td class="rblock">        * <span class="insert">Detection</span> algorithm. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_bool_t enable_wred;</td><td> </td><td class="right">       odp_bool_t enable_wred;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0054" /></td></tr>
      <tr><td class="lblock">       /** When use_byte_fullness is true then WRED will use queue memory</td><td> </td><td class="rblock">       /** When use_byte_fullness is true then WRED will use queue memory</td></tr>
      <tr><td class="lblock">       * usage as the fullness criterion, otherwise when use_byte_fullness</td><td> </td><td class="rblock">        * usage as the fullness criterion, otherwise when use_byte_fullness</td></tr>
      <tr><td class="lblock">       * is false, WRED will use the queue length (i.e. the number of</td><td> </td><td class="rblock">        * is false, WRED will use the queue length (i.e. the number of</td></tr>
      <tr><td class="lblock">       * packets in the queue) as the fullness criterion.  Often will be <span class="delete">se</span></td><td> </td><td class="rblock">        * packets in the queue) as the fullness criterion.  Often will be <span class="insert">s</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"><span class="insert">et</span></td></tr>
      <tr><td class="lblock">       * to true for WRED profiles applied to tm_queues and set to false <span class="delete">fo</span></td><td> </td><td class="rblock">        * to true for WRED profiles applied to tm_queues and set to false <span class="insert">f</span></td></tr>
      <tr><td class="lblock"><span class="delete">r</span></td><td> </td><td class="rblock"><span class="insert">or</span></td></tr>
      <tr><td class="lblock">       * WRED profiles applied to tm_nodes.</td><td> </td><td class="rblock">        * WRED profiles applied to tm_nodes. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_bool_t use_byte_fullness;</td><td> </td><td class="right">       odp_bool_t use_byte_fullness;</td></tr>
      <tr><td class="left">} odp_tm_wred_params_t;</td><td> </td><td class="right">} odp_tm_wred_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_wred_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_wred_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_wred_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_wred_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to an odp_tm_wred_params_t record which</td><td> </td><td class="right"> * @param[in] params  A pointer to an odp_tm_wred_params_t record which</td></tr>
      <tr><td class="left"> *                    is to be initialized.</td><td> </td><td class="right"> *                    is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_wred_params_init(odp_tm_wred_params_t *params);</td><td> </td><td class="right">void odp_tm_wred_params_init(odp_tm_wred_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0055" /></td></tr>
      <tr><td class="lblock">/** odp_tm_wred_create() creates a WRED (Weighted Random Early D<span class="delete">iscard</span>)</td><td> </td><td class="rblock">/** odp_tm_wred_create() creates a WRED (Weighted Random Early D<span class="insert">etection</span>)</td></tr>
      <tr><td class="left"> * profile object, which can subsequently be attached to any number (includ
ing</td><td> </td><td class="right"> * profile object, which can subsequently be attached to any number (includ
ing</td></tr>
      <tr><td class="left"> * zero) of tm_queues or tm_nodes.</td><td> </td><td class="right"> * zero) of tm_queues or tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] name    Optional name associated with this WRED profile.  Can</td><td> </td><td class="right"> * @param[in] name    Optional name associated with this WRED profile.  Can</td></tr>
      <tr><td class="left"> *                    be NULL.  If non-NULL must be unique amongst the set 
of</td><td> </td><td class="right"> *                    be NULL.  If non-NULL must be unique amongst the set 
of</td></tr>
      <tr><td class="left"> *                    all other WRED profiles.</td><td> </td><td class="right"> *                    all other WRED profiles.</td></tr>
      <tr><td class="left"> * @param[in] params  The profile parameters.  See comments associated with
 the</td><td> </td><td class="right"> * @param[in] params  The profile parameters.  See comments associated with
 the</td></tr>
      <tr><td class="left"> *                    odp_tm_wred_params_t for more details.</td><td> </td><td class="right"> *                    odp_tm_wred_params_t for more details.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, or the newly</td></tr>
      <tr><td class="left"> *                    allocated odp_tm_wred_t value representing this profi
le</td><td> </td><td class="right"> *                    allocated odp_tm_wred_t value representing this profi
le</td></tr>
      <tr><td class="left"> *                    object.</td><td> </td><td class="right"> *                    object.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_wred_t odp_tm_wred_create(const char *name,</td><td> </td><td class="right">odp_tm_wred_t odp_tm_wred_create(const char *name,</td></tr>
      <tr><td class="left">                                odp_tm_wred_params_t *params);</td><td> </td><td class="right">                                odp_tm_wred_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0056" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Destroy WRED profile object</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_wred_destroy() function destroys/frees the given WRED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * profile object.  It is an error if this profile object is still being</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * referenced by an active (connected) tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] wred_profile   Specifies the WRED profile object which is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                            being destroyed.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                    Returns &lt; 0 upon failure or 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_wred_destroy(odp_tm_wred_t wred_profile);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** odp_tm_wred_params_read() "gets" the current set of values associated</td><td> </td><td class="right">/** odp_tm_wred_params_read() "gets" the current set of values associated</td></tr>
      <tr><td class="left"> * with the specified WRED profile object, and copies them into the supplie
d</td><td> </td><td class="right"> * with the specified WRED profile object, and copies them into the supplie
d</td></tr>
      <tr><td class="left"> * record.</td><td> </td><td class="right"> * record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  wred_profile  Specifies the WRED profile object whose</td><td> </td><td class="right"> * @param[in]  wred_profile  Specifies the WRED profile object whose</td></tr>
      <tr><td class="left"> *                           values are to be read.</td><td> </td><td class="right"> *                           values are to be read.</td></tr>
      <tr><td class="left"> * @param[out] params        A pointer to an odp_tm_wred_params_t record</td><td> </td><td class="right"> * @param[out] params        A pointer to an odp_tm_wred_params_t record</td></tr>
      <tr><td class="left"> *                           where the current WRED profile object values</td><td> </td><td class="right"> *                           where the current WRED profile object values</td></tr>
      <tr><td class="left"> *                           are copied to.</td><td> </td><td class="right"> *                           are copied to.</td></tr>
      <tr><td class="left"> * @return                   Returns &lt; 0 upon failure or 0 upon success.</td><td> </td><td class="right"> * @return                   Returns &lt; 0 upon failure or 0 upon success.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l9" /><small>skipping to change at</small><em> line 846</em></th><th> </th><th><a name="part-r9" /><small>skipping to change at</small><em> line 1198</em></th></tr>
      <tr><td class="left">odp_tm_wred_t odp_tm_wred_lookup(const char *name);</td><td> </td><td class="right">odp_tm_wred_t odp_tm_wred_lookup(const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_params_t record type is used to hold extra parameters w
hen</td><td> </td><td class="right">/** The odp_tm_node_params_t record type is used to hold extra parameters w
hen</td></tr>
      <tr><td class="left"> * calling the odp_tm_node_create() function.  Many of these fields are</td><td> </td><td class="right"> * calling the odp_tm_node_create() function.  Many of these fields are</td></tr>
      <tr><td class="left"> * optional EXCEPT for max_fanin and level.  Also since it is expected that</td><td> </td><td class="right"> * optional EXCEPT for max_fanin and level.  Also since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_node_params_init() be cal
led</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_node_params_init() be cal
led</td></tr>
      <tr><td class="left"> * on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0057" /></td></tr>
      <tr><td class="lblock">       /** The <span class="delete">max_fan_in sets tha maximum number of src tm_queues and</span></td><td> </td><td class="rblock">       /** The <span class="insert">user_context field is an generic pointer</span> that <span class="insert">the user</span> can</td></tr>
      <tr><td class="lblock"><span class="delete">       * producer tm_nodes</span> that can <span class="delete">be simultaneously be connected to this</span></td><td> </td><td class="rblock">        * <span class="insert">associate with a</span> tm_node <span class="insert">and then get this same value back using</span></td></tr>
      <tr><td class="lblock">       * tm_node <span class="delete">as their destination.</span></td><td> </td><td class="rblock"><span class="insert">        * the odp_tm_node_context() call.</span> */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock">       <span class="insert">void *user_context;</span></td></tr>
      <tr><td class="lblock">       <span class="delete">uint32_t max_fanin;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0058" /></td></tr>
      <tr><td class="lblock">       <span class="delete">/**&gt; @todo uint8_t num_priorities; ?</span> */</td><td> </td><td class="rblock">       <span class="insert">/** The max_fanin sets the maximum number of src tm_queues and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * producer tm_nodes that can be simultaneously be connected to this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * tm_node as their destination.</span> */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">       <span class="insert">uint32_t max_fanin;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0059" /></td></tr>
      <tr><td class="lblock">       /** The shaper profile to be associated with this tm_node.  Can be</td><td> </td><td class="rblock">       /** The shaper profile to be associated with this tm_node.  Can be</td></tr>
      <tr><td class="lblock">       * ODP_TM_INVALID and can also be set and changed post-creation via</td><td> </td><td class="rblock">        * ODP_TM_INVALID and can also be set and changed post-creation via</td></tr>
      <tr><td class="lblock">       * odp_tm_node_shaper_config();</td><td> </td><td class="rblock">        * odp_tm_node_shaper_config(); */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_tm_shaper_t shaper_profile;</td><td> </td><td class="right">       odp_tm_shaper_t shaper_profile;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0060" /></td></tr>
      <tr><td class="lblock">       /** The threshold profile to be used in setting the max queue fullne</td><td> </td><td class="rblock">       /** The threshold profile to be used in setting the max queue fullne</td></tr>
      <tr><td class="lblock">ss</td><td> </td><td class="rblock">ss</td></tr>
      <tr><td class="lblock">       * for WRED and/or tail drop?  Can be ODP_TM_INVALID and can also be</td><td> </td><td class="rblock">        * for WRED and/or tail drop?  Can be ODP_TM_INVALID and can also be</td></tr>
      <tr><td class="lblock">       * set and changed post-creation via odp_tm_node_threshold_config().</td><td> </td><td class="rblock">        * set and changed post-creation via odp_tm_node_threshold_config().</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"> */</td></tr>
      <tr><td class="left">       odp_tm_threshold_t threshold_profile;</td><td> </td><td class="right">       odp_tm_threshold_t threshold_profile;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0061" /></td></tr>
      <tr><td class="lblock">       /** The WRED profile(s) to be associated with this tm_node.  Any or</td><td> </td><td class="rblock">       /** The WRED profile(s) to be associated with this tm_node.  Any or</td></tr>
      <tr><td class="lblock">       * all array elements can be ODP_TM_INVALID and can also be set and</td><td> </td><td class="rblock">        * all array elements can be ODP_TM_INVALID and can also be set and</td></tr>
      <tr><td class="lblock">       * changed post-creation via odp_tm_node_wred_config().</td><td> </td><td class="rblock">        * changed post-creation via odp_tm_node_wred_config(). */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_tm_wred_t wred_profile[ODP_NUM_PACKET_COLORS];</td><td> </td><td class="right">       odp_tm_wred_t wred_profile[ODP_NUM_PACKET_COLORS];</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0062" /></td></tr>
      <tr><td class="lblock">       /** The level (or tm_node stage) sets the level for this tm_node It</td><td> </td><td class="rblock">       /** The level (or tm_node stage) sets the level for this tm_node It</td></tr>
      <tr><td class="lblock">       * must be in range 0..max_levels-1.  Note that the tm_node topology</td><td> </td><td class="rblock">        * must be in range 0..max_levels-1.  Note that the tm_node topology</td></tr>
      <tr><td class="lblock">       * is constrained such that only tm_node outputs with numerically</td><td> </td><td class="rblock">        * is constrained such that only tm_node outputs with numerically</td></tr>
      <tr><td class="lblock">       * greater levels may be connected to the fan-in of tm_node's with</td><td> </td><td class="rblock">        * greater levels may be connected to the fan-in of tm_node's with</td></tr>
      <tr><td class="lblock">       * numerically smaller levels.</td><td> </td><td class="rblock">        * numerically smaller levels. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint8_t level;</td><td> </td><td class="right">       uint8_t level;</td></tr>
      <tr><td class="left">} odp_tm_node_params_t;</td><td> </td><td class="right">} odp_tm_node_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_node_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_node_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_node_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_node_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to an odp_tm_node_params_t record which</td><td> </td><td class="right"> * @param[in] params  A pointer to an odp_tm_node_params_t record which</td></tr>
      <tr><td class="left"> *                    is to be initialized.</td><td> </td><td class="right"> *                    is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_node_params_init(odp_tm_node_params_t *params);</td><td> </td><td class="right">void odp_tm_node_params_init(odp_tm_node_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l10" /><small>skipping to change at</small><em> line 904</em></th><th> </th><th><a name="part-r10" /><small>skipping to change at</small><em> line 1254</em></th></tr>
      <tr><td class="left"> * creation.  The level parameter MUST be in the range 0..max_level - 1.</td><td> </td><td class="right"> * creation.  The level parameter MUST be in the range 0..max_level - 1.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] odp_tm  Odp_tm is used to identify the TM system into which t
his</td><td> </td><td class="right"> * @param[in] odp_tm  Odp_tm is used to identify the TM system into which t
his</td></tr>
      <tr><td class="left"> *                    odp_tm_node object is created.</td><td> </td><td class="right"> *                    odp_tm_node object is created.</td></tr>
      <tr><td class="left"> * @param[in] name    Optional name that can be used later later to find th
is</td><td> </td><td class="right"> * @param[in] name    Optional name that can be used later later to find th
is</td></tr>
      <tr><td class="left"> *                    same odp_tm_node_t.  Can be NULL, otherwise must be</td><td> </td><td class="right"> *                    same odp_tm_node_t.  Can be NULL, otherwise must be</td></tr>
      <tr><td class="left"> *                    unique across all odp_tm_node objects.</td><td> </td><td class="right"> *                    unique across all odp_tm_node objects.</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to a record holding (an extensible) set of</td><td> </td><td class="right"> * @param[in] params  A pointer to a record holding (an extensible) set of</td></tr>
      <tr><td class="left"> *                    properties/attributes of this tm_node.</td><td> </td><td class="right"> *                    properties/attributes of this tm_node.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, otherwise return
s</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, otherwise return
s</td></tr>
      <tr><td><a name="diff0063" /></td></tr>
      <tr><td class="lblock"> *                    a valid odp_tm_node_t handleif successful.</td><td> </td><td class="rblock"> *                    a valid odp_tm_node_t handle<span class="insert"> </span>if successful.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0064" /></td></tr>
      <tr><td class="lblock">odp_tm_node_t odp_tm_node_create(odp_tm_t odp_tm, const char *name,</td><td> </td><td class="rblock">odp_tm_node_t odp_tm_node_create(odp_tm_t              odp_tm,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                const char           *name,</td></tr>
      <tr><td class="left">                                odp_tm_node_params_t *params);</td><td> </td><td class="right">                                odp_tm_node_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0065" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Destroy  a tm_node object.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_node_destroy frees the resources used by a tm_node_t object.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The tm_node to be destroyed MUST not have any parent or child entities.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_node  Specifies the tm_node to be destroyed (freed).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return             Returns -1 upon failure, 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_node_destroy(odp_tm_node_t tm_node);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** The odp_tm_node_shaper_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_node_shaper_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the shaper profile associated with this tm_node.</td><td> </td><td class="right"> * change the shaper profile associated with this tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_node         Specifies the tm_node to be changed.</td><td> </td><td class="right"> * @param[in] tm_node         Specifies the tm_node to be changed.</td></tr>
      <tr><td class="left"> * @param[in] shaper_profile  Specifies the shaper profile that should</td><td> </td><td class="right"> * @param[in] shaper_profile  Specifies the shaper profile that should</td></tr>
      <tr><td class="left"> *                            now be used for the shaper entity within the</td><td> </td><td class="right"> *                            now be used for the shaper entity within the</td></tr>
      <tr><td class="left"> *                            given tm_node.  Note that it is legal to spec
ify</td><td> </td><td class="right"> *                            given tm_node.  Note that it is legal to spec
ify</td></tr>
      <tr><td class="left"> *                            ODP_TM_INVALID indicating that this tm_node</td><td> </td><td class="right"> *                            ODP_TM_INVALID indicating that this tm_node</td></tr>
      <tr><td class="left"> *                            no longer implements a shaper function.</td><td> </td><td class="right"> *                            no longer implements a shaper function.</td></tr>
      <tr><td class="left"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_shaper_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_node_shaper_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                             odp_tm_shaper_t shaper_profile);</td><td> </td><td class="right">                             odp_tm_shaper_t shaper_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_node_sched_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_node_sched_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the scheduler profile associated with a tm_node.</td><td> </td><td class="right"> * change the scheduler profile associated with a tm_node.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_node         Specifies the tm_node to be changed.</td><td> </td><td class="right"> * @param[in] tm_node         Specifies the tm_node to be changed.</td></tr>
      <tr><td class="left"> * @param[in] tm_fan_in_node  Specifies which of the specified tm_node's</td><td> </td><td class="right"> * @param[in] tm_fan_in_node  Specifies which of the specified tm_node's</td></tr>
      <tr><td class="left"> *                            fan-in's weights etc are to be changed. The</td><td> </td><td class="right"> *                            fan-in's weights etc are to be changed. The</td></tr>
      <tr><td><a name="diff0066" /></td></tr>
      <tr><td class="lblock"> *                            fan-in is i<span class="delete">ndentified by the "producer"/paren
</span>t</td><td> </td><td class="rblock"> *                            fan-in is i<span class="insert">dentified by the "producer"/paren</span>t</td></tr>
      <tr><td class="left"> *                            tm_node actually connected to this fan-in.</td><td> </td><td class="right"> *                            tm_node actually connected to this fan-in.</td></tr>
      <tr><td class="left"> * @param[in] sched_profile   Specifies the scheduler profile that should</td><td> </td><td class="right"> * @param[in] sched_profile   Specifies the scheduler profile that should</td></tr>
      <tr><td class="left"> *                            now be used for the WFQ/RR entity within the</td><td> </td><td class="right"> *                            now be used for the WFQ/RR entity within the</td></tr>
      <tr><td class="left"> *                            given tm_node.</td><td> </td><td class="right"> *                            given tm_node.</td></tr>
      <tr><td class="left"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_sched_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_node_sched_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                            odp_tm_node_t tm_fan_in_node,</td><td> </td><td class="right">                            odp_tm_node_t tm_fan_in_node,</td></tr>
      <tr><td class="left">                            odp_tm_sched_t sched_profile);</td><td> </td><td class="right">                            odp_tm_sched_t sched_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l11" /><small>skipping to change at</small><em> line 982</em></th><th> </th><th><a name="part-r11" /><small>skipping to change at</small><em> line 1343</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] odp_tm  Odp_tm is used to identify the TM system into which t
his</td><td> </td><td class="right"> * @param[in] odp_tm  Odp_tm is used to identify the TM system into which t
his</td></tr>
      <tr><td class="left"> *                    odp_tm_node object is created.</td><td> </td><td class="right"> *                    odp_tm_node object is created.</td></tr>
      <tr><td class="left"> * @param[in] name    Name of a previously created tm_node.  Cannot be</td><td> </td><td class="right"> * @param[in] name    Name of a previously created tm_node.  Cannot be</td></tr>
      <tr><td class="left"> *                    NULL.</td><td> </td><td class="right"> *                    NULL.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, or the tm_node</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, or the tm_node</td></tr>
      <tr><td class="left"> *                    handle created with this name.</td><td> </td><td class="right"> *                    handle created with this name.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_node_t odp_tm_node_lookup(odp_tm_t odp_tm, const char *name);</td><td> </td><td class="right">odp_tm_node_t odp_tm_node_lookup(odp_tm_t odp_tm, const char *name);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0067" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** odp_tm_node_context() can be used to get the user_context value that is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * associated with the given tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_node Specifies the tm_node whose user_context is to be got</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ten.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return            Returns the user_context pointer associated with this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                    tm_node.  Returns NULL if the tm_node is not valid OR</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                    if the user_context was NLL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                    handle created with this name.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void *odp_tm_node_context(odp_tm_node_t tm_node);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** odp_tm_node_context_set() can be used to set the user_context value tha</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * associated with the given tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_node Specifies the tm_node whose user_context is to be set</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] user_context  Generic pointer associated with the given tm_no</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">de.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          Does not have any effect on the tm_node semanti</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">cs.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                  Returns 0 upon success and -1 if the given tm_n</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ode</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          is not valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_node_context_set(odp_tm_node_t tm_node, void *user_context);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** The odp_tm_queue_params_t record type is used to hold extra parameters</td><td> </td><td class="right">/** The odp_tm_queue_params_t record type is used to hold extra parameters</td></tr>
      <tr><td class="left"> * when calling the odp_tm_queue_create() function.  Many of these fields a
re</td><td> </td><td class="right"> * when calling the odp_tm_queue_create() function.  Many of these fields a
re</td></tr>
      <tr><td class="left"> * optional EXCEPT for priority.  Also since it is expected that</td><td> </td><td class="right"> * optional EXCEPT for priority.  Also since it is expected that</td></tr>
      <tr><td class="left"> * implementations might augment this record type with platform specific</td><td> </td><td class="right"> * implementations might augment this record type with platform specific</td></tr>
      <tr><td class="left"> * additional fields - it is required that odp_tm_queue_params_init() be</td><td> </td><td class="right"> * additional fields - it is required that odp_tm_queue_params_init() be</td></tr>
      <tr><td class="left"> * called on variables of this type before any of the fields are filled in.</td><td> </td><td class="right"> * called on variables of this type before any of the fields are filled in.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0068" /></td></tr>
      <tr><td class="lblock">       /** The shaper profile to be associated with this tm_queue.  Can be</td><td> </td><td class="rblock">       /** The <span class="insert">user_context field is an generic pointer that the user can</span></td></tr>
      <tr><td class="lblock">       * ODP_TM_INVALID and can also be set and changed post-creation via</td><td> </td><td class="rblock"><span class="insert">        * associate with a tm_queue and then get this same value back using</span></td></tr>
      <tr><td class="lblock">       * <span class="delete">odp_tm_queue_shaper_config();</span></td><td> </td><td class="rblock"><span class="insert">        * the odp_tm_queue_context() call. */</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"><span class="insert">       void *user_context;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The</span> shaper profile to be associated with this tm_queue.  Can be</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * ODP_TM_INVALID and can also be set and changed post-creation via</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * <span class="insert">odp_tm_queue_shaper_config().</span> */</td></tr>
      <tr><td class="left">       odp_tm_shaper_t shaper_profile;</td><td> </td><td class="right">       odp_tm_shaper_t shaper_profile;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0069" /></td></tr>
      <tr><td class="lblock">       /** The threshold profile to be used in setting the max queue fullne</td><td> </td><td class="rblock">       /** The threshold profile to be used in setting the max queue fullne</td></tr>
      <tr><td class="lblock">ss</td><td> </td><td class="rblock">ss</td></tr>
      <tr><td class="lblock">       * for WRED and/or tail drop?  Can be ODP_TM_INVALID and can also be</td><td> </td><td class="rblock">        * for WRED and/or tail drop?  Can be ODP_TM_INVALID and can also be</td></tr>
      <tr><td class="lblock">       * set and changed post-creation via <span class="delete">odp_tm_queue_threshold_config().</span></td><td> </td><td class="rblock">        * set and changed post-creation via <span class="insert">odp_tm_queue_threshold_config()</span></td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"><span class="insert">.</span> */</td></tr>
      <tr><td class="left">       odp_tm_threshold_t threshold_profile;</td><td> </td><td class="right">       odp_tm_threshold_t threshold_profile;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0070" /></td></tr>
      <tr><td class="lblock">       /** The WRED profile(s) to be associated with this tm_queue.  Any or</td><td> </td><td class="rblock">       /** The WRED profile(s) to be associated with this tm_queue.  Any or</td></tr>
      <tr><td class="lblock">       * all array elements can be ODP_TM_INVALID and can also be set and</td><td> </td><td class="rblock">        * all array elements can be ODP_TM_INVALID and can also be set and</td></tr>
      <tr><td class="lblock">       * changed post-creation via odp_tm_queue_wred_config().</td><td> </td><td class="rblock">        * changed post-creation via odp_tm_queue_wred_config(). */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_tm_wred_t wred_profile[ODP_NUM_PACKET_COLORS];</td><td> </td><td class="right">       odp_tm_wred_t wred_profile[ODP_NUM_PACKET_COLORS];</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0071" /></td></tr>
      <tr><td class="lblock">       /** The strict priority level assigned to packets in this tm_queue -</td><td> </td><td class="rblock">       /** The strict priority level assigned to packets in this tm_queue -</td></tr>
      <tr><td class="lblock">       * in other words all packets associated with a given tm_queue MUST</td><td> </td><td class="rblock">        * in other words all packets associated with a given tm_queue MUST</td></tr>
      <tr><td class="lblock">       * have the same single strict priority level and this level must be</td><td> </td><td class="rblock">        * have the same single strict priority level and this level must be</td></tr>
      <tr><td class="lblock">       * in the range 0..max_priority.</td><td> </td><td class="rblock">        * in the range 0..max_priority. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint8_t priority;</td><td> </td><td class="right">       uint8_t priority;</td></tr>
      <tr><td class="left">} odp_tm_queue_params_t;</td><td> </td><td class="right">} odp_tm_queue_params_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** odp_tm_queue_params_init() must be called to initialize any</td><td> </td><td class="right">/** odp_tm_queue_params_init() must be called to initialize any</td></tr>
      <tr><td class="left"> * odp_tm_queue_params_t record before it is first used or assigned to.</td><td> </td><td class="right"> * odp_tm_queue_params_t record before it is first used or assigned to.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to an odp_tm_queue_params_t record which</td><td> </td><td class="right"> * @param[in] params  A pointer to an odp_tm_queue_params_t record which</td></tr>
      <tr><td class="left"> *                    is to be initialized.</td><td> </td><td class="right"> *                    is to be initialized.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">void odp_tm_queue_params_init(odp_tm_queue_params_t *params);</td><td> </td><td class="right">void odp_tm_queue_params_init(odp_tm_queue_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l12" /><small>skipping to change at</small><em> line 1042</em></th><th> </th><th><a name="part-r12" /><small>skipping to change at</small><em> line 1426</em></th></tr>
      <tr><td class="left"> * @param[in] odp_tm  Odp_tm is used to identify the TM system into which t
his</td><td> </td><td class="right"> * @param[in] odp_tm  Odp_tm is used to identify the TM system into which t
his</td></tr>
      <tr><td class="left"> *                    odp_tm_queue object is created.</td><td> </td><td class="right"> *                    odp_tm_queue object is created.</td></tr>
      <tr><td class="left"> * @param[in] params  A pointer to a record holding (an extensible) set of</td><td> </td><td class="right"> * @param[in] params  A pointer to a record holding (an extensible) set of</td></tr>
      <tr><td class="left"> *                    properties/attributes of this tm_queue.</td><td> </td><td class="right"> *                    properties/attributes of this tm_queue.</td></tr>
      <tr><td class="left"> * @return            Returns ODP_TM_INVALID upon failure, otherwise a vali
d</td><td> </td><td class="right"> * @return            Returns ODP_TM_INVALID upon failure, otherwise a vali
d</td></tr>
      <tr><td class="left"> *                    odp_tm_queue_t handle.</td><td> </td><td class="right"> *                    odp_tm_queue_t handle.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">odp_tm_queue_t odp_tm_queue_create(odp_tm_t odp_tm,</td><td> </td><td class="right">odp_tm_queue_t odp_tm_queue_create(odp_tm_t odp_tm,</td></tr>
      <tr><td class="left">                                  odp_tm_queue_params_t *params);</td><td> </td><td class="right">                                  odp_tm_queue_params_t *params);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0072" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Destroy an tm_queue object. The odp_tm_queue_destroy frees the resource</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * used by a tm_queue_t object.  The tm_queue to be destroyed MUST not be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * connected in a tm system, and consequently cannot contain any pkts.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_queue  Specifies the tm_queue to be destroyed (freed).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return              Returns -1 upon failure, 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_queue_destroy(odp_tm_queue_t tm_queue);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** odp_tm_queue_context() can be used to get the user_context value that i</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * associated with the given tm_queue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_queue  Specifies the tm_queue whose user_context is to be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      returned.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return              Returns the user_context pointer associated with th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      tm_queue.  Returns NULL if the tm_quue is not valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> OR</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      if the user_context was NULL.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">void *odp_tm_queue_context(odp_tm_queue_t tm_queue);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** odp_tm_queue_context_set() can be used to set the user_context value th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">at is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * associated with the given tm_queue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_queue      Specifies the tm_queue whose user_context is to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          set.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] user_context  Generic pointer associated with the given tm_qu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">eue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          Does not have any effect on the tm_queue semant</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ics.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                  Returns 0 upon success and -1 if the given tm_q</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ueu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                          is not valid.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_queue_context_set(odp_tm_queue_t tm_queue, void *user_context);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** The odp_tm_queue_shaper_config() function is used to dynamically set</td><td> </td><td class="right">/** The odp_tm_queue_shaper_config() function is used to dynamically set</td></tr>
      <tr><td class="left"> * or change the shaper profile associated with this tm_queue.</td><td> </td><td class="right"> * or change the shaper profile associated with this tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_queue        Specifies the tm_queue to be changed.</td><td> </td><td class="right"> * @param[in] tm_queue        Specifies the tm_queue to be changed.</td></tr>
      <tr><td class="left"> * @param[in] shaper_profile  Specifies the shaper profile that should now 
be</td><td> </td><td class="right"> * @param[in] shaper_profile  Specifies the shaper profile that should now 
be</td></tr>
      <tr><td class="left"> *                            used for shaping the tm_queue's packet stream
.</td><td> </td><td class="right"> *                            used for shaping the tm_queue's packet stream
.</td></tr>
      <tr><td class="left"> *                            Note that it is legal to specify ODP_TM_INVAL
ID</td><td> </td><td class="right"> *                            Note that it is legal to specify ODP_TM_INVAL
ID</td></tr>
      <tr><td class="left"> *                            indicating that this tm_queue no longer</td><td> </td><td class="right"> *                            indicating that this tm_queue no longer</td></tr>
      <tr><td class="left"> *                            implements a shaper function.</td><td> </td><td class="right"> *                            implements a shaper function.</td></tr>
      <tr><td class="left"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l13" /><small>skipping to change at</small><em> line 1064</em></th><th> </th><th><a name="part-r13" /><small>skipping to change at</small><em> line 1480</em></th></tr>
      <tr><td class="left">                              odp_tm_shaper_t shaper_profile);</td><td> </td><td class="right">                              odp_tm_shaper_t shaper_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_sched_config() function is used to dynamically set or</td><td> </td><td class="right">/** The odp_tm_queue_sched_config() function is used to dynamically set or</td></tr>
      <tr><td class="left"> * change the scheduler profile associated with a tm_node.  Note that despi
te</td><td> </td><td class="right"> * change the scheduler profile associated with a tm_node.  Note that despi
te</td></tr>
      <tr><td class="left"> * the name, this function affects a tm_node scheduler - specifically the</td><td> </td><td class="right"> * the name, this function affects a tm_node scheduler - specifically the</td></tr>
      <tr><td class="left"> * scheduler fan-in when such fan-in comes from an tm_queue.</td><td> </td><td class="right"> * scheduler fan-in when such fan-in comes from an tm_queue.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_node         Specifies the tm_node to be changed.</td><td> </td><td class="right"> * @param[in] tm_node         Specifies the tm_node to be changed.</td></tr>
      <tr><td class="left"> * @param[in] tm_fan_in_queue Specifies which of the specified tm_node's</td><td> </td><td class="right"> * @param[in] tm_fan_in_queue Specifies which of the specified tm_node's</td></tr>
      <tr><td class="left"> *                            fan-in's weights etc are to be changed. The</td><td> </td><td class="right"> *                            fan-in's weights etc are to be changed. The</td></tr>
      <tr><td><a name="diff0073" /></td></tr>
      <tr><td class="lblock"> *                            fan-in is i<span class="delete">ndentified by the "producer"/paren
</span>t</td><td> </td><td class="rblock"> *                            fan-in is i<span class="insert">dentified by the "producer"/paren</span>t</td></tr>
      <tr><td class="left"> *                            tm_queue actually connected to this fan-in.</td><td> </td><td class="right"> *                            tm_queue actually connected to this fan-in.</td></tr>
      <tr><td class="left"> * @param[in] sched_profile   Specifies the scheduler profile that should</td><td> </td><td class="right"> * @param[in] sched_profile   Specifies the scheduler profile that should</td></tr>
      <tr><td class="left"> *                            now be used for the WFQ/RR entity within the</td><td> </td><td class="right"> *                            now be used for the WFQ/RR entity within the</td></tr>
      <tr><td class="left"> *                            given tm_node.</td><td> </td><td class="right"> *                            given tm_node.</td></tr>
      <tr><td class="left"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                    Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_sched_config(odp_tm_node_t tm_node,</td><td> </td><td class="right">int odp_tm_queue_sched_config(odp_tm_node_t tm_node,</td></tr>
      <tr><td class="left">                             odp_tm_queue_t tm_fan_in_queue,</td><td> </td><td class="right">                             odp_tm_queue_t tm_fan_in_queue,</td></tr>
      <tr><td class="left">                             odp_tm_sched_t sched_profile);</td><td> </td><td class="right">                             odp_tm_sched_t sched_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l14" /><small>skipping to change at</small><em> line 1107</em></th><th> </th><th><a name="part-r14" /><small>skipping to change at</small><em> line 1523</em></th></tr>
      <tr><td class="left"> *                          indicating that this tm_queue/pkt_color combina
tion</td><td> </td><td class="right"> *                          indicating that this tm_queue/pkt_color combina
tion</td></tr>
      <tr><td class="left"> *                          no longer implements WRED.</td><td> </td><td class="right"> *                          no longer implements WRED.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_wred_config(odp_tm_queue_t tm_queue,</td><td> </td><td class="right">int odp_tm_queue_wred_config(odp_tm_queue_t tm_queue,</td></tr>
      <tr><td class="left">                            odp_packet_color_t pkt_color,</td><td> </td><td class="right">                            odp_packet_color_t pkt_color,</td></tr>
      <tr><td class="left">                            odp_tm_wred_t wred_profile);</td><td> </td><td class="right">                            odp_tm_wred_t wred_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** Topology setting functions */</td><td> </td><td class="right">/** Topology setting functions */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0074" /></td></tr>
      <tr><td class="lblock">/** Connects the "output" of the src_tm_node to be a "producer" of the <span class="delete">give</span></td><td> </td><td class="rblock">/** Connects <span class="insert">two tm_nodes</span></td></tr>
      <tr><td class="lblock"><span class="delete">n</span></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Connects</span> the "output" of the src_tm_node to be a "producer" of the <span class="insert">given</span></td></tr>
      <tr><td class="left"> * dst_tm_node.  Note that an ODP_TM_ROOT handle passed in for the</td><td> </td><td class="right"> * dst_tm_node.  Note that an ODP_TM_ROOT handle passed in for the</td></tr>
      <tr><td class="left"> * dst_tm_node implies connection to the egress/root object of this TM syst
em.</td><td> </td><td class="right"> * dst_tm_node implies connection to the egress/root object of this TM syst
em.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] src_tm_node  odp_tm_node_t handle of the tm_node whose output
 is</td><td> </td><td class="right"> * @param[in] src_tm_node  odp_tm_node_t handle of the tm_node whose output
 is</td></tr>
      <tr><td class="left"> *                         to be connected to the fan-in of the next tm_nod
e</td><td> </td><td class="right"> *                         to be connected to the fan-in of the next tm_nod
e</td></tr>
      <tr><td class="left"> *                         as represented by the dst_tm_node.</td><td> </td><td class="right"> *                         as represented by the dst_tm_node.</td></tr>
      <tr><td class="left"> * @param[in] dst_tm_node  odp_tm_node_t handle of the tm_node object that 
will</td><td> </td><td class="right"> * @param[in] dst_tm_node  odp_tm_node_t handle of the tm_node object that 
will</td></tr>
      <tr><td class="left"> *                         receive all of the pkt_descs from the src tm_nod
e</td><td> </td><td class="right"> *                         receive all of the pkt_descs from the src tm_nod
e</td></tr>
      <tr><td class="left"> *                         output.  If ODP_TM_ROOT, then attachment is to</td><td> </td><td class="right"> *                         output.  If ODP_TM_ROOT, then attachment is to</td></tr>
      <tr><td class="left"> *                         the root egress object/spigot.</td><td> </td><td class="right"> *                         the root egress object/spigot.</td></tr>
      <tr><td class="left"> * @return                 0 upon success, &lt; 0 on failure.</td><td> </td><td class="right"> * @return                 0 upon success, &lt; 0 on failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_node_connect(odp_tm_node_t src_tm_node, odp_tm_node_t dst_tm_nod
e);</td><td> </td><td class="right">int odp_tm_node_connect(odp_tm_node_t src_tm_node, odp_tm_node_t dst_tm_nod
e);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0075" /></td></tr>
      <tr><td class="lblock">/** The <span class="delete">odp_queue_connect()</span> function connects the indicated tm_queue to a</td><td> </td><td class="rblock">/** <span class="insert">Disconnect a tm_node to tm_node linkage.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span> The <span class="insert">odp_tm_node_disconnect() function is used to disconnect a given</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * tm_node from its fanout.  This function requires that no active, enabled</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * tm_queue to be in the fanin tree (directly or indirectly) of this tm_nod</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that it is legal for this tm_node to no fanout connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] src_tm_node  odp_tm_node_t handle of the tm_node whose output</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                         to be disconnected from the fan-in of the next</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                         tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                 0 upon success, &lt; 0 on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_node_disconnect(odp_tm_node_t src_tm_node);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The odp_tm_queue_connect()</span> function connects the indicated tm_queue to </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">a</td></tr>
      <tr><td class="left"> * parent tm_node or to the egress/root node.  The tm_queue will then becom
e</td><td> </td><td class="right"> * parent tm_node or to the egress/root node.  The tm_queue will then becom
e</td></tr>
      <tr><td class="left"> * one of the dst node's fan-in set.</td><td> </td><td class="right"> * one of the dst node's fan-in set.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_queue     Specifies the tm_queue.</td><td> </td><td class="right"> * @param[in] tm_queue     Specifies the tm_queue.</td></tr>
      <tr><td class="left"> * @param[in] dst_tm_node  odp_tm_node_t handle of the tm_node object that 
will</td><td> </td><td class="right"> * @param[in] dst_tm_node  odp_tm_node_t handle of the tm_node object that 
will</td></tr>
      <tr><td class="left"> *                         receive all of the pkt_descs from the src tm_nod
e</td><td> </td><td class="right"> *                         receive all of the pkt_descs from the src tm_nod
e</td></tr>
      <tr><td class="left"> *                         output.  If ODP_TM_ROOT, then attachment is to</td><td> </td><td class="right"> *                         output.  If ODP_TM_ROOT, then attachment is to</td></tr>
      <tr><td class="left"> *                         the root egress object/spigot.</td><td> </td><td class="right"> *                         the root egress object/spigot.</td></tr>
      <tr><td class="left"> * @return                 Returns 0 upon success and &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                 Returns 0 upon success and &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_queue_connect(odp_tm_queue_t tm_queue, odp_tm_node_t dst_tm_node
);</td><td> </td><td class="right">int odp_tm_queue_connect(odp_tm_queue_t tm_queue, odp_tm_node_t dst_tm_node
);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0076" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Disconnect a tm_queue from a tm_system.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_queue_disconnect() function is used to disconnect a given</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * tm_queue from its fanout. Note that it is legal for this tm_queue to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * have no fanout connection.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in] tm_queue     Specifies the tm_queue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                 0 upon success, &lt; 0 on failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_queue_disconnect(odp_tm_queue_t tm_queue);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** Input API */</td><td> </td><td class="right">/** Input API */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_enq() function is used to add packets to a given TM system.</td><td> </td><td class="right">/** The odp_tm_enq() function is used to add packets to a given TM system.</td></tr>
      <tr><td class="left"> * Note that the System Metadata associated with the pkt needed by the TM</td><td> </td><td class="right"> * Note that the System Metadata associated with the pkt needed by the TM</td></tr>
      <tr><td class="left"> * system is (a) a drop_eligible bit, (b) a two bit "pkt_color", (c) a 16-b
it</td><td> </td><td class="right"> * system is (a) a drop_eligible bit, (b) a two bit "pkt_color", (c) a 16-b
it</td></tr>
      <tr><td class="left"> * pkt_len, and MAYBE? (d) a signed 8-bit shaper_len_adjust.</td><td> </td><td class="right"> * pkt_len, and MAYBE? (d) a signed 8-bit shaper_len_adjust.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * If there is a non-zero shaper_len_adjust, then it is added to the pkt_le
n</td><td> </td><td class="right"> * If there is a non-zero shaper_len_adjust, then it is added to the pkt_le
n</td></tr>
      <tr><td class="left"> * after any non-zero shaper_len_adjust that is part of the shaper profile.</td><td> </td><td class="right"> * after any non-zero shaper_len_adjust that is part of the shaper profile.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * The pkt_color bits are a result of some earlier Metering/Marking/Policin
g</td><td> </td><td class="right"> * The pkt_color bits are a result of some earlier Metering/Marking/Policin
g</td></tr>
      <tr><td class="left"> * processing (typically ingress based), and should not be confused with th
e</td><td> </td><td class="right"> * processing (typically ingress based), and should not be confused with th
e</td></tr>
      <tr><td class="left"> * shaper_color produced from the TM shaper entities within the tm_inputs a
nd</td><td> </td><td class="right"> * shaper_color produced from the TM shaper entities within the tm_inputs a
nd</td></tr>
      <tr><td class="left"> * tm_nodes.</td><td> </td><td class="right"> * tm_nodes.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_queue  Specifies the tm_queue (and indirectly the TM syste
m).</td><td> </td><td class="right"> * @param[in] tm_queue  Specifies the tm_queue (and indirectly the TM syste
m).</td></tr>
      <tr><td class="left"> * @param[in] pkt       Handle to a packet.</td><td> </td><td class="right"> * @param[in] pkt       Handle to a packet.</td></tr>
      <tr><td class="left"> * @return              Returns 0 upon success, &lt; 0 upon failure. One of th
e</td><td> </td><td class="right"> * @return              Returns 0 upon success, &lt; 0 upon failure. One of th
e</td></tr>
      <tr><td><a name="diff0077" /></td></tr>
      <tr><td class="lblock"> *                      more common failure reasons is WRED drop<span class="delete">age</span>.</td><td> </td><td class="rblock"> *                      more common failure reasons is WRED drop.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_enq(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td><td> </td><td class="right">int odp_tm_enq(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_enq_with_cnt() function behaves identically to odp_tm_enq(),</td><td> </td><td class="right">/** The odp_tm_enq_with_cnt() function behaves identically to odp_tm_enq(),</td></tr>
      <tr><td class="left"> * except that it also returns (an approximation to?) the current tm_queue</td><td> </td><td class="right"> * except that it also returns (an approximation to?) the current tm_queue</td></tr>
      <tr><td class="left"> * packet queue count.</td><td> </td><td class="right"> * packet queue count.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] tm_queue  Specifies the tm_queue (and indirectly the TM syste
m).</td><td> </td><td class="right"> * @param[in] tm_queue  Specifies the tm_queue (and indirectly the TM syste
m).</td></tr>
      <tr><td class="left"> * @param[in] pkt       Handle to a packet.</td><td> </td><td class="right"> * @param[in] pkt       Handle to a packet.</td></tr>
      <tr><td class="left"> * @return              Returns the number of packets previously enqueued o
n</td><td> </td><td class="right"> * @return              Returns the number of packets previously enqueued o
n</td></tr>
      <tr><td class="left"> *                      this tm_queue upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> *                      this tm_queue upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_enq_with_cnt(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td><td> </td><td class="right">int odp_tm_enq_with_cnt(odp_tm_queue_t tm_queue, odp_packet_t pkt);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0078" /></td></tr>
      <tr><td class="lblock"><span class="delete">/**</span> Dynamic state query functions */</td><td> </td><td class="rblock"><span class="insert">/*</span> Dynamic state query functions */</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The odp_tm_node_info_t record type  is used to return various bits of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * information about a given tm_node via the odp_tm_node_info() function.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The shaper profile currently associated with this tm_node.  Can </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * ODP_TM_INVALID indicating no shaper profile is associated. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_shaper_t shaper_profile;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The threshold profile currently associated with this tm_node.  C</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">an</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * be ODP_TM_INVALID indicating no threshold profile is associated. </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_threshold_t threshold_profile;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The WRED profile(s) currently associated with this tm_node.  Any</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * or all array elements can be ODP_TM_INVALID indicating no WRED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * profile is associated  with this tm_node/ color combination. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_wred_t wred_profile[ODP_NUM_PACKET_COLORS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Current tm_queue fanin. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t tm_queue_fanin;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** Current tm_node fanin. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint32_t tm_node_fanin;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The next_tm_node is the "next" node in the tree - i.e. the fanou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * of this node.  Can be ODP_TM_ROOT if this tm_node directly connec</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ts</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * to the egress spigot and can be ODP_TM_INVALID if this tm_node is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * disconnected from the TM system tree, */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_node_t next_tm_node;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The level of this tm_node.  Note that this value cannot be modif</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ied</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * after a tm_node has been created, */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       uint8_t level;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_tm_node_info_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Get tm_node Info</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_node_info() function is used to extract various bits of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * configuration associated with a given tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in]  tm_node  Specifies the tm_node to be queried.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] info     A pointer to an odp_tm_node_info_t record that is t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                      be filled in by this call.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return              Returns &lt; 0 upon failure, 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_node_info(odp_tm_node_t tm_node, odp_tm_node_info_t *info);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The odp_tm_node_fanin_info_t record type is used to return various bits</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * information about a given "link"/"connection"/"fanin" between a tm_queue</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * and a tm_node OR between a tm_node and a tm_node,  It is also used as th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * state needed to implement an iterator that walks the complete fanin list</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * of a given tm_node.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The sched profile currently associated with this fanin link.  Th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * can be ODP_TM_INVALID indicating no sched profile is associated. </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_sched_t sched_profile;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The tm_queue indicates the "producer" of this fanin. Note that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * that at most one of tm_queue and tm_node can be valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * here (i.e. not equal to ODP_TM_INVALID). */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_queue_t tm_queue;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The tm_node indicates the "producer" of this fanin. Note that</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * that at most one of tm_queue and tm_node can be valid</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * here (i.e. not equal to ODP_TM_INVALID). */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_node_t tm_node;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The is_last flag is set when the tm_queue/tm_node above is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * currently the last element in the fanin list. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_bool_t is_last;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_tm_node_fanin_info_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Get tm_node Fanin Info</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_node_fanin_info() function is used to extract various bits of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * configuration associated with a given tm_node's fanin.  It can also be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * used to walk the complete fanin list of a given tm_node.  Note in partic</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ular</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * that the odp_tm_node_fanin_info_t record passed to this function is both</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * an input AND output parameter.  The semantics are that the application</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * first clears the tm_queue, tm_node and is_last fields (to TM_ODP_INVALID</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * TM_ODP_INVALID and false respectively) before making its first call to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odp_tm_node_fanin_info().  The fact that tm_queue and tm_node are both</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * TM_ODP_INVALID indicates that the caller wants the FIRST entry in the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * given tm_node's fanin list.  It will then update either the tm_queue or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * tm_node field in the info record with this first entry.  On subsequent c</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">alls</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * to this function, exactly one of the tm_queue or tm_node field will be !</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">=</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * TM_ODP_INVALID, and this function will then replace the tm_queue and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * tm_node fields with the NEXT entry in this tm_node's fanin list.  If thi</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * next entry is also the last entry then is_last will also be set.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that this function will fail (returning &lt; 0 code) if the incoming</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * is_last field is set.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * In general walking a fanin list while it is being changed (via _connect(</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">) or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * _disconnect() calls) is problematic - BUT as long as the incoming</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * tm_queue/tm_node values refer to entities that have not been disconnecte</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * from their fanin list, a reasonable list walk can occur - even while pas</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t or</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * future entries are being removed or while future entries are being added</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that all new additions to a fanin list always take place at the end</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the list.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in]  tm_node    Specifies the tm_node to be queried.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[inout] info     A pointer to an odp_tm_node_fanin_info_t record t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">hat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        is used to determine which fanin entry is to be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                        next filled in by this call.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return                Returns &lt; 0 upon failure, 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_node_fanin_info(odp_tm_node_t             tm_node,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                          odp_tm_node_fanin_info_t *info);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The odp_tm_queue_info_t record type  is used to return various bits of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * information about a given tm_queue via the odp_tm_queue_info() function.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef struct {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The shaper profile currently associated with this tm_queue.  Can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * ODP_TM_INVALID indicating no shaper profile is currently associat</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ed</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * with this tm_queue. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_shaper_t shaper_profile;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The threshold profile currently associated with this tm_queue.  </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * be ODP_TM_INVALID indicating no threshold profile is currently</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * associated with this tm_queue. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_threshold_t threshold_profile;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The WRED profile(s) currently associated with this tm_queue.  An</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * or all array elements can be ODP_TM_INVALID indicating no WRED</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * profile is currently associated  with this tm_queue/color</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * combination. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_wred_t wred_profile[ODP_NUM_PACKET_COLORS];</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The next_tm_node is the "next" node in the tree - i.e. the fanou</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * of this tm_queu.  Can be ODP_TM_ROOT if this tm_queue directly</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * connects to the egress spigot and can be ODP_TM_INVALID if this</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * tm_queue is disconnected from the TM system tree. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_tm_node_t next_tm_node;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       /** The active_pkt is the current packet "at the head of the queue"</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">        * that is being processed by this tm_queue. */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_packet_t active_pkt;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odp_tm_queue_info_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** Get tm_queue Info</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * The odp_tm_queue_info() function is used to extract various bits of</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * configuration associated with a given tm_queue.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[in]  tm_queue  Specifies the tm_queue to be queried.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param[out] info      A pointer to an odp_tm_queue_info_t record that is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> to</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                       be filled in by this call.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return               Returns &lt; 0 upon failure, 0 upon success.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odp_tm_queue_info(odp_tm_queue_t tm_queue, odp_tm_queue_info_t *info);</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The following bit mask constants are used to refine the queue query</td><td> </td><td class="right">/** The following bit mask constants are used to refine the queue query</td></tr>
      <tr><td class="left"> * functions defined below.</td><td> </td><td class="right"> * functions defined below.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_TM_QUERY_PKT_CNT     0x01   /**&lt;  The total_pkt_cnt value */</td><td> </td><td class="right">#define ODP_TM_QUERY_PKT_CNT     0x01   /**&lt;  The total_pkt_cnt value */</td></tr>
      <tr><td class="left">#define ODP_TM_QUERY_BYTE_CNT    0x02   /**&lt;  The total_byte_cnt value */</td><td> </td><td class="right">#define ODP_TM_QUERY_BYTE_CNT    0x02   /**&lt;  The total_byte_cnt value */</td></tr>
      <tr><td class="left">#define ODP_TM_QUERY_THRESHOLDS  0x04   /**&lt;  The thresholds??? */</td><td> </td><td class="right">#define ODP_TM_QUERY_THRESHOLDS  0x04   /**&lt;  The thresholds??? */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0079" /></td></tr>
      <tr><td class="lblock">/** The odp_tm_que<span class="delete">ue</span>_info_t record type is used to return the various count
s</td><td> </td><td class="rblock">/** The odp_tm_que<span class="insert">ry</span>_info_t record type is used to return the various count
s</td></tr>
      <tr><td class="left"> * as requested by functions like odp_tm_queue_query() and</td><td> </td><td class="right"> * as requested by functions like odp_tm_queue_query() and</td></tr>
      <tr><td class="left"> * odp_tm_total_query().</td><td> </td><td class="right"> * odp_tm_total_query().</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct {</td><td> </td><td class="right">typedef struct {</td></tr>
      <tr><td><a name="diff0080" /></td></tr>
      <tr><td class="lblock">       /** The total_pkt_cnt field is the total number of packets currently</td><td> </td><td class="rblock">       /** The total_pkt_cnt field is the total number of packets currently</td></tr>
      <tr><td class="lblock">       * stored/associated with the requested set of tm_queues.  Note that</td><td> </td><td class="rblock">        * stored/associated with the requested set of tm_queues.  Note that</td></tr>
      <tr><td class="lblock">       * because the packet queues are potentially being manipulated by</td><td> </td><td class="rblock">        * because the packet queues are potentially being manipulated by</td></tr>
      <tr><td class="lblock">       * multiple cpu's, the values here are only accurate when the tm</td><td> </td><td class="rblock">        * multiple cpu's, the values here are only accurate when the tm</td></tr>
      <tr><td class="lblock">       * system is "stopped" (i.e. the egress spigot is stopped and no</td><td> </td><td class="rblock">        * system is "stopped" (i.e. the egress spigot is stopped and no</td></tr>
      <tr><td class="lblock">       * odp_tm_enq calls are taking place).  Implementations are free to</td><td> </td><td class="rblock">        * odp_tm_enq calls are taking place).  Implementations are free to</td></tr>
      <tr><td class="lblock">       * batch update these counters - up to a dozen or so packets.</td><td> </td><td class="rblock">        * batch update these counters - up to a dozen or so packets. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint64_t total_pkt_cnt;</td><td> </td><td class="right">       uint64_t total_pkt_cnt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0081" /></td></tr>
      <tr><td class="lblock">       /** If the requested set of tm_queues has an odp_tm_threshold_t</td><td> </td><td class="rblock">       /** If the requested set of tm_queues has an odp_tm_threshold_t</td></tr>
      <tr><td class="lblock">       * profile associated with it, then this is the max_pkt_cnt set in <span class="delete">th</span></td><td> </td><td class="rblock">        * profile associated with it, then this is the max_pkt_cnt set in <span class="insert">t</span></td></tr>
      <tr><td class="lblock"><span class="delete">e</span></td><td> </td><td class="rblock"><span class="insert">he</span></td></tr>
      <tr><td class="lblock">       * profile params.  Returning this field is a convenience to the ODP</td><td> </td><td class="rblock">        * profile params.  Returning this field is a convenience to the ODP</td></tr>
      <tr><td class="lblock">       * programmer, enabling them to quickly see how the total_pkt_cnt</td><td> </td><td class="rblock">        * programmer, enabling them to quickly see how the total_pkt_cnt</td></tr>
      <tr><td class="lblock">       * compares to the maximum packet count threshold.  Note that there <span class="delete">i</span></td><td> </td><td class="rblock">        * compares to the maximum packet count threshold.  Note that there </td></tr>
      <tr><td class="lblock"><span class="delete">s</span></td><td> </td><td class="rblock"><span class="insert">is</span></td></tr>
      <tr><td class="lblock">       * no requirement that total_pkt_cnt be &lt;= max_pkt_cnt.</td><td> </td><td class="rblock">        * no requirement that total_pkt_cnt be &lt;= max_pkt_cnt. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint64_t max_pkt_cnt;</td><td> </td><td class="right">       uint64_t max_pkt_cnt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0082" /></td></tr>
      <tr><td class="lblock">       /** The total_byte_cnt can either be the actual number of bytes used</td><td> </td><td class="rblock">       /** The total_byte_cnt can either be the actual number of bytes used</td></tr>
      <tr><td class="lblock">       * or an approximation of the number of bytes used based upon the</td><td> </td><td class="rblock">        * or an approximation of the number of bytes used based upon the</td></tr>
      <tr><td class="lblock">       * number of fixed sized buffers used multiplied by the buffer size.</td><td> </td><td class="rblock">        * number of fixed sized buffers used multiplied by the buffer size.</td></tr>
      <tr><td class="lblock">       * In both cases the total_byte_cnt should correspond to the same <span class="delete">set</span></td><td> </td><td class="rblock">        * In both cases the total_byte_cnt should correspond to the same <span class="insert">se</span></td></tr>
      <tr><td class="lblock">       * of packets that were counted above.  For instance, if the</td><td> </td><td class="rblock"><span class="insert">t</span></td></tr>
      <tr><td class="lblock">       * total_pkt_cnt is updated in a batch, then the total_byte_cnt <span class="delete">shoul</span></td><td> </td><td class="rblock">        * of packets that were counted above.  For instance, if the</td></tr>
      <tr><td class="lblock"><span class="delete">d</span></td><td> </td><td class="rblock">        * total_pkt_cnt is updated in a batch, then the total_byte_cnt <span class="insert">shou</span></td></tr>
      <tr><td class="lblock">       * also be updated in the same batch.  The approx_byte_cnt field <span class="delete">belo</span></td><td> </td><td class="rblock"><span class="insert">ld</span></td></tr>
      <tr><td class="lblock"><span class="delete">w</span></td><td> </td><td class="rblock">        * also be updated in the same batch.  The approx_byte_cnt field <span class="insert">bel</span></td></tr>
      <tr><td class="lblock">       * indicates whether the total_byte_cnt is buffer count based or <span class="delete">not.</span></td><td> </td><td class="rblock"><span class="insert">ow</span></td></tr>
      <tr><td class="lblock">       * In the case that the number of bytes used by a packet is rounded <span class="delete">u</span></td><td> </td><td class="rblock">        * indicates whether the total_byte_cnt is buffer count based or <span class="insert">not</span></td></tr>
      <tr><td class="lblock"><span class="delete">p</span></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock">       * to a 2, 4, 8, or 16 byte boundary, it is recommended that</td><td> </td><td class="rblock">        * In the case that the number of bytes used by a packet is rounded </td></tr>
      <tr><td class="lblock">       * approx_byte_cnt be false.  It is implementation dependent whether</td><td> </td><td class="rblock"><span class="insert">up</span></td></tr>
      <tr><td class="lblock">       * the byte count of a packet includes the CRC, but it is <span class="delete">recommended</span></td><td> </td><td class="rblock">        * to a 2, 4, 8, or 16 byte boundary, it is recommended that</td></tr>
      <tr><td class="lblock">       * that it not include headroom, preamble or IPG.  Of course when <span class="delete">the</span></td><td> </td><td class="rblock">        * approx_byte_cnt be false.  It is implementation dependent whether</td></tr>
      <tr><td class="lblock">       * buffer counting method is used, it is expected that any headroom <span class="delete">i</span></td><td> </td><td class="rblock">        * the byte count of a packet includes the CRC, but it is <span class="insert">recommende</span></td></tr>
      <tr><td class="lblock"><span class="delete">n</span></td><td> </td><td class="rblock"><span class="insert">d</span></td></tr>
      <tr><td class="lblock">       * the first buffer is implicitly included.  Finally in the case of</td><td> </td><td class="rblock">        * that it not include headroom, preamble or IPG.  Of course when <span class="insert">th</span></td></tr>
      <tr><td class="lblock">       * variable length pkt based buffering, instead of taking the</td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock">       * total_pkt_cnt and multiplying it by the maximum ethernet packet</td><td> </td><td class="rblock">        * buffer counting method is used, it is expected that any headroom </td></tr>
      <tr><td class="lblock">       * size, it is recommended that byte_cnt_valid be FALSE - even when</td><td> </td><td class="rblock"><span class="insert">in</span></td></tr>
      <tr><td class="lblock">       * query_flags includes <span class="delete">ODP_TM_QUERY_BYTE_CNT.</span></td><td> </td><td class="rblock">        * the first buffer is implicitly included.  Finally in the case of</td></tr>
      <tr><td class="lblock"><span class="delete">       */</span></td><td> </td><td class="rblock">        * variable length pkt based buffering, instead of taking the</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * total_pkt_cnt and multiplying it by the maximum ethernet packet</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * size, it is recommended that byte_cnt_valid be FALSE - even when</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">        * query_flags includes <span class="insert">ODP_TM_QUERY_BYTE_CNT.*/</span></td></tr>
      <tr><td class="left">       uint64_t total_byte_cnt;</td><td> </td><td class="right">       uint64_t total_byte_cnt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0083" /></td></tr>
      <tr><td class="lblock">       /** If the requested set of tm_queues has an odp_tm_threshold_t</td><td> </td><td class="rblock">       /** If the requested set of tm_queues has an odp_tm_threshold_t</td></tr>
      <tr><td class="lblock">       * profile associated with it, then this is the max_byte_cnt set in</td><td> </td><td class="rblock">        * profile associated with it, then this is the max_byte_cnt set in</td></tr>
      <tr><td class="lblock">       * the profile params.  Returning this field is a convenience to the</td><td> </td><td class="rblock">        * the profile params.  Returning this field is a convenience to the</td></tr>
      <tr><td class="lblock">       * ODP programmer, enabling them to quickly see how the <span class="delete">total_byte_cn</span></td><td> </td><td class="rblock">        * ODP programmer, enabling them to quickly see how the <span class="insert">total_byte_c</span></td></tr>
      <tr><td class="lblock"><span class="delete">t</span></td><td> </td><td class="rblock"><span class="insert">nt</span></td></tr>
      <tr><td class="lblock">       * compares to the maximum byte count threshold.  Note that there is</td><td> </td><td class="rblock">        * compares to the maximum byte count threshold.  Note that there is</td></tr>
      <tr><td class="lblock">       * no requirement that total_byte_cnt be &lt;= max_byte_cnt.</td><td> </td><td class="rblock">        * no requirement that total_byte_cnt be &lt;= max_byte_cnt. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       uint64_t max_byte_cnt;</td><td> </td><td class="right">       uint64_t max_byte_cnt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0084" /></td></tr>
      <tr><td class="lblock">       /** The following boolean values indicate which of the counts above</td><td> </td><td class="rblock">       /** The following boolean values indicate which of the counts above</td></tr>
      <tr><td class="lblock">       * are valid.  Invalid count values must be 0.</td><td> </td><td class="rblock">        * are valid.  Invalid count values must be 0. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_bool_t total_pkt_cnt_valid;  /**&lt; TRUE if total_pkt_cnt is valid
 */</td><td> </td><td class="right">       odp_bool_t total_pkt_cnt_valid;  /**&lt; TRUE if total_pkt_cnt is valid
 */</td></tr>
      <tr><td class="left">       odp_bool_t max_pkt_cnt_valid;    /**&lt; TRUE if max_pkt_cnt is valid *
/</td><td> </td><td class="right">       odp_bool_t max_pkt_cnt_valid;    /**&lt; TRUE if max_pkt_cnt is valid *
/</td></tr>
      <tr><td class="left">       odp_bool_t total_byte_cnt_valid; /**&lt; TRUE if total_byte_cnt is vali
d */</td><td> </td><td class="right">       odp_bool_t total_byte_cnt_valid; /**&lt; TRUE if total_byte_cnt is vali
d */</td></tr>
      <tr><td class="left">       odp_bool_t max_byte_cnt_valid;   /**&lt; TRUE if max_byte_cnt is valid 
*/</td><td> </td><td class="right">       odp_bool_t max_byte_cnt_valid;   /**&lt; TRUE if max_byte_cnt is valid 
*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0085" /></td></tr>
      <tr><td class="lblock">       /** The approx_byte_cnt is TRUE if the total_byte_cnt field is valid</td><td> </td><td class="rblock">       /** The approx_byte_cnt is TRUE if the total_byte_cnt field is valid</td></tr>
      <tr><td class="lblock">       * AND if the buffer counting method is used.</td><td> </td><td class="rblock">        * AND if the buffer counting method is used. */</td></tr>
      <tr><td class="lblock">       */</td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_bool_t approx_byte_cnt;</td><td> </td><td class="right">       odp_bool_t approx_byte_cnt;</td></tr>
      <tr><td><a name="diff0086" /></td></tr>
      <tr><td class="lblock">} odp_tm_que<span class="delete">ue</span>_info_t;</td><td> </td><td class="rblock">} odp_tm_que<span class="insert">ry</span>_info_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_queue_query() function can be used to check a single tm_queu
e's</td><td> </td><td class="right">/** The odp_tm_queue_query() function can be used to check a single tm_queu
e's</td></tr>
      <tr><td class="left"> * queue utilization.  The query_flags indicate whether or not packet count
s,</td><td> </td><td class="right"> * queue utilization.  The query_flags indicate whether or not packet count
s,</td></tr>
      <tr><td class="left"> * byte counts or both are being requested.  It is an error to request</td><td> </td><td class="right"> * byte counts or both are being requested.  It is an error to request</td></tr>
      <tr><td class="left"> * neither.  The implementation may still return both sets of counts</td><td> </td><td class="right"> * neither.  The implementation may still return both sets of counts</td></tr>
      <tr><td class="left"> * regardless of query_flags if the cost of returning all the counts is</td><td> </td><td class="right"> * regardless of query_flags if the cost of returning all the counts is</td></tr>
      <tr><td class="left"> * comparable to the cost of checking the query_flags.</td><td> </td><td class="right"> * comparable to the cost of checking the query_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  tm_queue     Specifies the tm_queue (and indirectly the</td><td> </td><td class="right"> * @param[in]  tm_queue     Specifies the tm_queue (and indirectly the</td></tr>
      <tr><td class="left"> *                          TM system).</td><td> </td><td class="right"> *                          TM system).</td></tr>
      <tr><td class="left"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td><td> </td><td class="right"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td></tr>
      <tr><td class="left"> *                          being requested to be returned in the info reco
rd.</td><td> </td><td class="right"> *                          being requested to be returned in the info reco
rd.</td></tr>
      <tr><td><a name="diff0087" /></td></tr>
      <tr><td class="lblock"> * @param[out] info         Pointer to an odp_tm_que<span class="delete">ue</span>_info_t record where 
the</td><td> </td><td class="rblock"> * @param[out] info         Pointer to an odp_tm_que<span class="insert">ry</span>_info_t record where 
the</td></tr>
      <tr><td class="left"> *                          requested queue info is returned.</td><td> </td><td class="right"> *                          requested queue info is returned.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0088" /></td></tr>
      <tr><td class="lblock">int odp_tm_queue_query(odp_tm_queue_t tm_queue,</td><td> </td><td class="rblock">int odp_tm_queue_query(odp_tm_queue_t       tm_queue,</td></tr>
      <tr><td class="lblock">                      uint32_t query_flags,</td><td> </td><td class="rblock">                      uint32_t             query_flags,</td></tr>
      <tr><td class="lblock">                      <span class="delete">odp_tm_queue_info_t</span> *info);</td><td> </td><td class="rblock">                      <span class="insert">odp_tm_query_info_t</span> *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_priority_query() function can be used to check the queue</td><td> </td><td class="right">/** The odp_tm_priority_query() function can be used to check the queue</td></tr>
      <tr><td class="left"> * utilization of all tm_queue's with the given priority.  The query_flags</td><td> </td><td class="right"> * utilization of all tm_queue's with the given priority.  The query_flags</td></tr>
      <tr><td class="left"> * indicate whether or not packet counts, byte counts or both are being</td><td> </td><td class="right"> * indicate whether or not packet counts, byte counts or both are being</td></tr>
      <tr><td class="left"> * requested.  It is an error to request neither.  The implementation may</td><td> </td><td class="right"> * requested.  It is an error to request neither.  The implementation may</td></tr>
      <tr><td class="left"> * still return both sets of counts regardless of query_flags if the cost o
f</td><td> </td><td class="right"> * still return both sets of counts regardless of query_flags if the cost o
f</td></tr>
      <tr><td class="left"> * returning all the counts is comparable to the cost of checking the</td><td> </td><td class="right"> * returning all the counts is comparable to the cost of checking the</td></tr>
      <tr><td class="left"> * query_flags.</td><td> </td><td class="right"> * query_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  odp_tm       Specifies the TM system.</td><td> </td><td class="right"> * @param[in]  odp_tm       Specifies the TM system.</td></tr>
      <tr><td class="left"> * @param[in]  priority     Supplies the strict priority level used to spec
ify</td><td> </td><td class="right"> * @param[in]  priority     Supplies the strict priority level used to spec
ify</td></tr>
      <tr><td class="left"> *                          which tm_queues are included in the info values
.</td><td> </td><td class="right"> *                          which tm_queues are included in the info values
.</td></tr>
      <tr><td class="left"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td><td> </td><td class="right"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td></tr>
      <tr><td class="left"> *                          being requested to be returned in the info reco
rd.</td><td> </td><td class="right"> *                          being requested to be returned in the info reco
rd.</td></tr>
      <tr><td><a name="diff0089" /></td></tr>
      <tr><td class="lblock"> * @param[out] info         Pointer to an odp_tm_que<span class="delete">ue</span>_info_t record where 
the</td><td> </td><td class="rblock"> * @param[out] info         Pointer to an odp_tm_que<span class="insert">ry</span>_info_t record where 
the</td></tr>
      <tr><td class="left"> *                          requested queue info is returned.</td><td> </td><td class="right"> *                          requested queue info is returned.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0090" /></td></tr>
      <tr><td class="lblock">int odp_tm_priority_query(odp_tm_t odp_tm, uint8_t priority,</td><td> </td><td class="rblock">int odp_tm_priority_query(odp_tm_t             odp_tm,</td></tr>
      <tr><td class="lblock">                         uint32_t query_flags, <span class="delete">odp_tm_queue_info_t</span> *info);</td><td> </td><td class="rblock">                         uint8_t              priority,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                         uint32_t             query_flags,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                         <span class="insert">odp_tm_query_info_t</span> *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_total_query() function can be used to check the queue</td><td> </td><td class="right">/** The odp_tm_total_query() function can be used to check the queue</td></tr>
      <tr><td class="left"> * utilization of all tm_queue's in a single TM system.  The query_flags</td><td> </td><td class="right"> * utilization of all tm_queue's in a single TM system.  The query_flags</td></tr>
      <tr><td class="left"> * indicate whether or not packet counts, byte counts or both are being</td><td> </td><td class="right"> * indicate whether or not packet counts, byte counts or both are being</td></tr>
      <tr><td class="left"> * requested.  It is an error to request neither.  The implementation may</td><td> </td><td class="right"> * requested.  It is an error to request neither.  The implementation may</td></tr>
      <tr><td class="left"> * still return both sets of counts regardless of query_flags if the cost o
f</td><td> </td><td class="right"> * still return both sets of counts regardless of query_flags if the cost o
f</td></tr>
      <tr><td class="left"> * returning all the counts is comparable to the cost of checking the</td><td> </td><td class="right"> * returning all the counts is comparable to the cost of checking the</td></tr>
      <tr><td class="left"> * query_flags.</td><td> </td><td class="right"> * query_flags.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in]  odp_tm       Specifies the TM system.</td><td> </td><td class="right"> * @param[in]  odp_tm       Specifies the TM system.</td></tr>
      <tr><td class="left"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td><td> </td><td class="right"> * @param[out] query_flags  A set of flag bits indicating which counters ar
e</td></tr>
      <tr><td class="left"> *                          being requested to be returned in the info reco
rd.</td><td> </td><td class="right"> *                          being requested to be returned in the info reco
rd.</td></tr>
      <tr><td><a name="diff0091" /></td></tr>
      <tr><td class="lblock"> * @param[out] info         Pointer to an odp_tm_que<span class="delete">ue</span>_info_t record where 
the</td><td> </td><td class="rblock"> * @param[out] info         Pointer to an odp_tm_que<span class="insert">ry</span>_info_t record where 
the</td></tr>
      <tr><td class="left"> *                          requested queue info is returned.</td><td> </td><td class="right"> *                          requested queue info is returned.</td></tr>
      <tr><td class="left"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td><td> </td><td class="right"> * @return                  Returns 0 upon success, &lt; 0 upon failure.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0092" /></td></tr>
      <tr><td class="lblock">int odp_tm_total_query(odp_tm_t odp_tm, uint32_t query_flags,</td><td> </td><td class="rblock">int odp_tm_total_query(odp_tm_t             odp_tm,</td></tr>
      <tr><td class="lblock">                      <span class="delete">odp_tm_queue_info_t</span> *info);</td><td> </td><td class="rblock">                      uint32_t             query_flags,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                      <span class="insert">odp_tm_query_info_t</span> *info);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_priority_threshold_config() function is only used to associa
te</td><td> </td><td class="right">/** The odp_tm_priority_threshold_config() function is only used to associa
te</td></tr>
      <tr><td class="left"> * a maximum packet count and/or a maximum byte count with a strict priorit
y</td><td> </td><td class="right"> * a maximum packet count and/or a maximum byte count with a strict priorit
y</td></tr>
      <tr><td class="left"> * level - for the benefit of the odp_tm_priority_query() function.  It has
 no</td><td> </td><td class="right"> * level - for the benefit of the odp_tm_priority_query() function.  It has
 no</td></tr>
      <tr><td class="left"> * semantic effects other than returning these queue threshold values in th
e</td><td> </td><td class="right"> * semantic effects other than returning these queue threshold values in th
e</td></tr>
      <tr><td><a name="diff0093" /></td></tr>
      <tr><td class="lblock"> * odp_tm_que<span class="delete">ue</span>_info_t record.</td><td> </td><td class="rblock"> * odp_tm_que<span class="insert">ry</span>_info_t record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] odp_tm              Specifies the TM system.</td><td> </td><td class="right"> * @param[in] odp_tm              Specifies the TM system.</td></tr>
      <tr><td class="left"> * @param[in] priority            Supplies the strict priority level that</td><td> </td><td class="right"> * @param[in] priority            Supplies the strict priority level that</td></tr>
      <tr><td class="left"> *                                the threshold profile params are associat
ed</td><td> </td><td class="right"> *                                the threshold profile params are associat
ed</td></tr>
      <tr><td class="left"> *                                with.</td><td> </td><td class="right"> *                                with.</td></tr>
      <tr><td class="left"> * @param[in] thresholds_profile  Specifies the queue threshold profile tha
t</td><td> </td><td class="right"> * @param[in] thresholds_profile  Specifies the queue threshold profile tha
t</td></tr>
      <tr><td class="left"> *                                should now be associated with the supplie
d</td><td> </td><td class="right"> *                                should now be associated with the supplie
d</td></tr>
      <tr><td class="left"> *                                strict priority level.</td><td> </td><td class="right"> *                                strict priority level.</td></tr>
      <tr><td class="left"> * @return                        Returns 0 upon success and &lt; 0 upon failu
re.</td><td> </td><td class="right"> * @return                        Returns 0 upon success and &lt; 0 upon failu
re.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0094" /></td></tr>
      <tr><td class="lblock">int odp_tm_priority_threshold_config(odp_tm_t odp_tm, uint8_t priority,</td><td> </td><td class="rblock">int odp_tm_priority_threshold_config(odp_tm_t           odp_tm,</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                    uint8_t            priority,</td></tr>
      <tr><td class="left">                                    odp_tm_threshold_t thresholds_profile);</td><td> </td><td class="right">                                    odp_tm_threshold_t thresholds_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** The odp_tm_total_threshold_config() function is only used to associate 
a</td><td> </td><td class="right">/** The odp_tm_total_threshold_config() function is only used to associate 
a</td></tr>
      <tr><td class="left"> * maximum packet count and/or a maximum byte count with a TM system - for 
the</td><td> </td><td class="right"> * maximum packet count and/or a maximum byte count with a TM system - for 
the</td></tr>
      <tr><td class="left"> * benefit of the odp_tm_total_query() function.  It has no semantic effect
s</td><td> </td><td class="right"> * benefit of the odp_tm_total_query() function.  It has no semantic effect
s</td></tr>
      <tr><td class="left"> * other than returning these queue threshold values in the</td><td> </td><td class="right"> * other than returning these queue threshold values in the</td></tr>
      <tr><td><a name="diff0095" /></td></tr>
      <tr><td class="lblock"> * odp_tm_que<span class="delete">ue</span>_info_t record.</td><td> </td><td class="rblock"> * odp_tm_que<span class="insert">ry</span>_info_t record.</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] odp_tm              Specifies the TM system.</td><td> </td><td class="right"> * @param[in] odp_tm              Specifies the TM system.</td></tr>
      <tr><td class="left"> * @param[in] thresholds_profile  Specifies the queue threshold profile tha
t</td><td> </td><td class="right"> * @param[in] thresholds_profile  Specifies the queue threshold profile tha
t</td></tr>
      <tr><td class="left"> *                                should now be used for the entire TM</td><td> </td><td class="right"> *                                should now be used for the entire TM</td></tr>
      <tr><td class="left"> *                                system.</td><td> </td><td class="right"> *                                system.</td></tr>
      <tr><td class="left"> * @return                        Returns 0 upon success and &lt; 0 upon failu
re.</td><td> </td><td class="right"> * @return                        Returns 0 upon success and &lt; 0 upon failu
re.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">int odp_tm_total_threshold_config(odp_tm_t odp_tm,</td><td> </td><td class="right">int odp_tm_total_threshold_config(odp_tm_t odp_tm,</td></tr>
      <tr><td class="left">                                 odp_tm_threshold_t thresholds_profile);</td><td> </td><td class="right">                                 odp_tm_threshold_t thresholds_profile);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0096" /></td></tr>
      <tr><td class="lblock"><span class="delete">/** Misc functions */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"></span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">/** The odp_tm_periodic_update function is a placeholder for any external</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * source of periodic events.  In some cases the TM system may already have</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> an</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * internal built-in source of periodic events - in which case calling this</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> * function has no effect.</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">void odp_tm_periodic_update(void);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/** The odp_tm_is_idle function is used to determine if the specified ODP</td><td> </td><td class="right">/** The odp_tm_is_idle function is used to determine if the specified ODP</td></tr>
      <tr><td class="left"> * traffic management system still has "work" to do (i.e. has at least one</td><td> </td><td class="right"> * traffic management system still has "work" to do (i.e. has at least one</td></tr>
      <tr><td class="left"> * non-empty tm_queue and perhaps some outstanding timers etc).  This funct
ion</td><td> </td><td class="right"> * non-empty tm_queue and perhaps some outstanding timers etc).  This funct
ion</td></tr>
      <tr><td class="left"> * can be used by test programs and ODP applications that wish to know when</td><td> </td><td class="right"> * can be used by test programs and ODP applications that wish to know when</td></tr>
      <tr><td class="left"> * TM system has completed its work - presumably after they have stopped</td><td> </td><td class="right"> * TM system has completed its work - presumably after they have stopped</td></tr>
      <tr><td class="left"> * sending in new pkts.  Note that this function should not be called often</td><td> </td><td class="right"> * sending in new pkts.  Note that this function should not be called often</td></tr>
      <tr><td class="left"> * since for some implementations this call could take a fairly long time</td><td> </td><td class="right"> * since for some implementations this call could take a fairly long time</td></tr>
      <tr><td class="left"> * to execute!</td><td> </td><td class="right"> * to execute!</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param[in] odp_tm  Specifies the TM system.</td><td> </td><td class="right"> * @param[in] odp_tm  Specifies the TM system.</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 96 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>376 lines changed or deleted</i></th><th><i> </i></th><th><i>1085 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;version.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;version.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 26</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 26</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @defgroup odp_version ODP VERSION</td><td> </td><td class="right"> * @defgroup odp_version ODP VERSION</td></tr>
      <tr><td class="left"> * @details</td><td> </td><td class="right"> * @details</td></tr>
      <tr><td class="left"> * &lt;b&gt; ODP API and implementation versions &lt;/b&gt;</td><td> </td><td class="right"> * &lt;b&gt; ODP API and implementation versions &lt;/b&gt;</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"> * ODP API version is identified by ODP_VERSION_API_XXX pre<span class="delete">-processor macro
s</span>.</td><td> </td><td class="rblock"> * ODP API version is identified by ODP_VERSION_API_XXX pre<span class="insert">processor macros
</span>.</td></tr>
      <tr><td class="left"> * In addition to these macros, API calls can be used to identify implement
ation</td><td> </td><td class="right"> * In addition to these macros, API calls can be used to identify implement
ation</td></tr>
      <tr><td class="left"> * and API version information at run time.</td><td> </td><td class="right"> * and API version information at run time.</td></tr>
      <tr><td class="left"> * @{</td><td> </td><td class="right"> * @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ODP API generation version</td><td> </td><td class="right"> * ODP API generation version</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Introduction of major new features or changes that make</td><td> </td><td class="right"> * Introduction of major new features or changes that make</td></tr>
      <tr><td class="left"> * very significant changes to the API. APIs with different</td><td> </td><td class="right"> * very significant changes to the API. APIs with different</td></tr>
      <tr><td class="left"> * versions are likely not backward compatible.</td><td> </td><td class="right"> * versions are likely not backward compatible.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_VERSION_API_GENERATION 1</td><td> </td><td class="right">#define ODP_VERSION_API_GENERATION 1</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ODP API major version</td><td> </td><td class="right"> * ODP API major version</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Introduction of major new features or changes. APIs with different major</td><td> </td><td class="right"> * Introduction of major new features or changes. APIs with different major</td></tr>
      <tr><td class="left"> * versions are likely not backward compatible.</td><td> </td><td class="right"> * versions are likely not backward compatible.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock">#define ODP_VERSION_API_MAJOR <span class="delete">9</span></td><td> </td><td class="rblock">#define ODP_VERSION_API_MAJOR <span class="insert">10</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * ODP API minor version</td><td> </td><td class="right"> * ODP API minor version</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * Minor version is incremented when introducing backward compatible change
s</td><td> </td><td class="right"> * Minor version is incremented when introducing backward compatible change
s</td></tr>
      <tr><td class="left"> * to the API. For an API with common generation and major version, but wit
h</td><td> </td><td class="right"> * to the API. For an API with common generation and major version, but wit
h</td></tr>
      <tr><td class="left"> * different minor numbers the two versions are backward compatible.</td><td> </td><td class="right"> * different minor numbers the two versions are backward compatible.</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">#define ODP_VERSION_API_MINOR 0</td><td> </td><td class="right">#define ODP_VERSION_API_MINOR 0</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;chksum.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;chksum.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 22</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 22</em></th></tr>
      <tr><td class="left">#ifndef ODPH_CHKSUM_H_</td><td> </td><td class="right">#ifndef ODPH_CHKSUM_H_</td></tr>
      <tr><td class="left">#define ODPH_CHKSUM_H_</td><td> </td><td class="right">#define ODPH_CHKSUM_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp_api.h&gt;</td><td> </td><td class="right">#include &lt;odp_api.h&gt;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* Chksum Operation Code</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This enumeration type is used to tell odph_udp_tcp_chksum what to do onc</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * it has calculated the TCP/UDP check sum.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">typedef enum {</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODPH_CHKSUM_GENERATE, /**&lt; Set TCP/UDP header chksum field */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODPH_CHKSUM_VERIFY,   /**&lt; See if TCP/UDP header chksum is correct *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       ODPH_CHKSUM_RETURN    /**&lt; Don't generate or verify chksum */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">} odph_chksum_op_t;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="left"> * Checksum</td><td> </td><td class="right"> * Checksum</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param buffer calculate chksum for buffer</td><td> </td><td class="right"> * @param buffer calculate chksum for buffer</td></tr>
      <tr><td class="left"> * @param len    buffer length</td><td> </td><td class="right"> * @param len    buffer length</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return checksum value in host cpu order</td><td> </td><td class="right"> * @return checksum value in host cpu order</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">static inline odp_u16sum_t odph_chksum(void *buffer, int len)</td><td> </td><td class="right">static inline odp_u16sum_t odph_chksum(void *buffer, int len)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       uint16_t *buf = buffer;</td><td> </td><td class="right">       uint16_t *buf = buffer;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 48</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 60</em></th></tr>
      <tr><td class="left">       if (len == 1)</td><td> </td><td class="right">       if (len == 1)</td></tr>
      <tr><td class="left">               sum += *(unsigned char *)buf;</td><td> </td><td class="right">               sum += *(unsigned char *)buf;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       sum = (sum &gt;&gt; 16) + (sum &amp; 0xFFFF);</td><td> </td><td class="right">       sum = (sum &gt;&gt; 16) + (sum &amp; 0xFFFF);</td></tr>
      <tr><td class="left">       sum += (sum &gt;&gt; 16);</td><td> </td><td class="right">       sum += (sum &gt;&gt; 16);</td></tr>
      <tr><td class="left">       result = ~sum;</td><td> </td><td class="right">       result = ~sum;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       return  (__odp_force odp_u16sum_t) result;</td><td> </td><td class="right">       return  (__odp_force odp_u16sum_t) result;</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * General Purpose TCP/UDP checksum function</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function handles all the different checksum operations like</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODPH_CHKSUM_GENERATE, ODPH_CHKSUM_VERIFY and ODPH_CHKSUM_RETURN for both</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * TCP and UDP pkts over either IPv4 or IPv6.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that the packet will be modified only if op==ODPH_CHKSUM_GENERATE.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * In the case of ODPH_CHKSUM_RETURN, the checksum will be calculated, but</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * will neither be written or compared, but just returned via the chksum_pt</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">r</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * parameter (assuming that chksum_ptr is non NULL).  Because the code does</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">n't</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * know whether a GENERATE or VERIFY is occurring, when using</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * ODPH_CHKSUM_RETURN it is important that the chksum field be well defined</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (either the value as received or set to 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * when created).  Note that for ODPH_CHKSUM_GENERATE, the existing chksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * field is ignored (i.e. the code will zero it out before computing the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * chksum).  See also comments in the convenience functions below.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  odp_pkt     Calculate the chksum for this pkt and based on the o</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">p</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     parameter either replace the existing chksum field,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     or verify that it is correct or just return it.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  op          What is to be done with the calculated chksum.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     doesn't handle tunnels of multiple IPv4/IPv6 headers</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  chksum_ptr  Pointer to a 16 bit field where the checksum will be</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     written.  Note that if this pointer is non NULL, the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     calculated checksum will always be returned regardle</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ss</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     of op.  Note that the calculated chksum always inclu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">des</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     the chksum in the TCP or UDP header.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return             Returns &lt; 0 upon an error which prevents the checksu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">m</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     calculation. Returns 0 when there is no error AND th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">e</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     op is either ODPH_CHKSUM_GENERATE or ODPH_CHKSUM_RET</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">URN.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     If there is no error and the op is ODPH_CHKSUM_VERIF</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">Y</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     then (a) 1 is returned if this is a UDP pkt whose</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     incoming checksum value was 0 (indicating a disabled</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     UDP chksum), else (b) 0 is returned if the incoming</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     chksum is "correct" (i.e. calculated value is 0),</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     else (c) 2 is returned if the incoming chksum is</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     incorrect (including the case of an incoming TCP chk</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">sum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     of 0).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">int odph_udp_tcp_chksum(odp_packet_t     odp_pkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       odph_chksum_op_t op,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">                       uint16_t        *chksum_ptr);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Generate TCP checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function supports TCP over either IPv4 or IPV6 - including handling</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * any IPv4 header options and any IPv6 extension headers.  However it</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * does not handle tunneled pkts (i.e. any case where there is more than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * one IPv4/IPv6 header).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function also handles non-contiguous pkts.  In particular it can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle arbitrary packet segmentation, including cases where the segments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * are not 2 byte aligned, nor have a length that is a multiple of 2.  This</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * function also can handle jumbo frames (at least up to 10K).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will insert the calculated IP checksum into the proper</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * location in the TCP header.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  odp_pkt     Calculate and insert chksum for this TCP pkt, which </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     be over IPv4 or IPv6.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return             0 upon success and &lt; 0 upon failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline int odph_tcp_chksum_set(odp_packet_t odp_pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!odp_packet_has_tcp(odp_pkt))</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return -1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return odph_udp_tcp_chksum(odp_pkt, ODPH_CHKSUM_GENERATE, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Generate UDP checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function supports UDP over either IPv4 or IPV6 - including handling</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * any IPv4 header options and any IPv6 extension headers.  However it</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * does not handle tunneled pkts (i.e. any case where there is more than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * one IPv4/IPv6 header).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function also handles non-contiguous pkts.  In particular it can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle arbitrary packet segmentation, including cases where the segments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * are not 2 byte aligned, nor have a length that is a multiple of 2.  This</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * function also can handle jumbo frames (at least up to 10K).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function will insert the calculated IP checksum into the proper</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * location in the UDP header.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  odp_pkt     Calculate and insert chksum for this UDP pkt, which </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     be over IPv4 or IPv6.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return             0 upon success and &lt; 0 upon failure.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline int odph_udp_chksum_set(odp_packet_t odp_pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!odp_packet_has_udp(odp_pkt))</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return -1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return odph_udp_tcp_chksum(odp_pkt, ODPH_CHKSUM_GENERATE, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Verify TCP checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function supports TCP over either IPv4 or IPV6 - including handling</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * any IPv4 header options and any IPv6 extension headers.  However it</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * does not handle tunneled pkts (i.e. any case where there is more than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * one IPv4/IPv6 header).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function also handles non-contiguous pkts.  In particular it can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle arbitrary packet segmentation, including cases where the segments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * are not 2 byte aligned, nor have a length that is a multiple of 2.  This</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * function also can handle jumbo frames (at least up to 10K).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that since TCP checksums cannot be turned off, an incoming TCP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * checksum of 0 will return an "incorrect" indication (the value 2).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  odp_pkt     Calculate and compare the chksum for this TCP pkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     which can be over IPv4 or IPv6.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return             Returns &lt; 0 upon an error. Returns 0 upon no error a</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">nd</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     the incoming chksum field is correct, else returns 2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     when the chksum field is incorrect or 0.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline int odph_tcp_chksum_verify(odp_packet_t odp_pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!odp_packet_has_tcp(odp_pkt))</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return -1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return odph_udp_tcp_chksum(odp_pkt, ODPH_CHKSUM_VERIFY, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/**</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Verify UDP checksum</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function supports UDP over either IPv4 or IPV6 - including handling</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * any IPv4 header options and any IPv6 extension headers.  However it</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * does not handle tunneled pkts (i.e. any case where there is more than</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * one IPv4/IPv6 header).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * This function also handles non-contiguous pkts.  In particular it can</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * handle arbitrary packet segmentation, including cases where the segments</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * are not 2 byte aligned, nor have a length that is a multiple of 2.  This</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * function also can handle jumbo frames (at least up to 10K).</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Note that UDP checksums can be disabled by setting the incoming UDP</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * chksum field to 0.  In this case this function will return the value 1 -</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * indicating neither a correct or incorrect chksum.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @param  odp_pkt     Calculate and compare the chksum for this UDP pkt,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     which can be over IPv4 or IPv6.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * @return             Returns &lt; 0 upon an error.  Returns 1 upon no error </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">and</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     the incoming chksum field is 0 (disabled), else retu</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">rns 0</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     if the incoming chksum field is correct, else return</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">s 2</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> *                     when the chksum field is incorrect.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">static inline int odph_udp_chksum_verify(odp_packet_t odp_pkt)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">{</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       if (!odp_packet_has_udp(odp_pkt))</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">               return -1;</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       return odph_udp_tcp_chksum(odp_pkt, ODPH_CHKSUM_VERIFY, NULL);</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">}</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 2 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>0 lines changed or deleted</i></th><th><i> </i></th><th><i>186 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;eth.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;eth.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 34</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 34</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODPH_ETHADDR_LEN     6    /**&lt; Ethernet address length */</td><td> </td><td class="right">#define ODPH_ETHADDR_LEN     6    /**&lt; Ethernet address length */</td></tr>
      <tr><td class="left">#define ODPH_ETHHDR_LEN      14   /**&lt; Ethernet header length */</td><td> </td><td class="right">#define ODPH_ETHHDR_LEN      14   /**&lt; Ethernet header length */</td></tr>
      <tr><td class="left">#define ODPH_VLANHDR_LEN     4    /**&lt; VLAN header length */</td><td> </td><td class="right">#define ODPH_VLANHDR_LEN     4    /**&lt; VLAN header length */</td></tr>
      <tr><td class="left">#define ODPH_ETH_LEN_MIN     60   /**&lt; Min frame length (excl CRC 4 bytes) 
*/</td><td> </td><td class="right">#define ODPH_ETH_LEN_MIN     60   /**&lt; Min frame length (excl CRC 4 bytes) 
*/</td></tr>
      <tr><td class="left">#define ODPH_ETH_LEN_MIN_CRC 64   /**&lt; Min frame length (incl CRC 4 bytes) 
*/</td><td> </td><td class="right">#define ODPH_ETH_LEN_MIN_CRC 64   /**&lt; Min frame length (incl CRC 4 bytes) 
*/</td></tr>
      <tr><td class="left">#define ODPH_ETH_LEN_MAX     1514 /**&lt; Max frame length (excl CRC 4 bytes) 
*/</td><td> </td><td class="right">#define ODPH_ETH_LEN_MAX     1514 /**&lt; Max frame length (excl CRC 4 bytes) 
*/</td></tr>
      <tr><td class="left">#define ODPH_ETH_LEN_MAX_CRC 1518 /**&lt; Max frame length (incl CRC 4 bytes) 
*/</td><td> </td><td class="right">#define ODPH_ETH_LEN_MAX_CRC 1518 /**&lt; Max frame length (incl CRC 4 bytes) 
*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/* The two byte odph_vlanhdr_t tci field is composed of the following three</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * subfields - a three bit Priority Code Point (PCP), a one bit Drop</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * Eligibility Indicator (DEI) and a twelve bit VLAN Identifier (VID).  The</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * following constants can be used to extract or modify these subfields, on</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ce</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the tci field has been read in and converted to host byte order.  Note</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * that the DEI subfield used to be the CFI bit.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_MAX_PRIO   7      /**&lt; Max value of the 3 bit priority</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_PCP_MASK   0xE000 /**&lt; PCP field bit mask */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_PCP_SHIFT  13     /**&lt; PCP field shift */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_DEI_MASK   0x1000 /**&lt; DEI field bit mask */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_DEI_SHIFT  12     /**&lt; DEI field shift */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_MAX_VID    0x0FFF /**&lt; Max value of the 12 bit VID fie</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">ld */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_VID_MASK   0x0FFF /**&lt; VID field bit mask */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_VLANHDR_VID_SHIFT  0      /**&lt; VID field shift */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Ethernet MAC address</td><td> </td><td class="right"> * Ethernet MAC address</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       uint8_t addr[ODPH_ETHADDR_LEN]; /**&lt; @private Address */</td><td> </td><td class="right">       uint8_t addr[ODPH_ETHADDR_LEN]; /**&lt; @private Address */</td></tr>
      <tr><td class="left">} odph_ethaddr_t;</td><td> </td><td class="right">} odph_ethaddr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_ethaddr_t)</span> == ODPH_ETHADDR_LEN, <span class="delete">"ODPH_ETHADD</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_ethaddr_t)</span> == ODPH_ETHADDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">R_T__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_ETHADDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Ethernet header</td><td> </td><td class="right"> * Ethernet header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       odph_ethaddr_t dst; /**&lt; Destination address */</td><td> </td><td class="right">       odph_ethaddr_t dst; /**&lt; Destination address */</td></tr>
      <tr><td class="left">       odph_ethaddr_t src; /**&lt; Source address */</td><td> </td><td class="right">       odph_ethaddr_t src; /**&lt; Source address */</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">       odp_u16be_t type;   /**&lt; Type */</td><td> </td><td class="rblock">       odp_u16be_t type;   /**&lt; <span class="insert">Ether</span>Type */</td></tr>
      <tr><td class="left">} odph_ethhdr_t;</td><td> </td><td class="right">} odph_ethhdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_ethhdr_t)</span> == ODPH_ETHHDR_LEN, <span class="delete">"ODPH_ETHHDR_T</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_ethhdr_t)</span> == ODPH_ETHHDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_ETHHDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"> * VLAN header</td><td> </td><td class="rblock"> * <span class="insert">IEEE 802.1Q </span>VLAN header</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"> * <span class="delete">@todo Check usage</span> of <span class="delete">tpid vs ethertype. Check outer VLAN TPID.</span></td><td> </td><td class="rblock"> * <span class="insert">This field is present when the EtherType (the odph_ethhdr_t type field)</span> </td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">of</td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"> <span class="insert">* the preceding ethernet header is ODPH_ETHTYPE_VLAN.  The inner EtherType</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * (the odph_vlanhdr_t type field) then indicates what comes next.  Note th</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">at</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the so called TPID field isn't here because it overlaps with the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * odph_ethhdr_t type field.</span></td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td><a name="diff0007" /></td></tr>
      <tr><td class="lblock"><span class="delete">       odp_u16be_t tpid;  /**&lt; Tag protocol ID (located after ethhdr.src) *
/</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">       odp_u16be_t tci;   /**&lt; Priority / CFI / VLAN ID */</td><td> </td><td class="right">       odp_u16be_t tci;   /**&lt; Priority / CFI / VLAN ID */</td></tr>
      <tr><td><a name="diff0008" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       odp_u16be_t type;  /**&lt; Inner EtherType */</span></td></tr>
      <tr><td class="left">} odph_vlanhdr_t;</td><td> </td><td class="right">} odph_vlanhdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0009" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_vlanhdr_t)</span> == ODPH_VLANHDR_LEN, <span class="delete">"ODPH_VLANHD</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_vlanhdr_t)</span> == ODPH_VLANHDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">R_T__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_VLANHDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Ethernet header Ether Type ('type') values, a selected few */</td><td> </td><td class="right">/* Ethernet header Ether Type ('type') values, a selected few */</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_IPV4       0x0800 /**&lt; Internet Protocol version 4 */</td><td> </td><td class="right">#define ODPH_ETHTYPE_IPV4       0x0800 /**&lt; Internet Protocol version 4 */</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_ARP        0x0806 /**&lt; Address Resolution Protocol */</td><td> </td><td class="right">#define ODPH_ETHTYPE_ARP        0x0806 /**&lt; Address Resolution Protocol */</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_RARP       0x8035 /**&lt; Reverse Address Resolution Prot
ocol*/</td><td> </td><td class="right">#define ODPH_ETHTYPE_RARP       0x8035 /**&lt; Reverse Address Resolution Prot
ocol*/</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_VLAN       0x8100 /**&lt; VLAN-tagged frame IEEE 802.1Q *
/</td><td> </td><td class="right">#define ODPH_ETHTYPE_VLAN       0x8100 /**&lt; VLAN-tagged frame IEEE 802.1Q *
/</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_VLAN_OUTER 0x88A8 /**&lt; Stacked VLANs/QinQ, outer-tag/S
-TAG*/</td><td> </td><td class="right">#define ODPH_ETHTYPE_VLAN_OUTER 0x88A8 /**&lt; Stacked VLANs/QinQ, outer-tag/S
-TAG*/</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_IPV6       0x86dd /**&lt; Internet Protocol version 6 */</td><td> </td><td class="right">#define ODPH_ETHTYPE_IPV6       0x86dd /**&lt; Internet Protocol version 6 */</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_FLOW_CTRL  0x8808 /**&lt; Ethernet flow control */</td><td> </td><td class="right">#define ODPH_ETHTYPE_FLOW_CTRL  0x8808 /**&lt; Ethernet flow control */</td></tr>
      <tr><td class="left">#define ODPH_ETHTYPE_MPLS       0x8847 /**&lt; MPLS unicast */</td><td> </td><td class="right">#define ODPH_ETHTYPE_MPLS       0x8847 /**&lt; MPLS unicast */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 9 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>10 lines changed or deleted</i></th><th><i> </i></th><th><i>35 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;icmp.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;icmp.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 94</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 94</em></th></tr>
      <tr><td class="left">#define ICMP_REDIR_HOST                1       /**&lt; Redirect Host          
    */</td><td> </td><td class="right">#define ICMP_REDIR_HOST                1       /**&lt; Redirect Host          
    */</td></tr>
      <tr><td class="left">#define ICMP_REDIR_NETTOS      2       /**&lt; Redirect Net for TOS       */</td><td> </td><td class="right">#define ICMP_REDIR_NETTOS      2       /**&lt; Redirect Net for TOS       */</td></tr>
      <tr><td class="left">#define ICMP_REDIR_HOSTTOS     3       /**&lt; Redirect Host for TOS      */</td><td> </td><td class="right">#define ICMP_REDIR_HOSTTOS     3       /**&lt; Redirect Host for TOS      */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/* Codes for TIME_EXCEEDED. */</td><td> </td><td class="right">/* Codes for TIME_EXCEEDED. */</td></tr>
      <tr><td class="left">#define ICMP_EXC_TTL           0       /**&lt; TTL count exceeded         */</td><td> </td><td class="right">#define ICMP_EXC_TTL           0       /**&lt; TTL count exceeded         */</td></tr>
      <tr><td class="left">#define ICMP_EXC_FRAGTIME      1       /**&lt; Fragment Reass time</td><td> </td><td class="right">#define ICMP_EXC_FRAGTIME      1       /**&lt; Fragment Reass time</td></tr>
      <tr><td class="left">                                                               exceeded*/</td><td> </td><td class="right">                                                               exceeded*/</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_icmphdr_t)</span> == ODPH_ICMPHDR_LEN, <span class="delete">"ODPH_ICMPHD</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_icmphdr_t)</span> == ODPH_ICMPHDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">R_T__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_ICMPHDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>2 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;ip.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;ip.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 34</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 34</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @addtogroup odph_header ODPH HEADER</td><td> </td><td class="right">/** @addtogroup odph_header ODPH HEADER</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#define ODPH_IPV4             4  /**&lt; IP version 4 */</td><td> </td><td class="right">#define ODPH_IPV4             4  /**&lt; IP version 4 */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_LEN     20  /**&lt; Min length of IP header (no options) 
*/</td><td> </td><td class="right">#define ODPH_IPV4HDR_LEN     20  /**&lt; Min length of IP header (no options) 
*/</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_IHL_MIN  5  /**&lt; Minimum IHL value*/</td><td> </td><td class="right">#define ODPH_IPV4HDR_IHL_MIN  5  /**&lt; Minimum IHL value*/</td></tr>
      <tr><td class="left">#define ODPH_IPV4ADDR_LEN     4  /**&lt; IPv4 address length in bytes */</td><td> </td><td class="right">#define ODPH_IPV4ADDR_LEN     4  /**&lt; IPv4 address length in bytes */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The one byte IPv4 tos or IPv6 tc field is composed of the following two</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * subfields - a six bit Differentiated Service Code Point (DSCP) and a two</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * bit Explicit Congestion Notification (ECN) subfield.  The following</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * constants can be used to extract or modify these fields.  Despite the</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * name prefix being ODPH_IP_TOS_* these constants apply equally well for</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the IPv6 Traffic Class (tc) field.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_TOS_MAX_DSCP   63    /**&lt; 6-bit DSCP field has max value 63</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_TOS_DSCP_MASK  0xFC  /**&lt; DSCP field is in bits &lt;7:2&gt;  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_TOS_DSCP_SHIFT 2     /**&lt; DSCP field is shifted letf by 2  </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_TOS_MAX_ECN    3     /**&lt; 2-bit ECN field has max value 3  </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_TOS_ECN_MASK   0x03  /**&lt; ECN field is in bits &lt;1:0&gt;  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_TOS_ECN_SHIFT  0     /**&lt; ECN field is not shifted.  */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The following constants give names to the four possible ECN values,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * as described in RFC 3168.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_ECN_NOT_ECT  0  /**&lt; 0 indicates not participating in ECN *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_ECN_ECT1     1  /**&lt; Indicates no congestion seen yet */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_ECN_ECT0     2  /**&lt; Indicates no congestion seen yet */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IP_ECN_CE       3  /**&lt; Used to signal Congestion Experienced </span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">*/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/** @internal Returns IPv4 version */</td><td> </td><td class="right">/** @internal Returns IPv4 version */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_VER(ver_ihl) (((ver_ihl) &amp; 0xf0) &gt;&gt; 4)</td><td> </td><td class="right">#define ODPH_IPV4HDR_VER(ver_ihl) (((ver_ihl) &amp; 0xf0) &gt;&gt; 4)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Returns IPv4 header length */</td><td> </td><td class="right">/** @internal Returns IPv4 header length */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_IHL(ver_ihl) ((ver_ihl) &amp; 0x0f)</td><td> </td><td class="right">#define ODPH_IPV4HDR_IHL(ver_ihl) ((ver_ihl) &amp; 0x0f)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Returns IPv4 DSCP */</td><td> </td><td class="right">/** @internal Returns IPv4 DSCP */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_DSCP(tos) (((tos) &amp; 0xfc) &gt;&gt; 2)</td><td> </td><td class="right">#define ODPH_IPV4HDR_DSCP(tos) (((tos) &amp; 0xfc) &gt;&gt; 2)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Returns IPv4 Don't fragment */</td><td> </td><td class="right">/** @internal Returns IPv4 Don't fragment */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l2" /><small>skipping to change at</small><em> line 55</em></th><th> </th><th><a name="part-r2" /><small>skipping to change at</small><em> line 77</em></th></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Returns IPv4 more fragments */</td><td> </td><td class="right">/** @internal Returns IPv4 more fragments */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_FLAGS_MORE_FRAGS(frag_offset)  ((frag_offset) &amp; 0x2000
)</td><td> </td><td class="right">#define ODPH_IPV4HDR_FLAGS_MORE_FRAGS(frag_offset)  ((frag_offset) &amp; 0x2000
)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Returns IPv4 fragment offset */</td><td> </td><td class="right">/** @internal Returns IPv4 fragment offset */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_FRAG_OFFSET(frag_offset) ((frag_offset) &amp; 0x1fff)</td><td> </td><td class="right">#define ODPH_IPV4HDR_FRAG_OFFSET(frag_offset) ((frag_offset) &amp; 0x1fff)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Returns true if IPv4 packet is a fragment */</td><td> </td><td class="right">/** @internal Returns true if IPv4 packet is a fragment */</td></tr>
      <tr><td class="left">#define ODPH_IPV4HDR_IS_FRAGMENT(frag_offset) ((frag_offset) &amp; 0x3fff)</td><td> </td><td class="right">#define ODPH_IPV4HDR_IS_FRAGMENT(frag_offset) ((frag_offset) &amp; 0x3fff)</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"><span class="delete">/** @internal Returns IPv4 DSCP */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">#define ODPH_IPV6HDR_DSCP(ver_tc_flow) (uint8_t)((((ver_tc_flow) &amp; 0x0fc000</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">00) &gt;&gt; 22) &amp; 0xff)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">/** IPv4 header */</td><td> </td><td class="right">/** IPv4 header */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       uint8_t    ver_ihl;     /**&lt; Version / Header length */</td><td> </td><td class="right">       uint8_t    ver_ihl;     /**&lt; Version / Header length */</td></tr>
      <tr><td class="left">       uint8_t    tos;         /**&lt; Type of service */</td><td> </td><td class="right">       uint8_t    tos;         /**&lt; Type of service */</td></tr>
      <tr><td class="left">       odp_u16be_t tot_len;    /**&lt; Total length */</td><td> </td><td class="right">       odp_u16be_t tot_len;    /**&lt; Total length */</td></tr>
      <tr><td class="left">       odp_u16be_t id;         /**&lt; ID */</td><td> </td><td class="right">       odp_u16be_t id;         /**&lt; ID */</td></tr>
      <tr><td class="left">       odp_u16be_t frag_offset;/**&lt; Fragmentation offset */</td><td> </td><td class="right">       odp_u16be_t frag_offset;/**&lt; Fragmentation offset */</td></tr>
      <tr><td class="left">       uint8_t    ttl;         /**&lt; Time to live */</td><td> </td><td class="right">       uint8_t    ttl;         /**&lt; Time to live */</td></tr>
      <tr><td class="left">       uint8_t    proto;       /**&lt; Protocol */</td><td> </td><td class="right">       uint8_t    proto;       /**&lt; Protocol */</td></tr>
      <tr><td class="left">       odp_u16sum_t chksum;    /**&lt; Checksum */</td><td> </td><td class="right">       odp_u16sum_t chksum;    /**&lt; Checksum */</td></tr>
      <tr><td class="left">       odp_u32be_t src_addr;   /**&lt; Source address */</td><td> </td><td class="right">       odp_u32be_t src_addr;   /**&lt; Source address */</td></tr>
      <tr><td class="left">       odp_u32be_t dst_addr;   /**&lt; Destination address */</td><td> </td><td class="right">       odp_u32be_t dst_addr;   /**&lt; Destination address */</td></tr>
      <tr><td class="left">} odph_ipv4hdr_t;</td><td> </td><td class="right">} odph_ipv4hdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_ipv4hdr_t)</span> == ODPH_IPV4HDR_LEN, <span class="delete">"ODPH_IPV4HD</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_ipv4hdr_t)</span> == ODPH_IPV4HDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">R_T__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_IPV4HDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * Check if IPv4 checksum is valid</td><td> </td><td class="right"> * Check if IPv4 checksum is valid</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  ODP packet</td><td> </td><td class="right"> * @param pkt  ODP packet</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @return 1 if checksum is valid, otherwise 0</td><td> </td><td class="right"> * @return 1 if checksum is valid, otherwise 0</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">static inline int odph_ipv4_csum_valid(odp_packet_t pkt)</td><td> </td><td class="right">static inline int odph_ipv4_csum_valid(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td class="left">       odp_u16be_t res = 0;</td><td> </td><td class="right">       odp_u16be_t res = 0;</td></tr>
      <tr><td class="left">       uint16_t *w;</td><td> </td><td class="right">       uint16_t *w;</td></tr>
      <tr><td class="left">       int nleft = sizeof(odph_ipv4hdr_t);</td><td> </td><td class="right">       int nleft = sizeof(odph_ipv4hdr_t);</td></tr>
      <tr><td class="left">       odph_ipv4hdr_t ip;</td><td> </td><td class="right">       odph_ipv4hdr_t ip;</td></tr>
      <tr><td class="left">       odp_u16be_t chksum;</td><td> </td><td class="right">       odp_u16be_t chksum;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       if (!odp_packet_l3_offset(pkt))</td><td> </td><td class="right">       if (!odp_packet_l3_offset(pkt))</td></tr>
      <tr><td class="left">               return 0;</td><td> </td><td class="right">               return 0;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">       <span class="delete">odp_packet_copydata_out(pkt,</span> odp_packet_l3_offset(pkt),</td><td> </td><td class="rblock">       <span class="insert">odp_packet_copy_to_mem(pkt,</span> odp_packet_l3_offset(pkt),</td></tr>
      <tr><td class="lblock">                               sizeof(odph_ipv4hdr_t), &amp;ip);</td><td> </td><td class="rblock">                              sizeof(odph_ipv4hdr_t), &amp;ip);</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       w = (uint16_t *)(void *)&amp;ip;</td><td> </td><td class="right">       w = (uint16_t *)(void *)&amp;ip;</td></tr>
      <tr><td class="left">       chksum = ip.chksum;</td><td> </td><td class="right">       chksum = ip.chksum;</td></tr>
      <tr><td class="left">       ip.chksum = 0x0;</td><td> </td><td class="right">       ip.chksum = 0x0;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">       res = odph_chksum(w, nleft);</td><td> </td><td class="right">       res = odph_chksum(w, nleft);</td></tr>
      <tr><td class="left">       return (res == chksum) ? 1 : 0;</td><td> </td><td class="right">       return (res == chksum) ? 1 : 0;</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l3" /><small>skipping to change at</small><em> line 135</em></th><th> </th><th><a name="part-r3" /><small>skipping to change at</small><em> line 155</em></th></tr>
      <tr><td class="left">       ip-&gt;chksum = odph_chksum(w, nleft);</td><td> </td><td class="right">       ip-&gt;chksum = odph_chksum(w, nleft);</td></tr>
      <tr><td class="left">       return ip-&gt;chksum;</td><td> </td><td class="right">       return ip-&gt;chksum;</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** IPv6 version */</td><td> </td><td class="right">/** IPv6 version */</td></tr>
      <tr><td class="left">#define ODPH_IPV6 6</td><td> </td><td class="right">#define ODPH_IPV6 6</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** IPv6 header length */</td><td> </td><td class="right">/** IPv6 header length */</td></tr>
      <tr><td class="left">#define ODPH_IPV6HDR_LEN 40</td><td> </td><td class="right">#define ODPH_IPV6HDR_LEN 40</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** IPv6 address length in bytes */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6ADDR_LEN 16</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** The following constants can be used to access the three subfields</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * of the 4 byte ver_tc_flow field - namely the four bit Version subfield,</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * the eight bit Traffic Class subfield (TC) and the twenty bit Flow Label</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * subfield.  Note that the IPv6 TC field is analogous to the IPv4 TOS</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * field and is composed of the DSCP and ECN subfields.  Use the ODPH_IP_TO</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">S_*</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> * constants above to access these subfields.</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"> */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_VERSION_MASK     0xF0000000 /**&lt; Version field bit mas</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">k */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_VERSION_SHIFT    28         /**&lt; Version field shift *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_TC_MASK          0x0FF00000 /**&lt; TC field bit mask */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_TC_SHIFT         20         /**&lt; TC field shift */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_FLOW_LABEL_MASK  0x000FFFFF /**&lt; Flow Label bit mask *</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_FLOW_LABEL_SHIFT 0          /**&lt; Flow Label shift */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert"></span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">/** @internal Returns IPv6 DSCP */</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#define ODPH_IPV6HDR_DSCP(ver_tc_flow) \</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">       (uint8_t)((((ver_tc_flow) &amp; 0x0fc00000) &gt;&gt; 22) &amp; 0xff)</span></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock">                                                                           </td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * IPv6 header</td><td> </td><td class="right"> * IPv6 header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       odp_u32be_t ver_tc_flow; /**&lt; Version / Traffic class / Flow label *
/</td><td> </td><td class="right">       odp_u32be_t ver_tc_flow; /**&lt; Version / Traffic class / Flow label *
/</td></tr>
      <tr><td class="left">       odp_u16be_t payload_len; /**&lt; Payload length */</td><td> </td><td class="right">       odp_u16be_t payload_len; /**&lt; Payload length */</td></tr>
      <tr><td class="left">       uint8_t    next_hdr;     /**&lt; Next header */</td><td> </td><td class="right">       uint8_t    next_hdr;     /**&lt; Next header */</td></tr>
      <tr><td class="left">       uint8_t    hop_limit;    /**&lt; Hop limit */</td><td> </td><td class="right">       uint8_t    hop_limit;    /**&lt; Hop limit */</td></tr>
      <tr><td class="left">       uint8_t    src_addr[16]; /**&lt; Source address */</td><td> </td><td class="right">       uint8_t    src_addr[16]; /**&lt; Source address */</td></tr>
      <tr><td class="left">       uint8_t    dst_addr[16]; /**&lt; Destination address */</td><td> </td><td class="right">       uint8_t    dst_addr[16]; /**&lt; Destination address */</td></tr>
      <tr><td class="left">} odph_ipv6hdr_t;</td><td> </td><td class="right">} odph_ipv6hdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0006" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_ipv6hdr_t)</span> == ODPH_IPV6HDR_LEN, <span class="delete">"ODPH_IPV6HD</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_ipv6hdr_t)</span> == ODPH_IPV6HDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">R_T__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_IPV6HDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * IPv6 Header extensions</td><td> </td><td class="right"> * IPv6 Header extensions</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       uint8_t    next_hdr;     /**&lt; Protocol of next header */</td><td> </td><td class="right">       uint8_t    next_hdr;     /**&lt; Protocol of next header */</td></tr>
      <tr><td class="left">       uint8_t    ext_len;      /**&lt; Length of this extension in 8 byte uni
ts,</td><td> </td><td class="right">       uint8_t    ext_len;      /**&lt; Length of this extension in 8 byte uni
ts,</td></tr>
      <tr><td class="left">                                   not counting first 8 bytes, so 0 = 8 byt
es</td><td> </td><td class="right">                                   not counting first 8 bytes, so 0 = 8 byt
es</td></tr>
      <tr><td class="left">                                   1 = 16 bytes, etc. */</td><td> </td><td class="right">                                   1 = 16 bytes, etc. */</td></tr>
      <tr><td class="left">       uint8_t    filler[6];    /**&lt; Fill out first 8 byte segment */</td><td> </td><td class="right">       uint8_t    filler[6];    /**&lt; Fill out first 8 byte segment */</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 6 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>10 lines changed or deleted</i></th><th><i> </i></th><th><i>58 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;ipsec.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;ipsec.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 40</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 40</em></th></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * IPSec ESP header</td><td> </td><td class="right"> * IPSec ESP header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       odp_u32be_t spi;     /**&lt; Security Parameter Index */</td><td> </td><td class="right">       odp_u32be_t spi;     /**&lt; Security Parameter Index */</td></tr>
      <tr><td class="left">       odp_u32be_t seq_no;  /**&lt; Sequence Number */</td><td> </td><td class="right">       odp_u32be_t seq_no;  /**&lt; Sequence Number */</td></tr>
      <tr><td class="left">       uint8_t    iv[0];    /**&lt; Initialization vector */</td><td> </td><td class="right">       uint8_t    iv[0];    /**&lt; Initialization vector */</td></tr>
      <tr><td class="left">} odph_esphdr_t;</td><td> </td><td class="right">} odph_esphdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_esphdr_t)</span> == ODPH_ESPHDR_LEN, <span class="delete">"ODPH_ESPHDR_T</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_esphdr_t)</span> == ODPH_ESPHDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_ESPHDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * IPSec ESP trailer</td><td> </td><td class="right"> * IPSec ESP trailer</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       uint8_t pad_len;      /**&lt; Padding length (0-255) */</td><td> </td><td class="right">       uint8_t pad_len;      /**&lt; Padding length (0-255) */</td></tr>
      <tr><td class="left">       uint8_t next_header;  /**&lt; Next header protocol */</td><td> </td><td class="right">       uint8_t next_header;  /**&lt; Next header protocol */</td></tr>
      <tr><td class="left">       uint8_t icv[0];       /**&lt; Integrity Check Value (optional) */</td><td> </td><td class="right">       uint8_t icv[0];       /**&lt; Integrity Check Value (optional) */</td></tr>
      <tr><td class="left">} odph_esptrl_t;</td><td> </td><td class="right">} odph_esptrl_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_esptrl_t)</span> == ODPH_ESPTRL_LEN, <span class="delete">"ODPH_ESPTRL_T</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_esptrl_t)</span> == ODPH_ESPTRL_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_ESPTRL_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * IPSec AH header</td><td> </td><td class="right"> * IPSec AH header</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       uint8_t    next_header;  /**&lt; Next header protocol */</td><td> </td><td class="right">       uint8_t    next_header;  /**&lt; Next header protocol */</td></tr>
      <tr><td class="left">       uint8_t    ah_len;       /**&lt; AH header length */</td><td> </td><td class="right">       uint8_t    ah_len;       /**&lt; AH header length */</td></tr>
      <tr><td class="left">       odp_u16be_t pad;         /**&lt; Padding (must be 0) */</td><td> </td><td class="right">       odp_u16be_t pad;         /**&lt; Padding (must be 0) */</td></tr>
      <tr><td class="left">       odp_u32be_t spi;         /**&lt; Security Parameter Index */</td><td> </td><td class="right">       odp_u32be_t spi;         /**&lt; Security Parameter Index */</td></tr>
      <tr><td class="left">       odp_u32be_t seq_no;      /**&lt; Sequence Number */</td><td> </td><td class="right">       odp_u32be_t seq_no;      /**&lt; Sequence Number */</td></tr>
      <tr><td class="left">       uint8_t    icv[0];       /**&lt; Integrity Check Value */</td><td> </td><td class="right">       uint8_t    icv[0];       /**&lt; Integrity Check Value */</td></tr>
      <tr><td class="left">} odph_ahhdr_t;</td><td> </td><td class="right">} odph_ahhdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_ahhdr_t)</span> == ODPH_AHHDR_LEN, <span class="delete">"ODPH_AHHDR_T__S</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_ahhdr_t)</span> == ODPH_AHHDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">IZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_AHHDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 3 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>6 lines changed or deleted</i></th><th><i> </i></th><th><i>6 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;udp.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;udp.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODPH_UDP_H_</td><td> </td><td class="right">#ifndef ODPH_UDP_H_</td></tr>
      <tr><td class="left">#define ODPH_UDP_H_</td><td> </td><td class="right">#define ODPH_UDP_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#include &lt;odp_api.h&gt;</td><td> </td><td class="right">#include &lt;odp_api.h&gt;</td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"></td><td> </td><td class="rblock"><span class="insert">#include &lt;odp/helper/chksum.h&gt;</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @addtogroup odph_header ODPH HEADER</td><td> </td><td class="right">/** @addtogroup odph_header ODPH HEADER</td></tr>
      <tr><td class="left"> *  @{</td><td> </td><td class="right"> *  @{</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** UDP header length */</td><td> </td><td class="right">/** UDP header length */</td></tr>
      <tr><td class="left">#define ODPH_UDPHDR_LEN 8</td><td> </td><td class="right">#define ODPH_UDPHDR_LEN 8</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** UDP header */</td><td> </td><td class="right">/** UDP header */</td></tr>
      <tr><td class="left">typedef struct ODP_PACKED {</td><td> </td><td class="right">typedef struct ODP_PACKED {</td></tr>
      <tr><td class="left">       odp_u16be_t src_port; /**&lt; Source port */</td><td> </td><td class="right">       odp_u16be_t src_port; /**&lt; Source port */</td></tr>
      <tr><td class="left">       odp_u16be_t dst_port; /**&lt; Destination port */</td><td> </td><td class="right">       odp_u16be_t dst_port; /**&lt; Destination port */</td></tr>
      <tr><td class="left">       odp_u16be_t length;   /**&lt; UDP datagram length in bytes (header+data
) */</td><td> </td><td class="right">       odp_u16be_t length;   /**&lt; UDP datagram length in bytes (header+data
) */</td></tr>
      <tr><td class="left">       odp_u16be_t chksum;   /**&lt; UDP header and data checksum (0 if not us
ed)*/</td><td> </td><td class="right">       odp_u16be_t chksum;   /**&lt; UDP header and data checksum (0 if not us
ed)*/</td></tr>
      <tr><td class="left">} odph_udphdr_t;</td><td> </td><td class="right">} odph_udphdr_t;</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * UDP checksum</td><td> </td><td class="right"> * UDP checksum</td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td><a name="diff0002" /></td></tr>
      <tr><td class="lblock"> * This function <span class="delete">uses odp packet to calc checksum</span></td><td> </td><td class="rblock"> * This function <span class="insert">calculates the UDP checksum given an odp packet.</span></td></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> * @param pkt  calculate chksum for pkt</td><td> </td><td class="right"> * @param pkt  calculate chksum for pkt</td></tr>
      <tr><td class="left"> * @return  checksum value in BE endianness</td><td> </td><td class="right"> * @return  checksum value in BE endianness</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left">static inline uint16_t odph_ipv4_udp_chksum(odp_packet_t pkt)</td><td> </td><td class="right">static inline uint16_t odph_ipv4_udp_chksum(odp_packet_t pkt)</td></tr>
      <tr><td class="left">{</td><td> </td><td class="right">{</td></tr>
      <tr><td><a name="diff0003" /></td></tr>
      <tr><td class="lblock">       <span class="delete">odph_ipv4hdr_t  *iph;</span></td><td> </td><td class="rblock">       uint16_t <span class="insert">chksum;</span></td></tr>
      <tr><td class="lblock"><span class="delete">       odph_udphdr_t   *udph;</span></td><td> </td><td class="rblock"><span class="insert">       int      rc;</span></td></tr>
      <tr><td class="lblock"><span class="delete">       uint32_t        sum;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       uint16_t        <span class="delete">udplen, *buf;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       union {</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               uint8_t v8[2];</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               uint16_t v16;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       } val;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0004" /></td></tr>
      <tr><td class="lblock">       <span class="delete">if (odp_packet_l4_offset(pkt) == ODP_PACKET_OFFSET_INVALID)</span></td><td> </td><td class="rblock">       <span class="insert">rc</span> = <span class="insert">odph_udp_tcp_chksum(pkt, ODPH_CHKSUM_RETURN, &amp;chksum);</span></td></tr>
      <tr><td class="lblock"><span class="delete">               return 0;</span></td><td> </td><td class="rblock">       return <span class="insert">(rc</span> == <span class="insert">0)</span> ? <span class="insert">chksum</span> : <span class="insert">0;</span></td></tr>
      <tr><td class="lblock"><span class="delete">       iph = (odph_ipv4hdr_t *)odp_packet_l3_ptr(pkt, NULL);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       udph = (odph_udphdr_t *)odp_packet_l4_ptr(pkt, NULL);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* 32-bit sum of UDP pseudo-header, seen as a series of 16-bit words</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete"> */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum = (iph-&gt;src_addr &amp; 0xFFFF) + (iph-&gt;src_addr &gt;&gt; 16) +</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                       (iph-&gt;dst_addr &amp; 0xFFFF) + (iph-&gt;dst_addr &gt;&gt; 16) +</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">                       udph-&gt;length;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       val.v8[0] = 0;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       val.v8[1]</span> = <span class="delete">iph-&gt;proto;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum += val.v16;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* 32-bit sum of UDP header (checksum field cleared) and UDP data, s</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">een</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">        * as a series of 16-bit words */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       udplen = odp_be_to_cpu_16(udph-&gt;length);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       buf = (uint16_t *)((void *)udph);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       for ( ; udplen &gt; 1; udplen -= 2)</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               sum += *buf++;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* Length is not a multiple of 2 bytes */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       if (udplen) {</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               val.v8[0] = *buf;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               val.v8[1] = 0;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">               sum += val.v16;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       }</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* Fold sum to 16 bits */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* Add carrier (0/1) to result */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum += (sum &gt;&gt; 16);</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* 1's complement */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       sum = ~sum;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock"><span class="delete">       /* Return checksum in BE endianness */</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">       return <span class="delete">(sum</span> == <span class="delete">0x0)</span> ? <span class="delete">0xFFFF</span> : <span class="delete">sum;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/** @internal Compile time assert */</td><td> </td><td class="right">/** @internal Compile time assert */</td></tr>
      <tr><td><a name="diff0005" /></td></tr>
      <tr><td class="lblock"><span class="delete">_ODP_STATIC_ASSERT(sizeof(odph_udphdr_t)</span> == ODPH_UDPHDR_LEN, <span class="delete">"ODPH_UDPHDR_T</span></td><td> </td><td class="rblock"><span class="insert">ODP_STATIC_ASSERT(sizeof(odph_udphdr_t)</span> == ODPH_UDPHDR_LEN,</td></tr>
      <tr><td class="lblock"><span class="delete">__SIZE_ERROR");</span></td><td> </td><td class="rblock">                 <span class="insert">"ODPH_UDPHDR_T__SIZE_ERROR");</span></td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">/**</td><td> </td><td class="right">/**</td></tr>
      <tr><td class="left"> * @}</td><td> </td><td class="right"> * @}</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">}</td><td> </td><td class="right">}</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 5 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>44 lines changed or deleted</i></th><th><i> </i></th><th><i>8 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><br/>
 
  <table class='diff_tbl' border="0" cellpadding="0" cellspacing="0"> 
  <tr bgcolor="orange"><th>&nbsp;odp_api.h (1.9.0.0)&nbsp;</th><th> </th><th>&nbsp;odp_api.h (1.10.0.0)&nbsp;</th></tr> 
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr bgcolor="gray" ><th><a name="part-l1" /><small>skipping to change at</small><em> line 21</em></th><th> </th><th><a name="part-r1" /><small>skipping to change at</small><em> line 21</em></th></tr>
      <tr><td class="left"> *</td><td> </td><td class="right"> *</td></tr>
      <tr><td class="left"> */</td><td> </td><td class="right"> */</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifndef ODP_API_H_</td><td> </td><td class="right">#ifndef ODP_API_H_</td></tr>
      <tr><td class="left">#define ODP_API_H_</td><td> </td><td class="right">#define ODP_API_H_</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td class="left">#ifdef __cplusplus</td><td> </td><td class="right">#ifdef __cplusplus</td></tr>
      <tr><td class="left">extern "C" {</td><td> </td><td class="right">extern "C" {</td></tr>
      <tr><td class="left">#endif</td><td> </td><td class="right">#endif</td></tr>
      <tr><td class="left"></td><td> </td><td class="right"></td></tr>
      <tr><td><a name="diff0001" /></td></tr>
      <tr><td class="lblock"><span class="delete">#include &lt;odp/api/config.h&gt;</span></td><td> </td><td class="rblock"></td></tr>
      <tr><td class="lblock">                                                                           </td><td> </td><td class="rblock"></td></tr>
      <tr><td class="left">#include &lt;odp/api/version.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/version.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/std_types.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/std_types.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/compiler.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/compiler.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/align.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/align.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/hash.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/hash.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/hints.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/hints.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/debug.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/debug.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/byteorder.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/byteorder.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/cpu.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/cpu.h&gt;</td></tr>
      <tr><td class="left">#include &lt;odp/api/cpumask.h&gt;</td><td> </td><td class="right">#include &lt;odp/api/cpumask.h&gt;</td></tr>

     <tr><td class="left"></td><td> </td><td class="right"></td></tr>
     <tr bgcolor="gray"><th colspan="5" align="center"><a name="end">&nbsp;End of changes. 1 change blocks.&nbsp;</a></th></tr>
     <tr class="stats"><th><i>2 lines changed or deleted</i></th><th><i> </i></th><th><i>0 lines changed or added</i></th></tr>
     <tr><td colspan="5" align="center" class="small"></td></tr>
   </table>
   <br/><div style='width:100%;' align='left' class='small'>This html diff was produced by rfcdiff 1.41.The latest version is available from <a href='http://tools.ietf.org/tools/rfcdiff/'>http://tools.ietf.org/tools/rfcdiff/</a></div>
</td></tr></table>
</body>
</html>
